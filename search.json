[{"title":"Ajax跨域的几种解决方案","url":"/2018/08/14/Ajax%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":" \n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个前后端分离越来越流行的时代，跨域请求对于我们来说已经非常常见了。关于跨域，有N种类型，本文只专注于ajax请求跨域。\n何为跨域请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。\n几种常见跨域请求\n\n\n请求地址\n服务器地址\n结果\n\n\n\nhttp://www.123.com\nhttp://www.abc.com\n(主域名不同，跨域)\n\n\nhttp://123.xiongchao.com\nhttp://abc.xiongchao.com\n(子域名不同，跨域)\n\n\nhttp://www.xiongchao.com:8080\nhttp://www.xiongchao.com:8081\n(端口不同，跨域)\n\n\nhttp://www.xiongchao.com\nhttps://www.xiongchao.com\n(协议不同，跨域)\n\n\n注意：localhost 和 localhost:8080、localhost 和 127.0.0.1 也属于跨域\n\n\n\n\n跨域情形请求代码：\nvar requestApi = &quot;http://localhost:8080/springmvc_hibernate_maven/&quot;;$.ajax(&#123;    type:&#x27;get&#x27;,    url:requestApi + &quot;test/userInfo&quot;,    dataType:&#x27;json&#x27;,    success:function(data)&#123;        console.log(data);    &#125;,    error:function(err)&#123;        console.log(err);    &#125;&#125;);\n\n服务器端java代码\n@Controller@RequestMapping(&quot;/test&quot;)public class Test &#123;\t@ResponseBody\t@RequestMapping(value = &quot;/userInfo&quot;,method = RequestMethod.GET)\tpublic String getUserInfo(HttpServletResponse httpServletResponse)&#123;\t\tUser user = new User();\t\tuser.setId(1);\t\tuser.setName(&quot;java&quot;);\t\tuser.setPassword(&quot;123456&quot;);\t\tuser.setLoginDate(&quot;2018-08-14&quot;);\t\tSystem.out.println(JSON.toJSONString(user));\t\treturn JSON.toJSONString(user);\t&#125;&#125;\n\n浏览器中访问（将html部署到nginx）结果:\n虽然请求成功并且返回了状态码200，但是并没有返回内容，并且控制台还打印了报错信息\n常见几种解决方案jsonp方式处理（基本被淘汰了）先看看json和jsonp数据格式的区别：\njson格式&#123;  &quot;id&quot;:&quot;1&quot;,  &quot;name&quot;:&quot;java&quot;,  &quot;password&quot;:&quot;123456&quot;,  &quot;loginDate&quot;:&quot;2018-08-14&quot;&#125;\n\njsonp格式callback(&#123;  &quot;id&quot;:&quot;1&quot;,  &quot;name&quot;:&quot;java&quot;,  &quot;password&quot;:&quot;123456&quot;,  &quot;loginDate&quot;:&quot;2018-08-14&quot;&#125;)\njsonp比json外面有多了一层，callback()。\n我们在请求的url后面拼接一个callback参数，用于返回jsonp格式数据\n$.ajax(&#123;    type:&#x27;get&#x27;,    url:requestApi + &quot;test/userInfo?callback=&quot;,    dataType:&#x27;jsonp&#x27;,    success:function(data)&#123;        console.log(data);    &#125;,    error:function(err)&#123;        console.log(err);    &#125;&#125;)\n\n服务器端处理：\n@Controller@RequestMapping(&quot;/test&quot;)public class Test &#123;\t@ResponseBody\t@RequestMapping(value = &quot;/userInfo&quot;,method = RequestMethod.GET)\tpublic String getUserInfo(HttpServletRequest request)&#123;                String callback = request.getParameter(&quot;callback&quot;);\t\tUser user = new User();\t\tuser.setId(1);\t\tuser.setName(&quot;java&quot;);\t\tuser.setPassword(&quot;123456&quot;);\t\tuser.setLoginDate(&quot;2018-08-14&quot;);\t\tSystem.out.println(JSON.toJSONString(user));\t\treturn callback+&quot;(&quot; + JSONObject.toJSONString(user) + &quot;)&quot;;\t&#125;&#125;\n\n我们看一下后台获取的callback的值\n修改请求代码再看一下后台获取的callback的值\n$.ajax(&#123;    type:&#x27;get&#x27;,    url:requestApi + &quot;test/userInfo&quot;,    dataType:&#x27;jsonp&#x27;,    jsonpCallback:&#x27;testCallback&#x27;,    success:function(data)&#123;        console.log(data);    &#125;,    error:function(err)&#123;        console.log(err);    &#125;&#125;)\n正是我们自定义的callback的值\n最后查看请求结果，控制台成功打印获取获取的数据\n需要注意的是jsonp是不支持post方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。另外可以使用jquer-jsonp插件实现跨域请求，服务器端无需做任何处理。java服务器端添加允许跨域请求的响应头ajax请求不用改，只需要添加响应头部Access-Control-Allow-Origin允许所有请求来源就可以了（所有服务器端处理都类似，对java不是很熟练，所以简单略过）\n@Controller@RequestMapping(&quot;/test&quot;)public class Test &#123;\t@ResponseBody\t@RequestMapping(value = &quot;/userInfo&quot;,method = RequestMethod.GET)\tpublic String getUserInfo(HttpServletResponse httpServletResponse)&#123;                httpServletResponse.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\t\tUser user = new User();\t\tuser.setId(1);\t\tuser.setName(&quot;java&quot;);\t\tuser.setPassword(&quot;123456&quot;);\t\tuser.setLoginDate(&quot;2018-08-14&quot;);\t\tSystem.out.println(JSON.toJSONString(user));\t\treturn JSON.toJSONString(user);\t&#125;&#125;\n\n结果：成功请求！\n比jsonp更强大的CORS方式解决跨域基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。\n这里介绍的是java后端应该如何配置以解决问题\n第一步：1.非maven项目：获取依赖jar包下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下2.mavne项目：添加如下依赖到pom.xml中\n&lt;dependency&gt;  &lt;groupId&gt;com.thetransactioncompany&lt;/groupId&gt;  &lt;artifactId&gt;cors-filter&lt;/artifactId&gt;  &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;\n\n第二步:添加CORS配置到项目的Web.xml中(&#x2F;WEB-INF&#x2F;web.xml)\n&lt;!-- 跨域配置 --&gt;&lt;filter&gt;  &lt;!-- The CORS filter with parameters --&gt;  &lt;filter-name&gt;CORS&lt;/filter-name&gt;  &lt;filter-class&gt;com.thetransactioncompany.cors.CORSFilter&lt;/filter-class&gt;  &lt;!-- Note: All parameters are options, if omitted the CORS Filter will     fall back to the respective default values. --&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.allowGenericHttpRequests&lt;/param-name&gt;    &lt;param-value&gt;true&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.allowOrigin&lt;/param-name&gt;    &lt;param-value&gt;*&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.allowSubdomains&lt;/param-name&gt;    &lt;param-value&gt;false&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.supportedMethods&lt;/param-name&gt;    &lt;param-value&gt;GET, HEAD, POST,PUT,DELETE OPTIONS&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.supportedHeaders&lt;/param-name&gt;    &lt;param-value&gt;Accept, Origin, X-Requested-With, Content-Type, Last-Modified&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.exposedHeaders&lt;/param-name&gt;    &lt;!--这里可以添加一些自己的暴露Headers --&gt;    &lt;param-value&gt;X-Test-1, X-Test-2&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.supportsCredentials&lt;/param-name&gt;    &lt;param-value&gt;true&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.maxAge&lt;/param-name&gt;    &lt;param-value&gt;3600&lt;/param-value&gt;  &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;  &lt;!-- CORS Filter mapping --&gt;  &lt;filter-name&gt;CORS&lt;/filter-name&gt;  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;\n请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的)\n除了上述配置，我们无需添加其他任何代码就可以尽情的使用GET,POST,PUT,DELETE等等这个方法了，是不是比jsonp强大多了\n现在我们再来正常请求和处理请求试一下\n$.ajax(&#123;    type:&#x27;delete&#x27;,    url:requestApi + &quot;test/userInfo&quot;,    dataType:&#x27;json&#x27;,    success:function(data)&#123;        console.log(data);    &#125;,    error:function(err,textStatus)&#123;        console.log(&quot;err&quot;,err);    &#125;&#125;)\n\n@Controller@RequestMapping(&quot;/test&quot;)public class Test &#123;\t@ResponseBody\t@RequestMapping(value = &quot;/userInfo&quot;,method = RequestMethod.DELETE)\tpublic String getUserInfo(HttpServletRequest request,HttpServletResponse response)&#123;\t\tUser user = new User();\t\tuser.setId(1);\t\tuser.setName(&quot;java&quot;);\t\tuser.setPassword(&quot;123456&quot;);\t\tuser.setLoginDate(&quot;2018-08-14&quot;);\t\treturn JSONObject.toJSONString(user); \t&#125;&#125;\n\n请求结果：可以看到有OPTIONS请求了\n","categories":["Ajax"],"tags":["ajax","跨域"]},{"title":"JavaScript封装XMLHttpRequest请求","url":"/2018/08/16/JavaScript%E5%B0%81%E8%A3%85XMLHttpRequest%E8%AF%B7%E6%B1%82/","content":"\n\n什么是 XMLHttpRequest 对象XMLHttpRequest 对象用于在后台与服务器交换数据。XMLHttpRequest 对象是开发者的梦想，因为您能够：\n\n在不重新加载页面的情况下更新网页\n在页面已加载后从服务器请求数据\n在页面已加载后从服务器接收数据\n在后台向服务器发送数据\n\n所有现代的浏览器都支持 XMLHttpRequest 对象，XMLHttpRequest在 Ajax 编程中被大量使用。\n原生javascript（ES5）封装XMLHttpRequest对象1.创建ajax.js\nfunction Ajax()&#123;&#125;Ajax.prototype.ajax = function(obj)&#123;    //创建xmlhttprequest对象    var xhr;    try&#123;        xhr = new XMLHttpRequest();    &#125;catch(e)&#123;        xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);    &#125;    xhr.timeout = 5000;    xhr.ontimeout = function (event) &#123;        console.log(&quot;请求超时&quot;);    &#125;    xhr.responseType = obj.dataType;    xhr.open(obj.type,obj.url,obj.async||true);        if(obj.headers&amp;&amp;obj.headers[&quot;Content-Type&quot;])&#123;        xhr.setRequestHeader(&quot;Content-Type&quot;,obj.headers[&quot;Content-Type&quot;]);    &#125;else&#123;        xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);    &#125;    xhr.onreadystatechange = function() &#123;        //xhr.readyState 4:完成，XMLHttpRequest对象读取服务器响应结束        if(xhr.readyState == 4)&#123;             //xhr.status HTTP状态码 2XX表示有效响应 304意味着是从缓存读取            if(xhr.status &gt;= 200 &amp;&amp; (xhr.status &lt; 300 || xhr.status == 304))&#123;                  obj.success(xhr.response)            &#125;else&#123;                obj.error(xhr.status)            &#125;        &#125;    &#125;    if(obj.data)&#123;        var params = [];        for (const key in obj.data) &#123;            if (obj.data.hasOwnProperty(key)) &#123;                params.push(encodeURIComponent(key) + &quot;=&quot; + encodeURIComponent(obj.data[key]))                        &#125;        &#125;        var postData = params.join(&#x27;&amp;&#x27;);        xhr.send(postData);    &#125;else&#123;        xhr.send();    &#125;&#125;\n\n2.引用ajax.js\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;./ajax.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;  var $$ = new Ajax();  var requestApi = &quot;http://localhost:8080/springmvc_hibernate_maven/&quot;;  window.onload = function()&#123;    $$.ajax(&#123;        type:&#x27;get&#x27;,        url:requestApi + &quot;test/userInfo&quot;,        dataType:&#x27;json&#x27;,        success:function(data)&#123;            console.log(data,&quot;get&quot;);        &#125;,        error:function(err)&#123;            console.log(err);        &#125;    &#125;)    $$.ajax(&#123;        type:&#x27;post&#x27;,        url:requestApi + &quot;test/userInfo&quot;,        data:&#123;            name:&quot;xiongchao&quot;,            password:&#x27;xiongchao&#x27;,            status:1        &#125;,        dataType:&#x27;json&#x27;,        success:function(data)&#123;            console.log(data,&quot;post&quot;);        &#125;,        error:function(err)&#123;            console.log(err);        &#125;    &#125;)    $$.ajax(&#123;        type:&#x27;put&#x27;,        url:requestApi + &quot;test/userInfo/4/1&quot;,        dataType:&#x27;json&#x27;,        success:function(data)&#123;            console.log(data,&#x27;put&#x27;);        &#125;,        error:function(err)&#123;            console.log(err);        &#125;    &#125;)    $$.ajax(&#123;        type:&#x27;delete&#x27;,        url:requestApi + &quot;test/userInfo/4&quot;,        dataType:&#x27;json&#x27;,        success:function(data)&#123;            console.log(data,&#x27;delete&#x27;);        &#125;,        error:function(err)&#123;            console.log(err);        &#125;    &#125;)&#125;&lt;/script&gt;\n\n3.顺带看下后端写法（哈哈,虽然不需要前端开发人员操心）\n4.最后看下四种请求的结果\nES6 封装XMLHttpRequest对象同样ajax.js 文件\nconst ajax = function(obj)&#123;  return new Promise((resolve,reject)=&gt;&#123;      //创建xmlhttprequest对象      var xhr;      try&#123;          xhr = new XMLHttpRequest();      &#125;catch(e)&#123;          xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);      &#125;      xhr.timeout = 5000;      xhr.ontimeout = function (event) &#123;          console.log(&quot;请求超时&quot;);      &#125;      xhr.responseType = obj.dataType;      xhr.open(obj.type,obj.url,obj.async||true);            if(obj.headers&amp;&amp;obj.headers[&quot;Content-Type&quot;])&#123;          xhr.setRequestHeader(&quot;Content-Type&quot;,obj.headers[&quot;Content-Type&quot;]);      &#125;else&#123;          xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);      &#125;      xhr.onreadystatechange = function() &#123;          //xhr.readyState 4:完成，XMLHttpRequest对象读取服务器响应结束          if(xhr.readyState == 4)&#123;               //xhr.status HTTP状态码 2XX表示有效响应 304意味着是从缓存读取              if(xhr.status &gt;= 200 &amp;&amp; (xhr.status &lt; 300 || xhr.status == 304))&#123;                    resolve(xhr.response);              &#125;else&#123;                  reject(xhr.response);              &#125;          &#125;      &#125;      if(obj.data)&#123;          var params = [];          for (const key in obj.data) &#123;              if (obj.data.hasOwnProperty(key)) &#123;                  params.push(encodeURIComponent(key) + &quot;=&quot; + encodeURIComponent(obj.data[key]))                          &#125;          &#125;          var postData = params.join(&#x27;&amp;&#x27;);          xhr.send(postData);      &#125;else&#123;          xhr.send();      &#125;  &#125;)&#125;export default ajax;\n\n引用ajax.js\n&lt;script type=&quot;module&quot;&gt;  import ajax from &#x27;./ajax.js&#x27;  var requestApi = &quot;http://localhost:8080/springmvc_hibernate_maven/&quot;;  window.onload = function()&#123;      ajax(&#123;          type:&#x27;get&#x27;,          url:requestApi + &quot;test/userInfo&quot;,          dataType:&#x27;json&#x27;      &#125;).then((data)=&gt;&#123;          console.log(data,&quot;get&quot;);      &#125;).catch((err)=&gt;&#123;          console.log(err);      &#125;)      ajax(&#123;          type:&#x27;post&#x27;,          data:&#123;              name:&quot;xiongchao&quot;,              password:&#x27;xiongchao&#x27;,              status:1          &#125;,          url:requestApi + &quot;test/userInfo&quot;,          dataType:&#x27;json&#x27;      &#125;).then((data)=&gt;&#123;          console.log(data,&quot;post&quot;);      &#125;).catch((err)=&gt;&#123;          console.log(err);      &#125;)      ajax(&#123;          type:&#x27;put&#x27;,          url:requestApi + &quot;test/userInfo/4/1&quot;,          dataType:&#x27;json&#x27;      &#125;).then((data)=&gt;&#123;          console.log(data,&quot;put&quot;);      &#125;).catch((err)=&gt;&#123;          console.log(err);      &#125;)      ajax(&#123;          type:&#x27;delete&#x27;,          url:requestApi + &quot;test/userInfo/4&quot;,          dataType:&#x27;json&#x27;      &#125;).then((data)=&gt;&#123;          console.log(data,&quot;delete&quot;);      &#125;).catch((err)=&gt;&#123;          console.log(err);      &#125;)  &#125;&lt;/script&gt;\n","categories":["Ajax"],"tags":["ajax"]},{"title":"Jquery Dom元素Index()方法的使用","url":"/2017/06/10/Jquery-Dom%E5%85%83%E7%B4%A0Index-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"\n\n\n前言作为一个做后端java开发的被强行拉到前端组的菜鸟，前端知识略懂皮毛的我对于jquery很多常用方法都有误区，比如我现在要说的jquery DOM元素的index()方法。\njquery获取元素索引值index()方法使用误区由于对index()方法理解不是很深，所以在做项目时就遇到了有的页面获取的索引是正常的有的页面获取的索引总是大了2个，然后为了让最后的结果正常我就直接减2，并在后面注释”&#x2F;&#x2F;这里不知道为什么总是多了2，但其他页面又是正常的”，结果组长偶然一次机会看到了我这个注释就批评我说“哪有人这么写代码的”。唉，糗事就不多说了，以后写代码再也不敢这样了。\njquery获取元素索引值index()方法作用用法一：$(select).index();\n\n示例一：\n\n\n# html代码:&lt;div class=&quot;main&quot;&gt;  &lt;div class=&quot;box&quot;&gt;Milk&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;Tea&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;Coffee&lt;/div&gt; &lt;/div&gt;\n# js代码：$(&quot;.box&quot;).on(&quot;click&quot;,function()&#123;  $(this).index();//结果：如果点击的Milk则返回 0&#125;);\n\n\n\n这个示例看起来是获取的自己在与自己相同元素中的位置，那么看实例二\n\n\n示例二：\n\n\n# html代码:&lt;div class=&quot;main&quot;&gt;  &lt;p&gt;Soda&lt;/p&gt;  &lt;div class=&quot;box&quot;&gt;Milk&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;Tea&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;Coffee&lt;/div&gt; &lt;/div&gt; \n# js代码：$(&quot;.box&quot;).on(&quot;click&quot;,function()&#123;  $(this).index();//结果：如果点击的Milk则返回 1&#125;);\n从以上两个示例可以看出$(select).index()即使在没有参数的情况下也是相对用法，这个相对用法是相对其父元素中的位置，而不是获取自己在相同元素中的位置\n用法二：$(select1).index(select2);\n\n示例：\n\n\n# html代码:&lt;p class=&quot;box&quot;&gt;Tea&lt;/p&gt;&lt;div class=&quot;main&quot;&gt;  &lt;p&gt;Soda&lt;/p&gt;  &lt;div class=&quot;box&quot;&gt;Milk&lt;/div&gt;  &lt;div class=&quot;box&quot; id=&quot;box2&quot;&gt;Tea&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;Coffee&lt;/div&gt;&lt;/div&gt;\n# js代码:$(&quot;.box&quot;).index($(&quot;#box2&quot;));//结果: 2\n\n通过这个示例可以看出**$(select1).index(select2)的用法是选择器select2相对于选择器select1**的位置索引，跟同辈元素和其父辈元素都无关。\n总结虽然index()的用法比较简单，但是理解不深的话在项目中运用出了问题还是麻烦的，特别是对于我这个前端菜鸟出现果过这种尴尬的事情还是记录下来比较好，以免以后再跳进同一个坑。\n","categories":["javascript"],"tags":["jquery"]},{"title":"Markdown","url":"/2017/06/09/Markdown/","content":"\n\n我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：\n\n\n整理知识，学习笔记\n发布日记，杂文，所见所想\n撰写发布技术文稿（代码支持）\n撰写发布学术论文（LaTeX 公式支持）\n\n\n\n除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：\nWindows&#x2F;Mac&#x2F;Linux 全平台客户端\n请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的  新文稿 或者使用快捷键 Ctrl+Alt+N。\n\n\n什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以\n1. 制作一份待办事宜 Todo 列表\n 支持以 PDF 格式导出文稿\n 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n 新增 Todo 列表功能\n 修复 LaTex 公式渲染问题\n 新增 LaTex 公式编号功能\n\n2. 书写一个质能守恒公式[^LaTeX]$$E&#x3D;mc^2$$\n3. 高亮一段代码[^code]@requires_authorizationclass SomeClass:    passif __name__ == &#x27;__main__&#x27;:    # A comment    print &#x27;hello world&#x27;\n\n4. 高效绘制 流程图st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op\n\n5. 高效绘制 序列图Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!\n\n6. 高效绘制 甘特图title 项目开发流程section 项目确定    需求分析       :a1, 2016-06-22, 3d    可行性报告     :after a1, 5d    概念验证       : 5dsection 项目实施    概要设计      :2016-07-05  , 5d    详细设计      :2016-07-08, 10d    编码          :2016-07-15, 10d    测试          :2016-07-22, 5dsection 发布验收    发布: 2d    验收: 3d\n\n7. 绘制表格\n\n\n项目\n价格\n数量\n\n\n\n计算机\n$1600\n5\n\n\n手机\n$12\n12\n\n\n管线\n$1\n234\n\n\n8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。\n总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。\n\n什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑&#x2F;发布&#x2F;阅读 Markdown 的在线平台——您可以在任何地方，任何系统&#x2F;设备上管理这里的文字。\n1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！\n2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。\n\n3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！\n4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。\n5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。\n6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏：\n\n通过管理工具栏可以：\n 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通&#x2F;Vim&#x2F;Emacs 编辑模式\n7. 阅读工具栏\n通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。\n工具栏上的五个图标依次为：\n 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境\n8. 阅读模式在 阅读工具栏 点击  或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。\n9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档：\n标签： 未分类\n标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：\n\n10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击  (Ctrl+Alt+P) 发布这份文档给好友吧！\n\n再一次感谢您花费时间阅读这份欢迎稿，点击  (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！\n作者 @ghosert2016 年 07月 07日    \n[^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i&#x3D;1}^n a_i&#x3D;0$， 访问 MathJax 参考更多使用方法。\n[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。\n","categories":["Markdown"],"tags":["Markdown"]},{"title":"Qiniu-image-tool-实现图片一键上传七牛云","url":"/2018/07/02/Qiniu-image-tool-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%80%E9%94%AE%E4%B8%8A%E4%BC%A0%E4%B8%83%E7%89%9B%E4%BA%91/","content":"\n\n&ensp;&ensp;&ensp;&ensp;写博客当然少不了云储存了，那为什么推荐使用七牛云呢，当然是因为七牛云储存提供10G的免费空间,以及每月10G的流量，存放个人博客外链图片最好不过了，七牛云储存还有各种图形处理功能、缩略图、视频存放速度也给力。&ensp;&ensp;&ensp;&ensp;qiniu-image-tool是一个提升 markdown 贴图体验的实用小工具，支持windows 及 mac。其中 qiniu-image-tool-win 为windows版本，基于AutoHotkey和qshell实现，一键上传图片或截图至七牛云，获取图片的markdown引用至剪贴板，并自动粘贴到当前编辑器。\n用法\n复制本地图片、视频、js等文件至剪贴板（ctrl+c）or 使用喜欢的截图工具截图 or 直接复制网络图片.\n切换到编辑器，ctrl+alt+v便可以看到图片链接自动粘贴到当前编辑器的光标处（同时链接也会保存在粘贴板里）\n\n预览效果图：\n本地图片文件上传\n\n截图上传\n\n其它文件上传\n\n\n安装首先从 github 下载release版本（有两个版本：2.0 正式版和1.0 正式版，推荐使用2.0 正式版）并解压到任意目录\n目录结构应如下：\n其中dump-clipboard-png.ps1是保存截图的powershell脚本，qiniu-image-upload.ahk 即完成文件上传的AutoHotkey脚本。\n配置脚本打开settings.ini文件，右键选择编辑脚本使脚本在编辑器中打开，找到下面这段代码:\n\n修改这里的五个配置项的值，其中前四个配置项都与七牛账号相关：\nACCESS_KEY &amp; SECRET_KEY这是qshell操作个人账号的账号凭证，登陆七牛账号后在个人面板-&gt;密钥管理中查看，或者直接访问查看。\nBUCKET_NAME &amp; BUCKET_DOMAIN在对象存储-&gt;存储空间列表中选择或新建一个存储空间即bucket，点击该bucket在右边看到一个测试域名，该域名即bucketDomain是图片上传后的访问域名。这里要特别注意域名不要少了前面的 ***http头 *** 和最后的那个 斜杠。\n运行脚本配置完成以后以管理员身份运行qImage.exe，这时便可以使用ctrl+alt+v尝试上传图片了。\n调试如果以上操作完成后没有按照预期达到图片上传的效果，感兴趣的筒子可以先自己调试找一下原因，一般报错信息会打印在cmd命令行中，但是cmd窗口一闪而过可能看不清楚，这时候将可选参数DEBUG_MODE &#x3D; false 改为DEBUG_MODE &#x3D; true打开调试模式，再次尝试，这时候cmd窗口不会自动关闭，便可以看到具体的报错信息从而对症下药解决问题。\n","categories":["云储存"],"tags":["upload"]},{"title":"css常用奇淫技巧(不定期更新)","url":"/2018/08/30/css%E5%B8%B8%E7%94%A8%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7-%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0/","content":"\n一、常用技巧清除浮动\n添加新的元素 、应用 clear：both; \n父级定义 overflow: auto;\n父元素也设置浮动;\n使用br标签和其自身的html属性:《br clear&#x3D;”all”&#x2F;》 clear&#x3D;”all | left | right | none”;\n最高大上的方法，强烈推荐 parentDom:after{content: “ “;display: block;clear: both;}\n\n垂直居中&lt;div class=&quot;box box1&quot;&gt;  &lt;span&gt;垂直居中&lt;/span&gt;&lt;/div&gt;\n.box &#123;  width: 200px;  height: 200px;  background: red;&#125; \n\n方法1：table-cell.box1 &#123;  display: table-cell;  vertical-align: middle;  text-align: center;&#125;\n方法2：display:flex（部分低版本浏览器不兼容）.box2 &#123;  display: flex;  justify-content:center;  align-items:Center;&#125;\n\n方法3：绝对定位和负边距(已知元素高度).box3 &#123;position:relative;&#125;.box3 span &#123;    position: absolute;    width:100px;    height: 50px;    top:50%;    left:50%;    margin-left:-50px;    margin-top:-25px;    text-align: center;&#125;\n\n方法4：绝对定位和0(已知元素高度).box &#123;position:relative;&#125;.box4 span &#123;  width: 50%;   height: 50%;   background: #000;  overflow: auto;   margin: auto;   position: absolute;   top: 0; left: 0; bottom: 0; right: 0; &#125;\n\n方法5：display:flex和margin:auto.box5 &#123;    display: flex;    text-align: center;&#125;.box5 span &#123;margin: auto;&#125;\n\n文本超出部分隐藏单行文本超出部分隐藏#ellipsis &#123;  overflow: hidden;   /*超出的文本隐藏*/  text-overflow: ellipsis;    /*溢出用省略号显示*/  white-space: nowrap;    /*溢出不换行*/&#125;\n\n多行文本超出部分隐藏#ellipsis &#123;  overflow: hidden;   display: -webkit-box;   /*作为弹性伸缩盒子模型显示*/  -webkit-box-orient: vertical;   /*设置伸缩盒子的子元素排列方式--从上到下垂直排列*/  -webkit-line-clamp: 2;   /*显示的行*/&#125;\n\n二、形状技巧三角形#triangle1 &#123;  width: 0;  height: 0;  border-top: 50px solid red;  border-right: 50px solid orange;  border-bottom: 50px solid yellow;  border-left: 50px solid green;&#125;#triangle2 &#123;  width: 0;  height: 0;  border-top: 50px solid red;  border-right: 50px solid transparent;  border-bottom: 50px solid transparent;  border-left: 50px solid transparent;&#125;\n\n未读数量#superscript &#123;    width: 50px;    height: 50px;    background: red;    padding:0 20px;    border-radius: 20px;&#125;\n\n字体边框同色#app&#123;    width: 100px;    height: 100px;    color: red;    font-size: 30px;    /*方案一    CSS3 currentColor 表示当前的文字颜色*/    /* border: 10px solid currentColor; */        /*方案二    border 的默认值 (initial) 就是 currentColor*/    border: 10px solid;  &#125;\n\n放大镜#div5&#123;    width: 50px;    height: 50px;    border: 5px solid #000000;    border-radius: 50%;    position: relative;&#125;#div5::after&#123;    content: &#x27; &#x27;;    display: block;    width: 8px;    height: 60px;    border-radius: 5px;    background: #000000;    position: absolute;    right: -22px;        top: 38px;    transform: rotate(-45deg);&#125;\n\n","categories":["前端"],"tags":["CSS"]},{"title":"sessionStorage和localStorage解释及区别","url":"/2018/08/07/essionStorage%E5%92%8ClocalStorage%E8%A7%A3%E9%87%8A%E5%8F%8A%E5%8C%BA%E5%88%AB/","content":"\n\nHTML5的本地存储HTML5中与本地存储相关的两个重要内容：Web Storage与本地数据库。其中，Web Storage存储机制是对HTML4中cookie存储机制的一个改善。由于cookie存储机制有很多缺点，HTML5不再使用它，转而使用改良后的Web Storage存储机制。本地数据库是HTML5中新增的一个功能，使用它可以在客户端本地建立一个数据库，原本必须保存在服务器端数据库中的内容现在可以直接保存在客户端本地了，这大大减轻了服务器端的负担，同时也加快了访问数据的速度。\n本文主要来讲解Web Storage我们知道，在HTML4中可以使用cookie在客户端保存诸如用户名等简单的用户信息，但是，通过长期的使用，你会发现，用cookie存储永久数据存在以下几个问题：\n1.大小：cookie的大小被限制在4KB。\n2.带宽：cookie是随HTTP事务一起被发送的，因此会浪费一部分发送cookie时使用的带宽。\n3.复杂性：要正确的操纵cookie是很困难的。\n针对这些问题，在HTML5中，重新提供了一种在客户端本地保存数据的功能，它就是Web Storage。\n具体来说，Web Storage又分为两种：1.sessionStorage：将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据。\n2.localStorage：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。\n这两者的区别在于，sessionStorage为临时保存，而localStorage为永久保存。\n到目前为止，Firefox3.6以上、Chrome6以上、Safari 5以上、Pera10.50以上、IE8以上版本的浏览器支持sessionStorage与localStorage的使用。WebStorage的目的是克服由cookie所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。\nWebStorage两个主要目标：（1）提供一种在cookie之外存储会话数据的路径。（2）提供一种存储大量可以跨会话存在的数据的机制。\nHTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage（会话存储）。1、生命周期：localStorage:localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。　　sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。\n2、存储大小：localStorage和sessionStorage的存储数据大小一般都是：5MB\n3、存储位置：localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。\n4、存储内容类型：localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理\n5、获取方式：localStorage：window.localStorage;；sessionStorage：window.sessionStorage;\n6、应用场景：localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录；\nWebStorage的优点：（1）存储空间更大：cookie为4KB，而WebStorage是5MB；\n（2）节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样每次请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量；\n（3）对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便；\n（4）快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快；\n（5）安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题；\nWebStorage提供了一些方法，数据操作比cookie方便；\nsetItem（key, value） ——  保存数据，以键值对的方式储存信息。\n\ngetItem（key） ——  获取数据，将键值传入，即可获取到对应的value值。\n\nremoveItem（key） ——  删除单个数据，根据键值移除对应的信息。\n\nclear（） ——  删除所有的数据\n\nkey（index） —— 获取某个索引的key\n\n\ncookie 、sessionStorage与localStorage的区别特性cookiesessionStoragelocalStorage数据生命期生成时就会被指定一个maxAge值，这就是cookie的生存周期，在这个周期内cookie有效，默认关闭浏览器失效页面会话期间可用除非数据被清除，否则一直存在存放数据大小4K左右（因为每次http请求都会携带cookie）一般5M或更大详细看这(需科学上网)与服务器通信由对服务器的请求来传递，每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题数据不是由每个服务器请求传递的，而是只有在请求时使用数据，不参与和服务器的通信易用性cookie需要自己封装setCookie，getCookie可以用源生接口，也可再次封装来对Object和Array有更好的支持共同点都是保存在浏览器端，和服务器端的session机制不同（这里有一篇很好的介绍cookie和session的文章）\n\n示例：（1） 新建两个文件：\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;a href=&quot;./test.html&quot; target=&quot;_blank&quot;&gt;跳到test.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    localStorage.setItem(&quot;xiongchao&quot;,123);    sessionStorage.setItem(&quot;xiongchao&quot;,456);&lt;/script&gt;\n\n（2） 部署服务（推荐使用nignx做反向代理,比tomcat简单粗暴，也可以不用这一步，只是为了模拟真实网站会话）\n（3） 打开index.html,并使用链接打开test.html\n两个页面的结果是一样的，这是一次会话，sessionStorage储存的内容被保存下来。\n（4） 单独打开test.html,会发现sessionStorage是空的。\n","categories":["javascript"],"tags":["sessionStorage","localStorage"]},{"title":"git常用命令","url":"/2018/07/08/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"\ngit的工作原理图解：\n将指定文件添加到暂存区(stage)\n\n将暂存区的所有内容提交到当前分支\n\n分支的创建与合并\n\n\ngit的使用步骤：基本使用git add . //如果有删除的文件则：git add -Agit commit -m&quot;first commit&quot;//这一步可能会进入一个奇怪的窗口，需执行 ESC :wqgit pull --rebase origin master//如果有冲突则解决冲突，然后执行第一步，最后执行以下命令git rebase --continuegit push origin master//push时有可能会提示没有change-id//复制提示中的&quot;gitdir=$(git rev-parse --git-dir); scp -p -P 29418 //xiongchao@192.168.1.192:hooks/commit-msg $&#123;gitdir&#125;/hooks/&quot;git commit -amend\n\n如果你正在完成某一个功能不能提交代码，然后又需要用到远程仓库中同事刚提交的代码，则只需要执行以下命令git stashgit pullgit stash pop //可能有冲突，改冲突，可直接运行项目\n\ncherry-pick用法（A分支的内容添加到B分支,此操作是在B分支上）git reflog//复制要cherry-pick的commit id（有说明的那一行）git cherry-pick commitidgit push origin master\n\ngit的常用命令解释：$ git status查看工作区状态；\n$ git add readme.txt将指定文件添加到暂存区(stage);反复多次使用，添加多个文件；\n$ git add .将所有文件添加到Git仓库暂存区；\n$ git commit -m “wrote a readme file”将暂存区的所有内容提交到当前分支；\n$ git checkout – readme.txt”把** readme.txt 文件在工作区的修改全部撤销，这里有两种情况：一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt**已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。\n$ rm test.txt”从版本库暂存区中删除该文件；\n$ git push origin master把当前分支master的内容推送到远程库；\n$ git pull –rebase origin master拉取远程库master分支的内容到本地仓库；\n$ git reset HEAD~将前版本回退到上一个版本；上上一个版本就是HEAD~~，上100个版本写成HEAD~100；\n$ git reset –hard 1094a将前版本回退到指定版本；\n$ git stash将你当前未提交（包括暂存的和非暂存的）到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的,需要说明一点，stash是本地的，不会通过git push命令上传到git server上；\n$ git stash pop将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下；\n$ git stash list查看现有stash；\n$ git stash drop移除stash；或者使用git stash clear命令，删除所有缓存的stash；\n$ git branch dev创建dev分支；\n$ git checkout dev切换到dev分支；\n$ git branch查看当前分支；\n$ git merge dev把dev分支的工作成果合并到master分支上；\n$ git branch -d dev删除dev分支；\n$ git clone将远程仓库克隆到本地；\n$ git log查看提交日志；\n$ git reflog记录你的每一次命令；\n","categories":["工具"],"tags":["git"]},{"title":"js Date对象的详细使用","url":"/2018/07/19/js%20Date%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/","content":"\n\n前言：&ensp;&ensp;&ensp;&ensp;最近发现Date对象在项目中真的是无处不在，几乎做过的所有项目中都有Date的各种用法，然而每次要使用的时候都是各种百度，自己既没有掌握Date的详细用法，也使得每次做项目都浪费很多时间，所以特此研究一下记录下来。\n一：Date()对象基本方法示例：//Date()：返回当日的日期和时间。var date = new Date();//Thu Jul 19 2018 10:46:06 GMT+0800// getDay()：从 Date 对象返回一周中的某一天 (0 ~ 6)。date.getDay();\t\t//4 今天是星期四// getFullYear()：从 Date 对象以四位数字返回年份。date.getFullYear();\t\t//2018// getMonth()：从 Date 对象返回月份 (0 ~ 11)。date.getMonth();\t\t//6// getDate()：从 Date 对象返回一个月中的某一天 (1 ~ 31)。date.getDate();\t\t//19// getHours()：返回 Date 对象的小时 (0 ~ 23)。date.getHours();\t\t//10// getMinutes()：返回 Date 对象的分钟 (0 ~ 59)。date.getMinutes();\t\t//53// getSeconds()：返回 Date 对象的秒数 (0 ~ 59)。date.getSeconds();\t\t//5// getMilliseconds()：返回 Date 对象的毫秒(0 ~ 999)。date.getMilliseconds();\t\t//522// getTime()：返回 1970 年 1 月 1 日至今的毫秒数。date.getTime();\t\t//1531968785522// setFullYear()：设置 Date 对象中的年份（四位数字）。date.setFullYear(1995); //1531968785522// setMonth()：设置 Date 对象中月份 (0 ~ 11)。date.setMonth(8); //Wed Sep 19 2018 11:51:48 GMT+0800 (中国标准时间)// setDate()：设置 Date 对象中月的某一天 (1 ~ 31)。date.setDate(25); //Wed Jul 25 2018 11:52:15 GMT+0800 (中国标准时间)// setTime()：以毫秒设置 Date 对象。date.setTime(77771564221); console.log(date) //Mon Jun 19 1972 11:12:44 GMT+0800 (中国标准时间)// toTimeString()：把 Date 对象的时间部分转换为字符串。console.log(date.toTimeString()); =&gt; 11:58:45 GMT+0800 (中国标准时间)// toDateString()：把 Date 对象的日期部分转换为字符串。console.log(date.toDateString()); =&gt; Thu Jul 19 2018\n\n\n二：Date()对象组合高级用法：//将毫秒转换为yyyy-MM-dd HH:mm:ss日期格式function dateFormat(seconds) &#123;    let date = new Date(seconds),        year = date.getFullYear(),        month = date.getMonth() + 1,        day = date.getDate(),        hour = date.getHours(),        min = date.getMinutes(),        s = date.getSeconds();    return `$&#123;year&#125;-$&#123;formatNum(month)&#125;-$&#123;formatNum(day)&#125; $&#123;formatNum(hour)&#125;:$&#123;formatNum(min)&#125;:$&#123;formatNum(s)&#125;`;&#125;//转换为yyyy-MM-dd日期格式function dateFormatShort(date) &#123;    let year = date.getFullYear(),    month = date.getMonth() + 1,    day = date.getDate();    return `$&#123;year&#125;-$&#123;formatNum(month)&#125;-$&#123;formatNum(day)&#125;`;&#125;//将yyyy-MM-dd HH:mm:ss转化为毫秒数function formatMilliseconds(str)&#123;    // str = &#x27;2018-7-19 15:14:30&#x27;;    str = str.replace(/-/g,&#x27;/&#x27;);//由于部分浏览器以及一些低版本浏览器不兼容new Date(yyyy-MM-dd HH:mm:ss)    let date = new Date(str);    return date.getTime();&#125;//获取两个时间的秒数差function SecondsDiff(startDate,endDate)&#123;    startDate = &quot;2018-7-18 10:56:23&quot;,endDate = &quot;2018-7-19 12:00:00&quot;;    let startTime = formatMilliseconds(startDate),//获得毫秒数        endTime = formatMilliseconds(endDate),        milliseconds = endTime - startTime;//毫秒数之差    return parseInt(milliseconds/1000);&#125;//根据剩余秒数获取剩余HH:mm:ss（应用在活动倒计时或物品过期还有多久&#x27;dd天HH小时&#x27;）function secondsFormat(seconds)&#123;    seconds = SecondsDiff();    let day = Math.floor(seconds / 3600 / 24),        hour = Math.floor((seconds % 86400) / 3600),        min = Math.floor((seconds % 86400 % 3600) / 60 ),        second = Math.floor(seconds % 86400 % 3600 % 60);        hour += day * 24;    return `$&#123;formatNum(hour)&#125;:$&#123;formatNum(min)&#125;:$&#123;formatNum(second)&#125;`;//为什么只计算天数,因为一般活动只在相邻几天&#125;    //获得某月的天数　　 function getMonthDays(year, month) &#123;    let nowDate = new Date(year,month,0),        days = nowDate.getDate();    return days;&#125;//补0操作function formatNum(e) &#123;    return e &gt;= 10 ? e : `0$&#123;e&#125;`;&#125;\t\n\n\n三：对当前时间的判定：//判断时间是否是今天function isToday(str)&#123;    str = new Date(str.replace(/-/g,&quot;/&quot;));    if (str.toDateString() === new Date().toDateString()) &#123;//今天        return true;    &#125; else if (new Date(str) &gt; new Date())&#123;        return false;    &#125;&#125;/*** 判断某个时间是前天、昨天、今天、明天、后天* @now:当前服务器时间*/function daysText(str,now)&#123;    let date = str.substring(0,str.indexOf(&quot;-&quot;)+6);    now = new Date(now.replace(/-/g,&#x27;/&#x27;));    now = new Date(now.getFullYear(), now.getMonth(), now.getDate());    str = new Date(str.replace(/-/g,&#x27;/&#x27;));    str = new Date(str.getFullYear(), str.getMonth(), str.getDate());    let diff = (str - now) / 1000 / 60 / 60 / 24;    if (diff &lt; -1) &#123;        return &quot;前天&quot;;    &#125; else if (diff &lt; -0) &#123;        return &quot;昨天&quot;    &#125; else if (diff == 0) &#123;        return &quot;今天&quot;;    &#125; else if (diff &lt; 2) &#123;        return &quot;明日&quot;;    &#125; else if (diff &lt; 3) &#123;        return &quot;后天&quot;;    &#125; else &#123;        return date;    &#125;&#125;//判断是否超过48小时function overTime(seconds) &#123;    let diffSeconds = Math.floor((new Date().getTime() - seconds)/1000),        days = Math.floor(diffSeconds / 86400),        hour = Math.floor(diffSeconds % 86400 / 3600),        min = Math.floor((diffSeconds % 86400 % 3600) / 60 )        second = Math.floor(diffSeconds % 86400 % 3600 % 60);    if(days&gt;2)&#123;//超过两天超时        return 0;    &#125;else if(days==2)&#123; //刚好两天判断时分秒        if(hour==0)&#123;             if(min==0)&#123;                if(second==0)&#123;                    return 1;                &#125;else&#123; //有多余秒数，超时                    return 0;                &#125;            &#125;else&#123; //有多余分钟，超时                return 0;            &#125;        &#125;else&#123; //还有多余小时，超时            return 0;        &#125;    &#125;else &#123; //小于两天则没有超时        return 1;    &#125;&#125;/** * 判断某个时间相对于现在过了多久 * seconds:毫秒数 */function pastTimes(seconds)&#123;    //得到时间    let dateTime;    //传入时间    let starDate = new Date(seconds),        starYear = starDate.getFullYear(), //年        starMonth = starDate.getMonth() + 1, //月        starDay = starDate.getDate(),     //日        starHour = starDate.getHours(),   //时        starMin = starDate.getMinutes(),  //分        starSen = starDate.getSeconds(); //秒    //当前时间    let nowDate = new Date(),        nowYear = nowDate.getFullYear(), //年        nowMonth = nowDate.getMonth() + 1, //月        nowDay = nowDate.getDate(),     //日        nowHour = nowDate.getHours(),   //时        nowMin = nowDate.getMinutes(),  //分        nowSen = nowDate.getSeconds();  //秒    //判断是否在同一年    if (starYear == nowYear) &#123;        //判断是否是同一个月        if (starMonth == nowMonth) &#123;             //判断在今天昨天或者前天            let diffDay = nowDay - starDay;            if (diffDay == 0) &#123;//今天                //判断小时数                let diffHours = nowHour - starHour;                let diffMinutes = nowMin - starMin;                if (diffHours == 0) &#123;                    if (diffMinutes &gt;= 0 &amp;&amp; diffMinutes &lt; 2) &#123;                        dateTime = &quot;刚刚&quot;;                    &#125; else if (diffMinutes &gt;= 2) &#123;                        dateTime = diffMinutes + &quot;分钟前&quot;;                    &#125;                &#125;else if (diffHours == 1) &#123;                    if (diffMinutes &lt; 0) &#123;                        let minute = (60 - starMin) + (nowMin - 0);                        dateTime = minute + &quot;分钟前&quot;;                    &#125; else if (diffMinutes &gt; 0) &#123;                        dateTime = &quot;1个小时前&quot;;                    &#125;                &#125;else if (diffHours == 2) &#123;                     if (diffMinutes &lt; 0) &#123;                        dateTime = &quot;1个小时前&quot;;                    &#125; else if (diffMinutes &gt; 0) &#123;                        dateTime = &quot;2个小时前&quot;;                    &#125;                &#125;else&#123;                    dateTime = formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);                &#125;            &#125;else if(diffDay == 1) &#123;//昨天                dateTime = &#x27;昨天&#x27; + formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);            &#125;else if (diffDay == 2) &#123;//前天                dateTime = &#x27;前天&#x27; + formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);            &#125;else&#123;                dateTime = formatNum(starMonth) + &#x27;-&#x27; + formatNum(starDay) + &#x27; &#x27; + formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);            &#125;        &#125;else&#123;            //不在同一个月且在同一年的不显示年份            dateTime = formatNum(starMonth) + &#x27;-&#x27; + formatNum(starDay) + &#x27; &#x27; + formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);        &#125;    &#125;else&#123;        //不在同一年的显示年月日时分        dateTime = starYear + &#x27;-&#x27; + formatNum(starMonth) + &#x27;-&#x27; + formatNum(starDay) + &#x27; &#x27; + formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);    &#125;    return dateTime    &#125;","categories":["javascript"],"tags":["js","date"]},{"title":"js 将对象数组中具有相同值的对象取出组成新的数组","url":"/2018/07/26/js-%E5%B0%86%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E5%80%BC%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%96%E5%87%BA%E7%BB%84%E6%88%90%E6%96%B0%E7%9A%84%E6%95%B0%E7%BB%84/","content":"\n\n实现方法：let arr = [  &#123;    &quot;id&quot;: 577,    &quot;name&quot;: &quot;艾杜纱 毛孔洁净洗面奶&quot;,    &quot;skuName&quot;: &quot;125mL&quot;,    &quot;image&quot;: &quot;commodityImage/haZW5gLF.jpg&quot;,    &quot;price&quot;: 122.32,    &quot;store&quot;: 327,    &quot;status&quot;: 1,    &quot;brandId&quot;: 18,    &quot;categoryId&quot;: 32  &#125;, &#123;    &quot;id&quot;: 536,    &quot;name&quot;: &quot;心机彩妆 星魅霓光唇膏&quot;,    &quot;skuName&quot;: &quot;BE300&quot;,    &quot;image&quot;: &quot;commodityImage/ibg54OOx.jpg&quot;,    &quot;price&quot;: 273.65,    &quot;store&quot;: 50,    &quot;status&quot;: 1,    &quot;brandId&quot;: 17,    &quot;categoryId&quot;: 33  &#125;, &#123;    &quot;id&quot;: 546,    &quot;name&quot;: &quot;心机彩妆 炫眉膏&quot;,    &quot;skuName&quot;: &quot;77&quot;,    &quot;image&quot;: &quot;commodityImage/356LBmxe.jpg&quot;,    &quot;price&quot;: 160.68,    &quot;store&quot;: 20,    &quot;status&quot;: 1,    &quot;brandId&quot;: 17,    &quot;categoryId&quot;: 20  &#125;]console.log(arr,&#x27;原始数组&#x27;);console.log(sortArr(arr, &#x27;brandId&#x27;),&#x27;转化后的数组&#x27;);/*** arr 要转化的数组* key 根据某一键转化*/function sortArr(arr, key) &#123;  let newArr = [],      tempArr = [],      temp;  // 按照特定的参数将数组排序，将具有相同值的排在一起  arr = arr.sort(function(a, b) &#123;      let s = a[key],          t = b[key];      return s &lt; t ? -1 : 1;  &#125;);  console.log(arr,&quot;排序之后的数组&quot;);  if ( arr.length )&#123;      temp = arr[0][key];  &#125;  // 将相同类别的对象添加到统一个数组  for (let i in arr) &#123;      if ( arr[i][key] === temp )&#123;          tempArr.push( arr[i] );      &#125; else &#123;          temp = arr[i][key];          newArr.push(tempArr);          tempArr = [arr[i]];      &#125;  &#125;  // 将最后的内容推出新数组  newArr.push(tempArr);  return newArr;&#125;\n结果：\n","categories":["javascript"],"tags":["js","Array"]},{"title":"js经典排序算法","url":"/2018/07/27/js%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/","content":"\n\n1.冒泡排序（Bubble Sort）冒泡排序动图演示：\n定义： 比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个 数据交换。对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。N=N-1，如果N不为0就重复前面二步，否则排序完成。\nfunction bubbleSort(arr)&#123;    var len = arr.length;    for(var i = 0;i &lt; len;i++)&#123;        for(var j = 0;j &lt; len - 1 - i;j++)&#123;            if(arr[j]&gt;arr[j+1])&#123;                var temp = arr[j];                arr[j+1] = arr[j];                arr[j] = temp;            &#125;        &#125;    &#125;&#125;\n2.选择排序（Selection Sort）选择排序动图演示：\n/*** 比如在一个长度为N的无序数组中，在第一趟遍历N个数据，找出其中最小的数值与* 第一个元素交换，第二趟遍历剩下的N-1个数据，找出其中最小的数值与第二个元* 素交换……第N-1趟遍历剩下的2个数据，找出其中最小的数值与第N-1个元素交换，* 至此选择排序完成。*/function selectSort(arr)&#123;    var min,temp;    for(var i=0;i&lt;arr.length-1;i++)&#123;        min=i;        for(var j=i+1;j&lt;arr.length;j++)&#123;            if(arr[j]&lt;arr[min])&#123;                min = j;            &#125;        &#125;        temp=arr[i];        arr[i]=arr[min];        arr[min]=temp;    &#125;    return arr;&#125;\n\n3.插入排序（Insertion Sort）插入排序动图演示：\n从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。\nfunction insertionSort(arr) &#123;    var len = arr.length;    var preIndex, current;    for (var i = 1; i &lt; len; i++) &#123;        preIndex = i - 1;        current = arr[i];        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;            arr[preIndex+1] = arr[preIndex];            preIndex--;        &#125;        arr[preIndex+1] = current;    &#125;    return arr;&#125;\n\n4.快速排序（Quick Sort）快速排序动图演示：\n先从数列中取出一个数作为基准数。分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。再对左右区间重复第二步，直到各区间只有一个数。\n\nfunction quickSort(arr)&#123;    if(arr.length&lt;2)&#123;        return arr    &#125;    var left=[],right=[],mid=arr.splice(Math.floor(arr.length/2),1);    for(var i=0;i&lt;arr.length;i++)&#123;            if(arr[i]&lt;mid)&#123;                left.push(arr[i]);            &#125;else &#123;                right.push(arr[i])            &#125;    &#125;    return bubbleSort(left).concat(mid,bubbleSort(right))  &#125;","categories":["算法"],"tags":["Array","sort"]},{"title":"js跳出循环总结","url":"/2018/07/31/js%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF%E6%80%BB%E7%BB%93/","content":"\n\n一.跳出一层循环var arr = [&quot;a&quot;, &quot;b&quot;,&#x27;c&#x27;,&#x27;d&#x27;];\n结束for循环for(var i=0;i&lt;arr.length;i++)&#123;  if(i==2)&#123;      break;  &#125;  console.log(arr[i],i);&#125;console.log(&#x27;循环外&#x27;);\n注意：return 虽说可以结束循环，但是循环体后面的内容也无法执行了\n结束forEach循环try &#123;    arr.forEach((o,i) =&gt; &#123;        if(i==2)&#123;            throw new Error(&quot;EndIterative&quot;);        &#125;        console.log(o,i);    &#125;);&#125; catch (e) &#123;    if(e.message!=&#x27;EndIterative&#x27;)&#123;        throw e;    &#125;&#125;console.log(&#x27;循环体外&#x27;);\n\n注意：return 只能结束本次循环，并不能终止整个循环\n结束for…in循环for (var i in arr) &#123;    if(i==2)&#123;        break;    &#125;    console.log(arr[i],i);&#125;console.log(&#x27;循环体外&#x27;);\n注意：return 虽说可以结束循环，但是循环体后面的内容也无法执行了\n结果：\n二.跳出多层循环var arr = [[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;],[&quot;小红&quot;, &quot;小明&quot;, &quot;小亮&quot;]];\n正常多层for循环for (var i = 0; i &lt; arr.length; i++) &#123;    for (var j = 0; j &lt; arr[i].length; j++) &#123;        console.log(arr[i][j], &#x27;内层&#x27;);    &#125;    console.log(arr[i], &quot;外层&quot;);&#125;console.log(&quot;循环体外&quot;);\n#####结果：\n使用breakfor (var i = 0; i &lt; arr.length; i++) &#123;    for (var j = 0; j &lt; arr[i].length; j++) &#123;      if(j==i)&#123;          break;      &#125;      console.log(arr[i][j], &#x27;内层&#x27;);    &#125;    console.log(arr[i], &quot;外层&quot;);&#125;\n结果： 只跳出了一层循环\n\n我们可以使用以下方法跳出多层for循环var flag = false;for (var i = 0; i &lt; arr.length; i++) &#123;    for (var j = 0; j &lt; arr[i].length; j++) &#123;      if(j==1)&#123;          flag = true;          break;      &#125;      console.log(arr[i][j], &#x27;内层&#x27;);    &#125;    if(flag)&#123;        break;    &#125;    console.log(arr[i], &quot;外层&quot;);&#125;\n结果： 只执行了一次j&#x3D;0就结束了循环\n使用returnfor (var i = 0; i &lt; arr.length; i++) &#123;    for (var j = 0; j &lt; arr[i].length; j++) &#123;      if(j==1)&#123;          return;      &#125;      console.log(arr[i][j], &#x27;内层&#x27;);    &#125;    console.log(arr[i], &quot;外层&quot;);&#125;console.log(&#x27;我在循环体外&#x27;);\n结果： 虽然跳出了多层循环，但是循环体后面的内容都没有被执行\n\n跳出多层forEach循环try &#123;    arr.forEach((newArr,i) =&gt; &#123;        newArr.forEach((o,j)=&gt;&#123;            if(j==1)&#123;                throw new Error(&quot;EndIterative&quot;);            &#125;            console.log(o,&#x27;内层&#x27;)        &#125;);        console.log(newArr,&#x27;外层&#x27;);    &#125;);&#125; catch (e) &#123;    if(e.message!=&quot;EndIterative&quot;)&#123;        throw e;    &#125;&#125;console.log(&#x27;循环体外&#x27;);\n结果： 正确跳出了多层循环\n最后总结：\nbreak只能在for、for…in循环中使用不能再forEach里面使用，并且break只能跳出单层循环；\nreturn 虽然可以终止循环，但是也终止了return之后的所有语句，特别注意：return 不能终止forEach循环，只能结束当前循环。\n\n","categories":["javascript"],"tags":["Array","循环"]},{"title":"使用gulp插件快速开发项目","url":"/2017/07/16/%E4%BD%BF%E7%94%A8gulp%E6%8F%92%E4%BB%B6%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE/","content":"\n\n\n简介：&ensp;&ensp;&ensp;&ensp;gulp有着丰富的插件库，她能自动化地完成javascript、coffee、sass、less、html、image、css 等文件的的测试、检查、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤，能快速提高我们项目的开发效率。\n1.gulpfile.js基本配置示例：&ensp;&ensp;&ensp;&ensp;通过此配置示例可以让我们快速编写js,css代码并打包压缩文件，减少文件资源大小。\n//导入工具包 require(&#x27;node_modules里对应模块&#x27;)var gulp = require(&#x27;gulp&#x27;); //本地安装gulp所用到的地方var sass = require(&#x27;gulp-sass&#x27;);//将scss文件编译成浏览器可识别的cssvar minifycss = require(&#x27;gulp-minify-css&#x27;);//压缩css文件，减小文件大小，并给引用url添加版本号避免缓存var cleancss = require(&#x27;gulp-clean-css&#x27;);//压缩css文件，减小文件大小，并给引用url添加版本号避免缓存var livereload = require(&#x27;gulp-livereload&#x27;);//监听文件发生变化时，浏览器自动刷新页面var babel = require(&#x27;gulp-babel&#x27;);//将ES6编译成ES5var uglify = require(&#x27;gulp-uglify&#x27;);//压缩jsvar autoprefixer = require(&#x27;gulp-autoprefixer&#x27;);//根据设置浏览器版本自动处理浏览器前缀//定义一个sass任务（自定义任务名称）gulp.task(&#x27;sass&#x27;, function () &#123;    gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件        .pipe(sass()) //该任务调用的模块        .pipe(cleancss(&#123;            advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]            compatibility: &#x27;ie7&#x27;,//保留ie7及以下兼容写法 类型：String 默认：&#x27;&#x27;or&#x27;*&#x27; [启用兼容模式； &#x27;ie7&#x27;：IE7兼容模式，&#x27;ie8&#x27;：IE8兼容模式，&#x27;*&#x27;：IE9+兼容模式]            keepBreaks: true,//类型：Boolean 默认：false [是否保留换行]            keepSpecialComments: &#x27;*&#x27;            //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀        &#125;))        .pipe(autoprefixer(&#123;            browsers: [&#x27;last 2 versions&#x27;, &#x27;Android &gt;= 4.0&#x27;],            cascade: true, //是否美化属性值 默认：true             remove:true //是否去掉不必要的前缀 默认：true         &#125;))        .pipe(gulp.dest(&#x27;./css&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）        .pipe(livereload());//监听文件发生变化时，浏览器自动刷新页面&#125;);//定义一个babel任务（自定义任务名称）编译jsgulp.task(&#x27;babel&#x27;, function () &#123;    gulp.src(&#x27;./src/**/*.js&#x27;) //该任务针对的文件        .pipe(babel(&#123;            presets: [&#x27;es2015&#x27;]        &#125;)) //该任务调用的模块        .pipe(livereload())//监听文件发生变化时，浏览器自动刷新页面        .pipe(uglify(&#123; //压缩js            // mangle: false,//类型：Boolean 默认：true 是否修改变量名            // compress: true//类型：Boolean 默认：true 是否完全压缩        &#125;))        .pipe(gulp.dest(&#x27;./js&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);gulp.task(&#x27;auto&#x27;, function () &#123;    gulp.watch(&#x27;./sass/**/*.scss&#x27;, [&#x27;sass&#x27;]);    gulp.watch(&#x27;./src/**/*.js&#x27;, [&#x27;babel&#x27;]);    // livereload.listen();&#125;); gulp.task(&#x27;default&#x27;,[&#x27;sass&#x27;,&#x27;auto&#x27;,&#x27;babel&#x27;]); //定义默认任务// 通配符路径匹配示例：// “src/a.js”：指定具体文件；// “*”：匹配所有文件    例：src/*.js(包含src下的所有js文件)；// “**”：匹配0个或多个子文件夹    例：src/**/*.js(包含src的0个或多个子文件夹下的js文件)；// “&#123;&#125;”：匹配多个属性    例：src/&#123;a,b&#125;.js(包含a.js和b.js文件)  src/*.&#123;jpg,png,gif&#125;(src下的所有jpg/png/gif文件)；// “!”：排除文件    例：!src/a.js(不包含src下的a.js文件)；//gulp.task(name[, deps], fn) 定义任务  name：任务名称 deps：依赖任务名称 fn：回调函数//gulp.src(globs[, options]) 执行任务处理的文件  globs：处理的文件路径(字符串或者字符串数组) //gulp.dest(path[, options]) 处理完后文件生成路径\n\n配置文件详解：执行一个任务分三步走：1.导入工具包 require(‘node_modules里对应模块’)  \nvar gulp = require(&#x27;gulp&#x27;); //本地安装gulp所用到的地方\n\n2.定义一个任务（自定义任务名称）  \ngulp.task(&#x27;test&#x27;, function () &#123;  gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件      .pipe(test())      .pipe(gulp.dest(&#x27;./css&#x27;)) //将会在css文件夹下生成.css文件（复制文件目录及文件）&#125;)\n3.执行任务：cmd命令提示符 \ngulp test\n如果只是简单的配置了上面部分，每当我们修改了代码都需要重新执行命令gulp test,而且如果有多个任务就要执行多个命令，为了避免这么繁琐的操作可以加上如下配置：gulp.task(&#x27;auto&#x27;, function () &#123;    gulp.watch(&#x27;./src/**/*.js&#x27;, [&#x27;test&#x27;]);&#125;);gulp.task(&#x27;default&#x27;,[&#x27;auto&#x27;,&#x27;test&#x27;]); //定义默认任务\n这样我们只需要输入一次命令gulp,就可以监听到每次代码的修改，自动帮我们编译，减少了很多繁琐的操作。\n2.使用gulp编译css1.gulp-sass的使用：1.简介：SASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。2.本地安转：npm install gulp-less –save-dev3.配置gulpfile.js1.配置：\n//导入sass工具包var sass = require(&#x27;gulp-sass&#x27;);//定义一个sass任务（自定义任务名称）gulp.task(&#x27;sass&#x27;, function () &#123;    gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件        .pipe(sass(&#123;        outputStyle: &#x27;compact&#x27;  //代码风格      // nested：嵌套缩进的css代码，它是默认值。      // expanded：没有缩进的、扩展的css代码。      // compact：简洁格式的css代码。      // compressed：压缩后的css代码。        &#125;)) //该任务调用的模块        .pipe(gulp.dest(&#x27;./css&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);\n\n2.sass使用示例：\n$blue : #1875e7;　.class &#123;    font-size: 12px;&#125;.main&#123;    color:$blue;    @if 1 + 1 == 2 &#123;         border: 1px solid red;    &#125;@if 5 &lt; 3 &#123;         border: 2px dotted blue;     &#125;    .parent&#123;        margin-left:10px + 20px;        &amp;:hover&#123;            cursor: pointer;            @extend .class;        &#125;    &#125;&#125;\n\n4.执行任务：命令提示符：gulp sass\n5.编译结果：\n2.gulp-minify-css的使用：1.插件介绍：压缩css文件，减小文件大小，并给引用url添加版本号避免缓存2.本地安转：npm install gulp-minify-css –save-dev。3.配置gulpfile.js1.配置\nvar minifycss = require(&#x27;gulp-minify-css&#x27;);//定义一个sass任务（自定义任务名称）gulp.task(&#x27;sass&#x27;, function () &#123;    gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件        .pipe(sass(&#123;            outputStyle: &#x27;compact&#x27;  //代码风格        // nested：嵌套缩进的css代码，它是默认值。        // expanded：没有缩进的、扩展的css代码。        // compact：简洁格式的css代码。        // compressed：压缩后的css代码。        &#125;)) //该任务调用的模块        .pipe(minifycss(&#123;            advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]            compatibility: &#x27;ie7&#x27;,//保留ie7及以下兼容写法 类型：String 默认：&#x27;&#x27;or&#x27;*&#x27; [启用兼容模式； &#x27;ie7&#x27;：IE7兼容模式，&#x27;ie8&#x27;：IE8兼容模式，&#x27;*&#x27;：IE9+兼容模式]            keepBreaks: true,//类型：Boolean 默认：false [是否保留换行]            keepSpecialComments: &#x27;*&#x27;            //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀        &#125;))        .pipe(gulp.dest(&#x27;./css&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);\n2.使用示例：\n4.执行任务：命令提示符：gulp sass\n5.编译结果：编译之后的css文件被压缩了\n3.gulp-autoprefixer：1.插件介绍：根据设置浏览器版本自动处理浏览器前缀2.本地安转：npm install gulp-autoprefixer –save-dev。3.配置gulpfile.js1.配置\nvar autoprefixer = require(&#x27;gulp-autoprefixer&#x27;);//定义一个sass任务（自定义任务名称）gulp.task(&#x27;sass&#x27;, function () &#123;    gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件        .pipe(sass(&#123;            outputStyle: &#x27;compact&#x27;  //代码风格        // nested：嵌套缩进的css代码，它是默认值。        // expanded：没有缩进的、扩展的css代码。        // compact：简洁格式的css代码。        // compressed：压缩后的css代码。        &#125;)) //该任务调用的模块        .pipe(autoprefixer(&#123;            browsers: [&#x27;last 2 versions&#x27;, &#x27;Android &gt;= 4.0&#x27;],            cascade: true, //是否美化属性值 默认：true             remove:true //是否去掉不必要的前缀 默认：true         &#125;))        .pipe(gulp.dest(&#x27;./css&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);\n2.使用示例：\n4.执行任务：命令提示符：gulp sass\n5.编译结果：浏览器中的编译结果：\n3.使用gulp编译js1.gulp-babel的使用：1.介绍：gulp-babel是可以将ES6编译成大多数浏览器可识别的ES5规范2.本地安转：1.npm install gulp-babel –save-dev2.npm install babel-preset-es2015 –save-dev\n3.配置gulpfile.js1.配置：\n//导入babel工具包var less = require(&#x27;gulp-babel&#x27;);//定义一个babel任务（自定义任务名称）//定义一个babel任务（自定义任务名称）编译jsgulp.task(&#x27;babel&#x27;, function () &#123;    gulp.src(&#x27;./src/**/*.js&#x27;) //该任务针对的文件        .pipe(babel(&#123;            presets: [&#x27;es2015&#x27;]        &#125;)) //该任务调用的模块        .pipe(gulp.dest(&#x27;./js&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);\n\n2.ES6使用示例：\n\n4.执行任务：命令提示符：gulp babel\n5.编译结果：\n2.gulp-uglify的使用：1.介绍：压缩js代码2.本地安转： npm install gulp-uglify –save-dev3.配置gulpfile.js1.配置：\n//导入uglify工具包var uglify = require(&#x27;gulp-uglify&#x27;);//定义一个babel任务（自定义任务名称）编译jsgulp.task(&#x27;babel&#x27;, function () &#123;    gulp.src(&#x27;./src/**/*.js&#x27;) //该任务针对的文件        .pipe(babel(&#123;            presets: [&#x27;es2015&#x27;]        &#125;)) //该任务调用的模块        .pipe(uglify(&#123; //压缩js         // mangle: false,//类型：Boolean 默认：true 是否修改变量名         // compress: true//类型：Boolean 默认：true 是否完全压缩        &#125;))        .pipe(gulp.dest(&#x27;./js&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);\n\n2.ES6使用示例：\n\n4.执行任务：命令提示符：gulp babel\n5.编译结果：\ngulp插件库还有其他很多优秀的插件，可以根据自己的需要引入。此dome在我的github上，可以下载自行查看https://github.com/xiongcao/project-gule\n","categories":["工具"],"tags":["gulp"]},{"title":"css3伪类选择器nth-child和nth-of-type的区别","url":"/2017/06/10/ss3%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8nth-child%E5%92%8Cnth-of-type%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"\n\n\n\n使用误区之前在做项目时一直是:nth-child和:nth-of-type混着用，第一个不行就用第二个，当时就觉得能实现效果就行，后来这样的情况遇到多了，每次用的时候就感觉效果是试出来的，特别浪费时间，现在就来研究一下这两个用法的区别。\n1.用法效果相同的情况示例一：# HTML代码&lt;div class=&quot;main&quot;&gt;  &lt;p&gt;one&lt;/p&gt;  &lt;p&gt;two&lt;/p&gt;  &lt;p&gt;three&lt;/p&gt;&lt;/div&gt;\n\n要实现的效果：将two变红\n\n\nnth-child()的方式:\n\n\n# CSSp:nth-child(2)&#123;color:red;&#125;\n\n\n\nnth-of-type()的方式:\n\n\n# CSSp:nth-of-type(2)&#123;color:red;&#125;\n\n效果：\n在同辈元素都相同的情况下两个用法效果一样\n2.用法相同效果不同的情况示例二：# HTML代码&lt;div class=&quot;main&quot;&gt;  &lt;p&gt;one&lt;/p&gt;  &lt;div&gt;div&lt;/div&gt;  &lt;p&gt;two&lt;/p&gt;  &lt;p&gt;three&lt;/p&gt;&lt;/div&gt;\n要实现的效果：同样将two变红\n\n\n先看nth-of-type()的方式:\n\n\n# CSSp:nth-of-type(2)&#123;color:red;&#125;\n效果：\n\n\n再来看nth-child()的方式:\n\n\n# CSSp:nth-child(2)&#123;color:red;&#125;\n效果：\n3.用法不同效果相同的情况示例三：# HTML代码&lt;div class=&quot;main&quot;&gt;  &lt;p&gt;one&lt;/p&gt;  &lt;div&gt;div&lt;/div&gt;  &lt;p&gt;two&lt;/p&gt;  &lt;p&gt;three&lt;/p&gt;&lt;/div&gt;\n要实现的效果：同样将two变红\n\n\n先看nth-of-type()的方式:\n\n\n# CSSp:nth-of-type(2)&#123;color:red;&#125;\n\n\n\n再来看nth-child()的方式:\n\n\n# CSSp:nth-child(3)&#123;color:red;&#125;\n\n效果：\n用法总结从以上三个示例可以看出：\n\n1.在所有子元素都相同的情况下，两种用法效果相同；\n2.在子元素不同的情况下，:nth-of-type选择的是相同（同种元素）元素中的第几个，而:nth-child选择的其父辈元素下面的第几个子元素；\n\n","categories":["javascript"],"tags":["css","伪类选择器"]},{"title":"使用gulp自动化构建前端项目","url":"/2017/07/09/%E4%BD%BF%E7%94%A8gulp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/","content":"\n\n\ngulp简介：&ensp;&ensp;&ensp;&ensp;gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成，从而大大提高我们的工作效率。\n&ensp;&ensp;&ensp;&ensp;gulp是基于Nodejs的自动任务运行器,她能自动化地完成javascript、coffee、sass、less、html、image、css 等文件的的测试、检查、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。\n环境搭建：1.安装nodeJS1.gulp是基于nodejs，所以需要安装nodejs。2.自己去node官网下载nodejs安装。\n2.npm工具说明：npm（node package manager）nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）；\n使用npm安装插件：npm install &lt;name&gt; [-g] [–save-dev]；1.name: node插件名称。例：npm install gulp-sass –save-dev；\n2.-g: 全局安装,可以通过命令行在任何地方调用它。如果不写-g则使非全局安装，将安装在定位目录的node_modules文件夹下，通过require()调用；  \n3.–save: 将保存配置信息至package.json（package.json是nodejs项目配置文件）；\n4.-dev: 保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点；\n3.安装gulp1.npm install gulp -g；\n4.新建package.json文件1.说明：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件；\n2.通过命令行新建：npm init， 创建过程中会提示让输入各种信息，可以一直回车忽略它。\n5.新建gulpfile.js文件1.说明：gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件2.新建gulpfile.js文件示例  \n//导入工具包 require(&#x27;node_modules里对应模块&#x27;)var gulp = require(&#x27;gulp&#x27;); //本地安装gulp所用到的地方var sass = require(&#x27;gulp-sass&#x27;);var minifycss = require(&#x27;gulp-minify-css&#x27;);//压缩css插件var cleancss = require(&#x27;gulp-clean-css&#x27;);//压缩css插件 //定义一个sass任务（自定义任务名称）gulp.task(&#x27;sass&#x27;, function () &#123;    gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件        .pipe(sass()) //该任务调用的模块        .pipe(cleancss(&#123;            advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]            compatibility: &#x27;ie7&#x27;,//保留ie7及以下兼容写法 类型：String 默认：&#x27;&#x27;or&#x27;*&#x27; [启用兼容模式； &#x27;ie7&#x27;：IE7兼容模式，&#x27;ie8&#x27;：IE8兼容模式，&#x27;*&#x27;：IE9+兼容模式]            keepBreaks: true,//类型：Boolean 默认：false [是否保留换行]            keepSpecialComments: &#x27;*&#x27;            //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀        &#125;))        .pipe(gulp.dest(&#x27;./css&#x27;)); //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;); gulp.task(&#x27;default&#x27;,[&#x27;sass&#x27;]); //定义默认任务 //gulp.task(name[, deps], fn) 定义任务  name：任务名称 deps：依赖任务名称 fn：回调函数//gulp.src(globs[, options]) 执行任务处理的文件  globs：处理的文件路径(字符串或者字符串数组) //gulp.dest(path[, options]) 处理完后文件生成路径\n\n6.运行gulp1.gulp [name]:  gulpfile.js里面定义的模块的名称 例如:gulp sass。2.gulp default: 如果定义了默认任务gulp.task(‘default’,[‘sass’])可直接执行gulp命令。\n&ensp;&ensp;&ensp;&ensp;到此为止使用gulp自动化构建前端项目的环境已经配置完成了，接下来就是我们自己去安装相应的插件来完善项目了。","categories":["工具"],"tags":["gulp"]},{"title":"本地存储","url":"/2019/01/16/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/","content":"\n\nHTML5的本地存储HTML5中与本地存储相关的两个重要内容：Web Storage与本地数据库。其中，Web Storage存储机制是对HTML4中cookie存储机制的一个改善。由于cookie存储机制有很多缺点，HTML5不再使用它，转而使用改良后的Web Storage存储机制。本地数据库是HTML5中新增的一个功能，使用它可以在客户端本地建立一个数据库，原本必须保存在服务器端数据库中的内容现在可以直接保存在客户端本地了，这大大减轻了服务器端的负担，同时也加快了访问数据的速度。\n本文主要来讲解Web Storage我们知道，在HTML4中可以使用cookie在客户端保存诸如用户名等简单的用户信息，但是，通过长期的使用，你会发现，用cookie存储永久数据存在以下几个问题：\n1.大小：cookie的大小被限制在4KB。\n2.带宽：cookie是随HTTP事务一起被发送的，因此会浪费一部分发送cookie时使用的带宽。\n3.复杂性：要正确的操纵cookie是很困难的。\n针对这些问题，在HTML5中，重新提供了一种在客户端本地保存数据的功能，它就是Web Storage。\n具体来说，Web Storage又分为两种：1.sessionStorage：将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据。\n2.localStorage：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。\n这两者的区别在于，sessionStorage为临时保存，而localStorage为永久保存。\n到目前为止，Firefox3.6以上、Chrome6以上、Safari 5以上、Pera10.50以上、IE8以上版本的浏览器支持sessionStorage与localStorage的使用。WebStorage的目的是克服由cookie所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。\nWebStorage两个主要目标：（1）提供一种在cookie之外存储会话数据的路径。（2）提供一种存储大量可以跨会话存在的数据的机制。\nHTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage（会话存储）。1、生命周期：localStorage:localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。　　sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。\n2、存储大小：localStorage和sessionStorage的存储数据大小一般都是：5MB\n3、存储位置：localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。\n4、存储内容类型：localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理\n5、获取方式：localStorage：window.localStorage;；sessionStorage：window.sessionStorage;\n6、应用场景：localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录；\nWebStorage的优点：（1）存储空间更大：cookie为4KB，而WebStorage是5MB；\n（2）节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样每次请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量；\n（3）对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便；\n（4）快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快；\n（5）安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题；\nWebStorage提供了一些方法，数据操作比cookie方便；\nsetItem（key, value） ——  保存数据，以键值对的方式储存信息。\n\ngetItem（key） ——  获取数据，将键值传入，即可获取到对应的value值。\n\nremoveItem（key） ——  删除单个数据，根据键值移除对应的信息。\n\nclear（） ——  删除所有的数据\n\nkey（index） —— 获取某个索引的key\n\n\ncookie 、sessionStorage与localStorage的区别特性cookiesessionStoragelocalStorage数据生命期生成时就会被指定一个maxAge值，这就是cookie的生存周期，在这个周期内cookie有效，默认关闭浏览器失效页面会话期间可用除非数据被清除，否则一直存在存放数据大小4K左右（因为每次http请求都会携带cookie）一般5M或更大详细看这(需科学上网)与服务器通信由对服务器的请求来传递，每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题数据不是由每个服务器请求传递的，而是只有在请求时使用数据，不参与和服务器的通信易用性cookie需要自己封装setCookie，getCookie可以用源生接口，也可再次封装来对Object和Array有更好的支持共同点都是保存在浏览器端，和服务器端的session机制不同（这里有一篇很好的介绍cookie和session的文章）\n\n示例：（1） 新建两个文件：\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;a href=&quot;./test.html&quot; target=&quot;_blank&quot;&gt;跳到test.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    localStorage.setItem(&quot;xiongchao&quot;,123);    sessionStorage.setItem(&quot;xiongchao&quot;,456);&lt;/script&gt;\n\n（2） 部署服务（推荐使用nignx做反向代理,比tomcat简单粗暴，也可以不用这一步，只是为了模拟真实网站会话）\n（3） 打开index.html,并使用链接打开test.html\n两个页面的结果是一样的，这是一次会话，sessionStorage储存的内容被保存下来。\n（4） 单独打开test.html,会发现sessionStorage是空的。\n","categories":["缓存"],"tags":["缓存"]},{"title":"大纲","url":"/2019/01/06/%E5%A4%A7%E7%BA%B2/","content":"\n\nIP\nIP头：IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间\nUDP（user datagram protocol）用户数据包协议\nTCP（transmission control protocol）传输控制协议\n性能优化：浏览器的组成与功能\nCDN工作原理\n浏览器渲染引擎与阻塞\n图层与重回重排\n浏览器本地存储\n缓存机制\n浏览器原理：CDN工作原理\nHTTP相关原理\n网页渲染原理\n浏览器的组成与功能\n浏览器相关原理\n三次握手四次挥手\n输入URL后发生了什么\n外链浏览器相关原理详细总结一\n","categories":["浏览器"],"tags":["网络","浏览器"]},{"title":"缓存机制","url":"/2019/02/10/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","content":" \n\n一、缓存理解1.缓存定义:​        浏览器在本地磁盘上将用户之前请求的数据存储起来，当访问者再次需要改数据的时候无需再次发送请求，直接从浏览器本地获取数据。\n2.缓存的好处:\n减少请求的个数；\n节省带宽，避免浪费不必要的网络资源；\n减轻服务器压力；\n提高浏览器网页的加载速度，提高用户体验；\n\n二、缓存分类1.强缓存\n不会向服务器发送请求，直接从本地缓存中获取数据\n\n请求资源的的状态码为: 200 ok(from memory cache)\n\n\n2.协商缓存\n向服务器发送请求，服务器会根据请求头的资源判断是否命中协商缓存\n如果命中，则返回304状态码通知浏览器从缓存中读取资源\n\n3.强缓存 &amp; 协商缓存的共同点\n都是从浏览器端读取资源\n\n4.强缓存 VS 协商缓存的不同点\n强缓存不发请求给服务器\n协商缓存发请求给服务器，根据服务器返回的信息决定是否使用缓存\n\n三、缓存使用示意图\n四、缓存中的header参数1、强缓存的header参数\nexpires：\n这是http1.0时的规范；它的值为一个绝对时间的GMT格式的时间字符串，如Mon, 10 Jun 2015 21:31:12 GMT，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。\n\ncache-control：max-age&#x3D;number。\n\n这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；\n\ncache-control常用的值（做一个简单了解即可）：\n\nno-cache: 不使用本地缓存，需要使用协商缓存。先与服务器确认返回的响应是否被更改，如果之前的响应中存在Etag，那么请求的额时候会与服务器端进行验证，如果资源为被更改则使用缓存。\n\nno-store: 直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。\n\npublic：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。\n\nprivate：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。\n\n注意：当cache-control与Expires共存的时候cache-control的优先级高\n\n\n2、协商缓存的header参数 重点：协商缓存都是由服务器来确定缓存资源是否可用的，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问\nLast-Modified&#x2F;If-Modified-Since:二者的值都是GMT格式的时间字符串\n\n浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间\n浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值\n服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header\n浏览器收到304的响应后，就会从缓存中加载资源\n如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值\n图例：\n\n\nEtag&#x2F;If-None-Match\n\n这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变\n其判断过程与Last-Modified&#x2F;If-Modified-Since类似\n\n\n既生Last-Modified何生Etag\n\nHTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题\n一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET\n某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；\n某些服务器不能精确的得到文件的最后修改时间。\n\n\n小结：\n\n利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。\nLast-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。\n\n","categories":["http"],"tags":["缓存","http"]},{"title":"浏览器相关原理详细总结一","url":"/2019/02/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/","content":" \n\n浏览器相关原理详细总结一Chrome 打开一个页面需要启动多少进程？分别有哪些进程？浏览器从关闭状态进行启动，然后新开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个进程；后续再新开标签页，浏览器、网络进程、GPU进程是共享的，不会重新启动，如果2个页面属于同一站点的话，并且从a页面中打开的b页面，那么他们也会共用一个渲染进程，否则新开一个渲染进程。\n最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。\n\n浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。\n\n渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。\n\nGPU 进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。\n\n网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。\n\n插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。\n\n\n如何保证页面文件能被完整送达浏览器？互联网中的数据是通过数据包来传输的。数据包要在互联网上进行传输，就要符合网际协议(IP)，互联网上不同的在线设备都有唯一的地址，地址只是一个数字，只要知道这个具体的地址，就可以往这里发送信息。\n如果要想把一个数据包从主机 A 发送给主机 B，那么在传输之前，数据包上会被附加上主机 B 的 IP 地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机 A 本身的 IP 地址，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 IP 头的数据结构里。IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。\nIP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，是交给浏览器还是交给王者荣耀？？因此，需要基于 IP 之上开发能和应用打交道的协议，最常见的是用户数据包协议（User Datagram Protocol)，简称UDP和传输控制协议（Transmission Control Protocol）,简称TCP。\n基本传输过程为：\n\n上层将数据包交给传输层；\n传输层会在数据包前面附加上UDP 头，组成新的 UDP 数据包，再将新的 UDP 数据包交给网络层；\n网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；\n数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层；\n在传输层，数据包中的 UDP 头会被拆开，并根据 UDP 中所提供的端口号，把数据部分交给上层的应用程序\n最终，数据包就发送到了主机 B 上层应用程序这里。\n\nUDP和TCP有什么区别？\nTCP协议在传送数据段的时候要给段标号；UDP协议不；\nTCP协议可靠；UDP协议不可靠；\nTCP协议是面向连接；UDP协议采用无连接；\nTCP协议负载较高，采用虚电路；UDP采用无连接；\nTCP协议的发送方要确认接收方是否收到数据段（3次握手协议）；\nTCP协议采用窗口技术和流控制。\n\n\n\n\n特性\nTCP\nUDP\n\n\n\n是否连接\n面向连接\n面向非连接\n\n\n传输可靠性\n可靠\n不可靠\n\n\n应用场合\n传输大量数据\n传输少量数据\n\n\n速度\n慢\n快\n\n\nTCP传输的详细过程是怎样的？进行三次握手，建立TCP连接。\n\n\n第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；\n第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；\n第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，，完成TCP三次握手。 完成了三次握手，客户端和服务器端就可以开始传送数据。\n\nACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。 TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。（ACK：确认字符）SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。（SYN：同步序列编号）FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。\n\n发送HTTP请求，服务器处理请求，返回响应结果TCP连接建立后，浏览器就可以利用HTTP／HTTPS协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200。\n关闭TCP连接![image-20230410171051659](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230410171051659.png)\n\n第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；\n第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；\n第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；\n第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。\n\nMSL：报文最大生存时间。是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。\n\n为什么“握手”是三次，“挥手”却要四次？TCP建立连接时之所以只需要”三次握手”，是因为在第二次”握手”过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。\n即SYN建立连接报文与ACK确认接收报文是在同一次”握手”当中传输的，所以”三次握手”不多也不少，正好让双方明确彼此信息互通。\nTCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次”握手”传输的。为何建立连接时一起传输，释放连接时却要分开传输？\n\n建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。\n释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。\n\n为什么客户端在TIME-WAIT阶段要等2MSL?为的是确认服务器端是否收到客户端发出的ACK确认报文\n当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。\n服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；\n\n如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；\n否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。\n\n所以，客户端要经历时长为2SML的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因\n为什么很多站点第二次打开速度会很快？主要原因是第一次加载页面过程中，缓存了一些耗时的数据。 那么，哪些数据会被缓存呢？\nDNS缓存主要就是在浏览器本地把对应的 IP 和域名关联起来，这样在进行DNS解析的时候就很快。\nMemoryCache是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。内存缓存是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内存里的数据也将不复存在。\n浏览器缓存浏览器缓存，也称Http缓存，分为强缓存和协商缓存。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。\n强缓存强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。\n实现强缓存，过去我们一直用expires。当服务器返回响应时，在 Response Headers 中将&#x3D;&#x3D;过期时间&#x3D;&#x3D;写入 expires 字段。像这样\nexpires: Wed, 12 Sep 2019 06:12:18 GMT\n\n可以看到，&#x3D;&#x3D;expires 是一个时间戳&#x3D;&#x3D;，接下来如果我们试图再次向服务器请求资源，浏览器就会先对&#x3D;&#x3D;比本地时间&#x3D;&#x3D;和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。\n从这样的描述中大家也不难猜测，expires 是有问题的，它最大的问题在于对“本地时间”的依赖。如果服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么 expires 将无法达到我们的预期。\n考虑到 expires 的局限性，HTTP1.1 新增了Cache-Control字段来完成 expires 的任务。expires 能做的事情，&#x3D;&#x3D;Cache-Control&#x3D;&#x3D; 都能做；expires 完成不了的事情，Cache-Control 也能做。因此，Cache-Control 可以视作是 expires 的完全替代方案。在当下的前端实践里，我们继续使用 expires 的唯一目的就是向下兼容。\ncache-control: max-age=31536000\n\n在 Cache-Control 中，我们通过max-age来控制资源的有效期。max-age 不是一个时间戳，而是一个&#x3D;&#x3D;时间长度&#x3D;&#x3D;。在本例中，max-age 是 31536000 秒，它意味着该资源在 31536000 秒以内都是有效的，完美地规避了时间戳带来的潜在问题。\nCache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。\n协商缓存协商缓存依赖于服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。\n协商缓存的实现,从 Last-Modified 到 Etag,Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：\nLast-Modified: Fri, 27 Oct 2017 06:35:57 GMT\n\n随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：\nIf-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT\n\n服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段。\n使用 Last-Modified 存在一些弊端，这其中最常见的就是这样两个场景：\n\n我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。\n\n当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。\n\n\n这两个场景其实指向了同一个 bug——服务器并没有正确感知文件的变化。为了解决这样的问题，Etag 作为 Last-Modified 的补充出现了。\n&#x3D;&#x3D;Etag &#x2F; If-None-Match&#x3D;&#x3D;\nEtag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串可以是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。\nEtag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。正如我们刚刚所提到的——Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。\nEtag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。\nService Worker CacheService Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们&#x3D;&#x3D;实现离线缓存、消息推送和网络代理&#x3D;&#x3D;等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。\nService Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实现离线存储的重要先决条件.\nPush CachePush Cache 是指 HTTP2 在 server push 阶段存在的缓存。这块的知识比较新，应用也还处于萌芽阶段，应用范围有限不代表不重要——HTTP2 是趋势、是未来。在它还未被推而广之的此时此刻，我仍希望大家能对 Push Cache 的关键特性有所了解：\n\nPush Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。\nPush Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。\n不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。\n\n原文地址：浏览器相关原理(面试题)详细总结一\n","categories":["浏览器"],"tags":["浏览器"]},{"title":"浏览器渲染引擎与阻塞","url":"/2019/03/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E4%B8%8E%E9%98%BB%E5%A1%9E/","content":" \n\n浏览器渲染引擎与阻塞一、浏览器渲染引擎主要模块\n一个渲染引擎主要包括：HTML解析器，CSS解析器，javascript引擎，布局layout模块，绘图模块\nHTML解析器：解释HTML文档的解析器，主要作用是将HTML文本解释成DOM树。\nCSS解析器：它的作用是为DOM中的各个元素对象计算出样式信息，为布局提供基础设施。\nJavascript引擎：使用Javascript代码可以修改网页的内容，也能修改css的信息，javascript引擎能够解释javascript代码，并通过DOM接口和CSS树接口来修改网页内容和样式信息，从而改变渲染的结果。\n布局（layout）：在DOM创建之后，Webkit需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能表达这所有信息的内部表示模型。\n绘图模块（paint）：使用图形库将布局计算后的各个网页的节点绘制成图像结果。\n\n大致的渲染过程\n浏览器渲染页面的整个过程：浏览器会从上到下解析文档。\n遇见 HTML 标记，调用HTML解析器解析为对应的 token （一个token就是一个标签文本的序列化）并构建 DOM 树（就是一块内存，保存着tokens，建立它们之间的关系）。\n遇见 style&#x2F;link 标记调用相应解析器处理CSS标记，并构建出CSS样式树。\n遇见 script 标记 调用javascript引擎 处理script标记、绑定事件、修改DOM树&#x2F;CSS树等\n将 DOM树 与 CSS树 合并成一个渲染树。\n根据渲染树来渲染，以计算每个节点的几何信息（这一过程需要依赖GPU）。\n最终将各个节点绘制到屏幕上。\n\n以上这些模块依赖很多其他的基础模块，包括要使用到网络 存储 2D&#x2F;3D图像 音频视频解码器 和 图片解码器。\n所以渲染引擎中还会包括如何使用这些依赖模块的部分。\n二、阻塞渲染1.关于css阻塞声明：只有link引入的外部css才能够产生阻塞。\n1.style标签中的样式：\n​     (1). 由html解析器进行解析（异步解析）；\n​     (2). 不阻塞浏览器渲染（可能会产生“闪屏现象”）；\n​     (3). 不阻塞DOM解析；\n2.link引入的外部css样式（推荐使用的方式）：\n​    (1). 由CSS解析器进行解析（同步解析）。\n​    (2). 阻塞浏览器渲染(可以利用这种阻塞避免“闪屏现象”)。 \n​    (3). 阻塞其后面的js语句的执行。\n​    (4). 不阻塞DOM的解析(绝大多数浏览器的工作方式)。\n3.优化核心理念：尽可能快的提高外部css加载速度\n​    (1).使用CDN节点进行外部资源加速。\n​    (2).对css进行压缩(利用打包工具，比如webpack,gulp等)。\n​    (3).减少http请求数，将多个css文件合并。\n​    (4).优化样式表的代码\n2.关于js阻塞1.阻塞后续DOM解析:\n​        原因：浏览器不知道后续脚本的内容，如果先去解析了下面的DOM，而随后的js删除了后面所有的DOM，那么浏览器就做了无用功，浏览器无法预估脚本里面具体做了什么操作，例如像document.write，这种操作，索性全部停住，等脚本执行完了，浏览器再继续向下解析DOM。  \n2.阻塞页面渲染:\n​        原因：js中也可以给DOM设置样式，浏览器等该脚本执行完毕，渲染出一个最终结果，避免做无用功。\n3.阻塞后续js的执行:\n​        原因：维护依赖关系，例如：必须先引入jQuery再引入bootstrap\nasync：\n当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，脚本下载完成后开始执行脚本，脚本执行的过程中文档将停止解析，直到脚本执行完毕。\ndefer：当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，待到&#x3D;&#x3D;文档解析完成&#x3D;&#x3D;，脚本才会执行。\n3.备注​    【备注1】：css的解析和js的执行是互斥的（互相排斥），css解析的时候js停止执行，js执行的时候css停止解析。\n​    【备注2】：无论css阻塞，还是js阻塞，都不会阻塞浏览器加载外部资源（图片、视频、样式、脚本等）。\n​             原因：浏览器始终处于一种：“先把请求发出去”的工作模式，只要是涉及到网络请求的内容，无论是：图片、样式、脚本，都会先发送请求去获取资源，至于资源到本地之后什么时候用，由浏览器自己协调。这种做法效率很高。\n​    【备注3】：WebKit 和 Firefox 都进行了【预解析】这项优化。\n​            在执行js脚本时，浏览器的其他线程会预解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树\n在上述的过程中，网页在加载和渲染过程中会触发“DOMContentLoaded”和“onload”事件；\n分别是在DOM树构建（解析）完成之后，以及DOM树构建完并且网页所依赖的资源都加载完之后。\n上面介绍的是一个完整的渲染过程，但现代网页很多都是动态的，这意味着在渲染完成之后，由于网页的动画或者用户的交互， 浏览器其实一直在不停地重复执行渲染过程。（重绘重排），以上的数字表示的是基本顺序，这不是严格一致的，这个过程可能重复也可能交叉。\n","categories":["浏览器"],"tags":["浏览器"]},{"title":"TCP三次握手四次挥手","url":"/2019/03/16/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","content":" \n\nTCP的三次握手和四次挥手实质就是TCP通信的连接和断开。\n\n\n1.三次握手​\t\tTCP协议位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略。\n&#x3D;&#x3D;三次握手原理：&#x3D;&#x3D;\n\n第1次握手：客户端发送一个带有SYN（synchronize）标志的数据包给服务端；\n\n第2次握手：服务端接收成功后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示收到了；\n\n第3次握手：客户端再回传一个带有ACK标志的数据包，握手结束。\n\n\n其中：SYN标志位数置1，表示建立TCP连接；ACK标志表示验证字段。\n\nACK：此标志表示应答域有效。TCP应答号将会包含在TCP数据包中。\n​\t\t\t有两个取值：0和1，1表示应答域有效，反之为0。\nSYN(SYNchronization) ：\n​\t\t在连接建立时用来同步序号。SYN置1就表示这是一个连接请求或连接接受报文。\n​\t\t当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文；\n​\t\tSYN&#x3D;1和ACK&#x3D;1，对方同意建立连接。\n\n可通过以下趣味图解理解三次握手：\n\n\n三次握手详细说明：\n\n第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；\n第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；\n第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，，完成TCP三次握手。 完成了三次握手，客户端和服务器端就可以开始传送数据。\n\n2.四次挥手​\t\t由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。\n&#x3D;&#x3D;四次挥手原理：&#x3D;&#x3D;\n\n第1次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态；\n\n第2次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1\n​\t\t\t\t\t（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态；\n​\t\t\t\t\t\t客户端进入FIN_WAIT_2状态\n\n第3次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态；\n\n第4次挥手：客户端收到FIN后，客户端t进入TIME_WAIT状态，接着发送一个ACK给Server，\n​\t\t\t\t\t 确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手。\n\n\n其中：FIN（finis）标志位数置1，表示断开TCP连接。\n可通过以下趣味图解理解四次挥手：\n\n\n\n\n\nLISTEN：等待从任何远端TCP 和端口的连接请求。\nSYN_SENT：发送完一个连接请求后等待一个匹配的连接请求。\nSYN_RECEIVED：发送连接请求并且接收到匹配的连接请求以后等待连接请求确认。\nESTABLISHED：表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态。\nFIN_WAIT_1：等待远端TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认。\nFIN_WAIT_2：等待远端TCP 的连接终止请求。\nCLOSE_WAIT：等待本地用户的连接终止请求。\nCLOSING：等待远端TCP 的连接终止请求确认。\nLAST_ACK：等待先前发送给远端TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认）\nTIME_WAIT：等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认。TIME_WAIT 两个存在的理由：          1.可靠的实现tcp全双工连接的终止；          2.允许老的重复分节在网络中消逝。\nCLOSED：不在连接状态（这是为方便描述假想的状态，实际不存在）\n\n3.为什么需要三次握手，两次不行吗？弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。\n\n第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。\n第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时&#x3D;&#x3D;服务器并不能确认客户端的接收能力是否正常&#x3D;&#x3D;。\n第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。\n\n另一个种解释：\n\n因为某些原因，S没有收到C的包，过了一段时间后才收到，S认为这是两个请求，而C认为是一个请求，从而在2次握手后进入等待状态，造成状态不一致。\n\n如果在3次握手的状态下，S收不到最后的ACK包，自然不会认为连接建立成功。\n\n所以3次握手，就是为了解决网络信道不可靠的问题。\n\n\n因此，需要三次握手才能确认双方的接收与发送能力是否正常。\n\n\n\n\n4.三次握手过程中可以携带数据吗？其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据\n为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。\n也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。\n5.挥手为什么需要四次？因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。\n6.为什么客户端需要等待超时时间这是为了保证对方已经收到ACK。\n\n因为假设客户端发送完最后一份ACK后，就释放了链接，一旦ack包在网络中丢失，服务端将一直停留在最后的确认状态。\n如果客户端发行完最后一份ACK后，等待一段时间，这时服务端又没有收到ACK，会重发FIN包，客户端会响应这个FIN包，重发ACK包，并刷新超时时间，也是为了保证在不可靠的网络链路中进行可靠的链接断开确认\n\n浏览器相关原理(面试题)详细总结一\n","categories":["网络"],"tags":["网络","HTTP"]},{"title":"浏览器的组成与功能","url":"/2019/02/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8A%9F%E8%83%BD/","content":" \n\n浏览器的组成与功能浏览器的内核(渲染引擎)浏览器中有一个最重要的模块，它主要的作用把一切请求回来的资源变为可视化的图像。 这个模块就是浏览器内核，通常它也被称为渲染引擎。 \n浏览器内核总结： IE———-&gt;Trident\nSafari——&gt;WebKit\n​        WebKit本身主要是由两个小引擎构成的，                一个正是渲染引擎“WebCore”，\n                另一个则是javascript解释引擎“JSCore”，\n                它们均是从KDE的渲染引擎KHTML及javascript解释引擎KJS衍生而来。\nChrome——&gt;WebKit的分支引擎—–&gt;Blink\n​        在13年发布的Chrome 28.0.1469.0版本开始，Chrome放弃Chromium引擎转而使用最新的Blink引擎（基于WebKit2——苹果公司于2010年推出的新的WebKit引擎），Blink对比上一代的引擎精简了代码、改善了DOM框架，也提升了安全性。\nOpera——&gt;Blink\n​        Opera在2013年2月宣布放弃Presto:        采用Chromium引擎;        又转为Blink引擎;\nFirefox——&gt;Gecko\n进程与线程进程：​        程序的一次执行, 它占有一片独有的内存空间.是操作系统执行的基本单元。\n​        一个进程中至少有一个运行的线程: 主线程, 进程启动后自动创建。\n​        一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的。\n​        一个进程内的数据可以供其中的多个线程直接共享，多个进程之间的数据是不能直接共享的。\n线程：​        是进程内的一个独立执行单元,是CPU调度的最小单元。程序运行的基本单元。\n​        线程池(thread pool): 保存多个线程对象的容器, 实现线程对象的反复利用。\nJS引擎是单线程运行的！（回忆事件轮询机制）现代浏览器：多进程、多线程模型1.不堪回首的过去:​        当你通过浏览器打开很多页面的时候,如果其中一个页面不响应了或者崩溃了,\n​        那么随之而来的将会是更不幸的事情,你开打的所有页面都会得不到响应,\n​        最让人不能忍受的是,其中的一些页面可能还包含了未保存或者未发送的信息。\n2.浏览器产商如何解决？​        采用多进程模型,该模型可以带来的好处：\n​        ①.避免因单个页面的不响应或者崩溃影响整个浏览器的稳定性；\n​        ②.当第三方插件崩溃时,也不会影响整个浏览器的稳定性；\n​        ③.安全\n3.浏览器到底有些什么进程​        ①.Browser进程:\n​            浏览器的主进程,负责浏览器界面的显示,和各个页面的管理,\n​            浏览器中所有其他类型进程的祖先,负责其他进程的的创建和销毁，\n​            它有且只有一个!!!!!\n​        ②.Renderer进程:\n​            网页渲染进程,负责页面的渲染,可以有多个；\n​            当然渲染进程的数量不一定等于你开打网页的个数。\n​        ③.各种插件进程\n​        ④.GPU进程：​            移动设备的浏览器可能不太一样:\n​                Android不支持插件,所以就没有插件进程；\n​                GPU演化成了Browser进程的一个线程；\n​                Renderer进程演化成了操作系统的一个服务进程,它仍然是独立的。\n4.每个进程内部又有很多线程​        多线程的目的主要是保持用户界面的高度响应。\n​        例如:为了不让Browser进程的UI线程被其他耗时的操作(大文件的加载,本地文件读写)所阻塞,\n​                那么我们就把这些操作放到分线程中去处理。\n​        在Renderer进程中,为了不让其他操作阻止渲染线程的高速执行,我们通常会将渲染过程【管线化】,\n​        利用计算机的多核优势,让渲染的不同阶段在不同的线程中执行\n","categories":["浏览器"],"tags":["浏览器"]},{"title":"图层的重绘与回流","url":"/2019/05/09/%E5%9B%BE%E5%B1%82%E7%9A%84%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/","content":" \n\n图层的重绘与回流css图层览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。\n在渲染DOM的时候，浏览器所做的工作实际上是：\n1. 获取DOM后分割为多个图层；\n2. 对每个图层的节点计算样式结果    （Recalculate style--样式重计算）\n3. 为每个节点生成图形和位置     （Layout--布局，重排,回流）\n4. 将每个节点绘制填充到图层位图中   （Paint--重绘）\n5. 图层作为纹理上传至GPU\n6. 组合多个图层到页面上生成最终屏幕图像  （Composite Layers--图层重组）\n\n图层创建的条件Chrome浏览器满足以下任意情况就会创建图层：\n 1. 拥有具有3D变换的CSS属性（tansform: translateZ(0)）;\n 2. 使用加速视频解码的&lt;video&gt;节点;\n 3. \\&lt;canvas\\&gt;节点;\n 4. CSS3动画的节点;\n 5. 拥有CSS加速属性的元素(will-change)【will-change：transform】\n\n重绘(Repaint)重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。\n需要注意的是：重绘重排都是以图层为单位，如果图层中某个元素需要重绘，那么整个图层都需要重绘。所以为了提高性能，我们应该让这些“变化的东西”拥有一个自己一个图层，不过好在绝大多数的浏览器自己会为CSS3动画的节点自动创建图层。\n重排(Reflow 又称：回流)渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排\n“重绘”不一定需要”重排”，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。\n“重排”大多数情况下会导致”重绘”，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。\n触发重绘的属性* color             * background                * outline-color* border-style      * background-image          * outline* border-radius     * background-position       * outline-style* visibility        * background-repeat         * outline-width* text-decoration   * background-size           * box-shadow\n\n触发重排(回流)的属性* width           * top                  * text-align* height          * bottom               * overflow-y* padding         * left                 * font-weight* margin          * right                * overflow* display         * position             * font-family* border-width    * float                * line-height* border          * clear                * vertival-align* min-height                             * white-space\n\n常见的触发重排的操作Reflow(重排) 的成本比 Repaint(重绘) 的成本高很多很多。\n一个结点的 Reflow 很有可能导致子结点，甚至父点以及同级结点的 Reflow。\n在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。\n所以，下面这些动作有很大可能会是成本比较高的。\n​        当你增加、删除、修改 DOM 结点时，会导致 Reflow , Repaint。\n​        当你移动 DOM 的位置。\n​        当你修改 CSS 样式的时候。\n​        当你 Resize 窗口的时候（移动端没有这个问题，因为移动端的缩放没有影响布局视口)。\n​        当你修改网页的默认字体时。【获取某些属性时(width,height…)！！！！！】\n注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发生位置变化。\n优化方案（重绘重排）我们已知：浏览器渲染页面时经历了如下“细致”的环节：\n1. 计算需要被加载到节点上的样式结果（Recalculate style--样式重计算）；\n2. 为每个节点生成图形和位置（Layout--重排或回流）；\n3. 将每个节点填充到图层中（Paint--重绘）；\n4. 组合图层到页面上（Composite Layers--图层重组）\n\n如果我们需要提升性能，需要做的就是减少浏览器在运行时所需要做的工作，即：尽量减少1234步。\n【具体优化方案如下】：1.元素位置移动变换时尽量使用CSS3的transform来代替对top left等的操作。\n​    变换（transform）和透明度（opacity）的改变仅仅影响图层的组合\n2.使用opacity来代替visibility\n​    (1).使用visibility不触发重排，但是依然重绘。\n​    (2).直接使用opacity既触发重绘，又触发重排（GPU底层设计如此！）。\n​    (3).opacity配合图层使用，既不触发重绘也不触发重排。\n​        原因：\n​                透明度的改变时，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并不需要整体的重绘。\n​                不过这个前提是这个被修改opacity本身必须是一个图层。\n3.不要使用table布局。\n​    table-cell；\n4.将多次改变样式属性的操作合并成一次操作。\n​    不要一条一条地修改DOM的样式，预先定义好class，然后修改DOM的className；\n5.将DOM离线后再修改。\n​    由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。\n​    如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。\n6.利用文档碎片。\n​    (documentFragment)——vue使用了该种方式提升性能。\n7.不要把获取某些DOM节点的属性值放在一个循环里当成循环的变量\n​    当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如：\n 1. offsetTop, offsetLeft, offsetWidth, offsetHeight\n 2. scrollTop/Left/Width/Height\n 3. clientTop/Left/Width/Height\n 4. width,height\n\n​    当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要刷新内部队列，\n​    因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。\n8.动画实现过程中，启用GPU硬件加速:transform: tranlateZ(0)。\n9.为动画元素新建图层,提高动画元素的z-index\n10.编写动画时，尽量使用如下的API：\nrequestAnimationFrame—-请求动画帧1.window.requestAnimationFrame()\n说明：该方法会告诉浏览器在下一次重绘重排之前调用你所指定的函数。\n①参数：\n​        该方法使用一个回调函数作为参数，这个回调函数会在浏览器下一次重绘之前调用。\n​        回调函数会被自动传入一个参数，DOMHighResTimeStamp，标识requestAnimationFrame()开始触发回调函数的当前时间\n②返回值：\n​            一个 long 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。你可以传这个值给 window.cancelAnimationFrame() 以取消回调函数。\n备注：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()\n2.window.cancelAnimationFrame(requestID)\n​        取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。\n​        requestID是先前调用window.requestAnimationFrame()方法时返回的值，它是一个时间标识，用法与定时器的id类似。\n","categories":["浏览器"],"tags":["缓存","浏览器"]},{"title":"细说浏览器输入URL后发生了什么","url":"/2019/04/28/%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/","content":" \n\n细说浏览器输入URL后发生了什么大体上，可以分为六步，当然每一步都可以详细都展开来说，这里先放一张总览图:\n\n1. 合成URL​\t\t用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引警合成新的URL， 如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL\n2. DNS域名解析​\t\t在网络世界，你肯定记得住网站的名称，但是很难记住网站的 IP 地址，因而也需要一个地址簿，就是 DNS 服务器。DNS 服务器是高可用、高并发和分布式的，它是树状结构，如图：\n\n根域名：www.baidu.com 的完整写法是 www.baidu.com.最后的这个 . 就是根域名。（下一级是顶级域名）\n顶级域 ：com, cn、org、edu 等。（下一级是权威 DNS 服务器）\n权威 DNS 服务器：返回主机 - IP 的最终映射。\n\n\n\n\n根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址\n顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址\n权威 DNS 服务器 ：返回相应主机的 IP 地址\n\nDNS的域名查找，在客户端和浏览器，本地DNS之间的查询方式是递归查询；\n在本地DNS服务器与根域及其子域之间的查询方式是迭代查询；\n递归过程：\n![image-20230410214854082](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230410214854082.png)\n​\t\t在客户端输入 URL 后，会有一个递归查找的过程，&#x3D;&#x3D;从浏览器缓存中查找 -&gt; 本地的hosts文件查找 -&gt; 找本地DNS解析器缓存查找 -&gt; 本地DNS服务器查找&#x3D;&#x3D;，这个过程中任何一步找到了都会结束查找流程。\n​\t\t如果本地DNS服务器无法查询到，则根据本地DNS服务器设置的转发器进行查询。若未用转发模式，则迭代查找过程如下图：\n\n\n结合起来的过程，可以用一个图表示：\n\n\n在查找过程中，有以下优化点：\n\nDNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。\n\n在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。\n\n\n3. 建立TCP连接​\t\t首先，判断是不是https的，如果是，则HTTPS其实是HTTP + SSL &#x2F; TLS 两部分组成，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。\n进行&#x3D;&#x3D;三次握手&#x3D;&#x3D;，建立TCP连接。\n\n第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；\n第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；\n第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。\n\nSSL握手过程\n\n第一阶段：建立安全能力，包括协议版本、会话Id、密码构件、压缩方法和初始随机数；\n第二阶段：服务器发送证书，密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号；\n第三阶段：如果有证书请求客户端发送此证书，之后客户端发送密钥交换数据，也可以发送证书验证消息；\n第四阶段：变更密码构件和结束握手协议\n\n完成了之后，客户端和服务器端就可以开始传送数据。更多 HTTPS 的资料可以看这里：\n\n深入理解HTTPS原理、过程与实践\n解析HTTPS\n\n备注\nACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。TCP协议规定，只有ACK&#x3D;1时有效，也规定连接建立后所有发送的报文的ACK必须为1。\nSYN(SYNchronization)：在连接建立时用来同步序号。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN&#x3D;1和ACK&#x3D;1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。\nFIN(finis）即完，终结的意思， 用来释放一个连接。当 FIN &#x3D; 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。\n4. 发送HTTP请求，服务器处理请求，返回响应结果​\t\tTCP连接建立后，浏览器就可以利用HTTP／HTTPS协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200.\n这里有发生的一个过程是HTTP缓存，是一个常考的考点，大致过程如图：\n其过程，比较多内容，可以参考我的这篇文章《浏览器相关原理(面试题)详细总结一》，这里我就不详细说了～\n5.关闭TCP连接\n第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；\n\n第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我”同意”你的关闭请求；\n\n第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；\n\n第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。\n\n\n6.浏览器渲染按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示。如图：\n![image-20230410220321066](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230410220321066.png)\n\n渲染进程将 HTML 内容转换为能够读懂DOM 树结构。\n渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。\n创建布局树，并计算元素的布局信息。\n对布局树进行分层，并生成分层树。\n为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。\n合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。\n\n6.1 构建 DOM 树浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程将字节解析为DOM树，先将HTML的原始字节数据转换为文件指定编码的字符，然后浏览器会根据HTML规范来将字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树。\n![image-20230410220818656](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230410220818656.png)\n具体步骤：\n\n转码（Bytes -&gt; Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串；\nTokens 化（Characters -&gt; Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则；\n构建 Nodes（Tokens -&gt; Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope；\n构建 DOM 树（Nodes -&gt; DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系\n\n6.2 样式计算渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。\nCSS 样式来源主要有 3 种，分别是通过 link 引用的外部 CSS 文件、style标签内的 CSS、元素的 style 属性内嵌的 CSS。,其样式计算过程主要为：\n可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。处理完成后再处理样式的继承和层叠，有些文章将这个过程称为CSSOM的构建过程。\n6.3 页面布局布局过程，即排除 script、meta 等功能化、非视觉节点，排除 display: none 的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。如图：\n![image-20230410221008150](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230410221008150.png)\n![image-20230410220939974](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230410220939974.png)\n其中，这个过程需要注意的是回流和重绘，关于回流和重绘，详细的可以看我另一篇文章《浏览器相关原理(面试题)详细总结二》，这里就不说了～\n6.4 生成分层树页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree），如图：\n![image-20230410221057683](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230410221057683.png)\n如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。在浏览器中，你可以打开 Chrome 的”开发者工具”，选择”Layers“标签。渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。\n并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？详细的可以看我另一篇文章《浏览器相关原理(面试题)详细总结二》，这里就不说了～\n栅格化合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。如图：\n\n\n通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。\n显示最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。\n原文地址：细说浏览器输入URL后发生了什么\n","categories":["网络"],"tags":["网络","HTTP"]},{"title":"网络安全","url":"/2019/05/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/","content":" \n\n1. XSSXSS（Cross Site Script），即&#x3D;&#x3D;跨站脚本攻击&#x3D;&#x3D;；\nXSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。\n攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。\nXSS攻击可以分为3类：\n\n反射型（非持久型）\n存储型（持久型）\n基于DOM。\n\n1.1 反射型反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。\n攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如cookie)的脚本，这取决于攻击者的目的。\n1.2 存储型存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。\n比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。\n当用户点击提交按钮将输入信息提交到服务端时，服务端通过 userInput 变量保存了输入内容。当用户通过 http://localhost:8001/$&#123;id&#125; 访问时，服务端会返回与 id 对应的内容(本示例简化了处理)。如果用户输入了恶意脚本内容，则其他用户访问该内容时，恶意脚本就会在浏览器端执行：\n1.3 基于DOM基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。\n看如下代码：\n&lt;h2&gt;XSS: &lt;/h2&gt;&lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;&lt;button id=&quot;btn&quot;&gt;Submit&lt;/button&gt;&lt;div id=&quot;div&quot;&gt;&lt;/div&gt;&lt;script&gt;    const input = document.getElementById(&#x27;input&#x27;);    const btn = document.getElementById(&#x27;btn&#x27;);    const div = document.getElementById(&#x27;div&#x27;);    let val;         input.addEventListener(&#x27;change&#x27;, (e) =&gt; &#123;        val = e.target.value;    &#125;, false);    btn.addEventListener(&#x27;click&#x27;, () =&gt; &#123;        div.innerHTML = `&lt;a href=$&#123;val&#125;&gt;testLink&lt;/a&gt;`    &#125;, false);&lt;/script&gt;\n\n点击 Submit 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容：\n&#x27;&#x27; onclick=alert(/xss/)\n\n用户提交之后，页面代码就变成了：\n&lt;a href onlick=&quot;alert(/xss/)&quot;&gt;testLink&lt;/a&gt;\n\n此时，用户点击生成的链接，就会执行对应的脚本：\n2. XSS 攻击的防范现在主流的浏览器内置了防范 XSS 的措施，例如 CSP。但对于开发者来说，也应该寻找可靠的解决方案来防止 XSS 攻击。\n2.1 HttpOnly 防止劫取 CookieHttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。\n上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。\n2.2 输入检查不要相信用户的任何输入。 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。\n在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 &lt;，&gt; 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。\n而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 &lt;，&gt;，script，防止 XSS 攻击：\nconst decodingMap = &#123;  &#x27;&amp;lt;&#x27;: &#x27;&lt;&#x27;,  &#x27;&amp;gt;&#x27;: &#x27;&gt;&#x27;,  &#x27;&amp;quot;&#x27;: &#x27;&quot;&#x27;,  &#x27;&amp;amp;&#x27;: &#x27;&amp;&#x27;,  &#x27;&amp;#10;&#x27;: &#x27;\\n&#x27;&#125;\n\n\n\n2.3 输出检查用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。\n3. CSRFCSRF（ Cross Site Request Forgery），中译是&#x3D;&#x3D;跨站请求伪造&#x3D;&#x3D;，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。\n通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。\n在举例子之前，先说说浏览器的 Cookie 策略。\n3.1 浏览器的 Cookie 策略Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。Cookie 主要用于以下三个方面：\n\n会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\n个性化设置（如用户自定义设置、主题等）\n浏览器行为跟踪（如跟踪分析用户行为等）\n\n而浏览器所持有的 Cookie 分为两种：\n\nSession Cookie(会话期 Cookie)：会话期 Cookie 是最简单的Cookie，它不需要指定过期时间（Expires）或者有效期（Max-Age），它仅在会话期内有效，浏览器关闭之后它会被自动删除。\nPermanent Cookie(持久性 Cookie)：与会话期 Cookie 不同的是，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。\n\nres.setHeader(&#x27;Set-Cookie&#x27;, [&#x27;mycookie=222&#x27;, &#x27;test=3333; expires=Sat, 21 Jul 2018 00:00:00 GMT;&#x27;]);\n\n上述代码创建了两个 Cookie：mycookie 和 test，前者属于会话期 Cookie，后者则属于持久性 Cookie。当我们去查看 Cookie 相关的属性时，不同的浏览器对会话期 Cookie 的 Expires 属性值会不一样：\nFirefox：\n![image-20230414081138509](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230414081138509.png)\nChrome:\n![image-20230414081204646](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230414081204646.png)\n此外，每个 Cookie 都会有与之关联的域，这个域的范围一般通过 donmain 属性指定。如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie（first-party cookie），如果 Cookie 的域和页面的域不同，则称之为第三方 Cookie（third-party cookie）。一个页面包含图片或存放在其他域上的资源（如图片）时，第一方的 Cookie 也只会发送给设置它们的服务器。\n3.2 通过 Cookie 进行 CSRF 攻击由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。\n但若 CSRF 攻击的目标并不需要使用 Cookie，则也不必顾虑浏览器的 Cookie 策略了。\n4. CSRF 攻击的防范当前，对 CSRF 攻击的防范措施主要有如下几种方式。\n\n验证码\nreferer check\n添加 token 验证\n\n4.1 验证码验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。\n从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。\n但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。\n4.2 Referer Check根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。\n比如，如果用户要删除自己的帖子，那么先要登录 www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 http://www.c.com；当请求是从 www.a.com 发起时，Referer 的值是 http://www.a.com 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 www.c.com 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。\nReferer Check 不仅能防范 CSRF 攻击，另一个应用场景是 “防止图片盗链”。\n4.3 添加 token 验证CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。\n总结XSS攻击可以分为3类：\n\n反射型（非持久型）：诱导用户点击恶意链接；\n\n存储型（持久型）：攻击者在论坛上写下一篇包含恶意 脚本的文章或评论，用户访问后，会在他们的浏览器中执行这段恶意的脚本。\n\n基于DOM：通过恶意脚本修改页面的 DOM 结构\n\n\n总结一下 XSS 攻击和 CSRF 攻击的常见防御措施：\n\n防御 XSS 攻击\n\nHttpOnly 防止劫取 Cookie。（浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。）\n用户的输入检查。（对于用户的任何输入要进行检查、过滤和转义，对特殊字符进行过滤或编码）\n服务端的输出检查\n\n\n防御 CSRF 攻击\n\n验证码\nReferer Check\nToken 验证\n\n\n\n👉👉 浅说 XSS 和 CSRF\n","categories":["安全"],"tags":["网络","安全"]},{"title":"性能优化总结","url":"/2019/07/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/","content":" \n\n\n\ncss 和 js 优化\n\n减少css和js阻塞；\n优化样式表的代码（选择器的权重）；\n异步加载js（ script 标签加上 defer 属性），放在页面底部；\n对css、js进行压缩；\n减少http请求数，将多个css、js文件合并。\n\n\n使用CDN节点进行外部资源加速。\n\n图片优化\n\n使用字体图标代替图片图标\n图片使用CSS雪碧图\n图片懒加载\n响应式图片。根据屏幕大小自动加载合适的图片\n图片压缩\n\n\n减少重绘和回流\n\n元素位置移动变换时尽量使用transform\n用opacity来代替visibility（opacity配合图层使用，既不触发重绘也不触发重排）\n将多次改变样式属性的操作合并成一次操作。（预先定义好class，然后修改DOM的className）\n将DOM离线后再修改（先隐藏它，操作完成后再显示，这样只在隐藏和显示时触发2次重排）\n利用文档碎片。（documentFragment）\n动画实现过程中，启用GPU硬件加速:transform: tranlateZ(0)。\n使用requestAnimationFrame(cb) （请求动画帧：回调函数会在浏览器下一次重绘之前调用。）\n\n\n使用事件委托。（利用事件冒泡，可以管理某一类型的所有事件，可以节省内存）\n\n强缓存\n\nExpires\ncache-control: max-age &#x3D; number\n\n\n协商缓存\n\nLast-Modified&#x2F;If-Modified-Since\nEtag&#x2F;If-None-Match\n\n\nStorage\n\n资源预加载\n\n prefetch 是利用浏览器的空闲时间，加载页面将来可能用到的资源的一种机制；通常可以用于加载其他页面（非首页）所需要的资源，以便加快后续页面的打开速度\n 在后台预加载具有高优先级的资源，对于在几秒钟内预加载您需要的资源非常有用\n\n\nwebpack打包优化\n\n**alias**：起别名，减少查找过程\n\n后缀尝试列表要尽可能的小，导入文件时尽可能的带上后缀，避免寻找过程（extensions）\n\ninclude 缩小打包范围\n\nGzip 对文件进行压缩，能大大提高首屏加载速度\n\n总体优化\n\n异步加载或按需加载\n路由懒加载（实现：ES6动态加载模块import() ）\n服务端渲染。提高首屏加载速度。\n\n\nDNS预解析。   适用于网页引用了大量其他域名的资源\n\nWeb Worker\n\n作用就是为 JavaScript 创造多线程环境，将一些任务在后台运行。\nWorker 线程完成计算任务，再把结果返回给主线程。\n好处是一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。\n\n\n\n\n","categories":["性能"],"tags":["网络","性能"]},{"title":"网页渲染原理","url":"/2019/06/26/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/","content":" \n\n浏览器相关原理详细总结二浏览器渲染过程是怎样的？按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示。\n\n渲染进程将 HTML 内容转换为能够读懂DOM 树结构。\n渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。\n创建布局树，并计算元素的布局信息。\n对布局树进行分层，并生成分层树。\n为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。\n合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。\n\n浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程将字节解析为DOM树，先将HTML的原始字节数据转换为文件指定编码的字符，然后浏览器会根据HTML规范来将字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树。\n获取css，获取style标签内的css、或者内嵌的css，或者当HTML代码遇见标签时，浏览器会发送请求获得该标签中标记的CSS，当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的styleSheets。\n创建布局树，遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。最后计算 DOM 元素的布局信息，使其都保存在布局树中。\n布局完成过程中，如果有js操作或者其他操作，对元素的颜色，背景等作出改变就会引起重绘，如果有对元素的大小、定位等有改变则会引起回流。\n因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。\n渲染引擎实现图层的绘制，把一个图层的绘制拆分成很多小的绘制指令然后再把这些指令按照顺序组成一个待绘制列表，当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程，合成线程会将图层划分为图块，然后按照视口附近的图块来优先生成位图(实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图)\n一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令，然后将该命令提交给浏览器进程,浏览器最后进行显示。\n如何理解回流和重绘？回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。\n重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。 由此我们可以看出，重绘不一定导致回流，回流一定会导致重绘。\n常见的会导致回流的元素：\n常见的几何属性有 width、height、padding、margin、left、top、border 等等。\n\n最容易被忽略的操作：获取一些需要通过即时计算得到的属性,当你要用到像这样的属性：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight 时，浏览器为了获取这些值，也会进行回流。\n\n当我们调用了 getComputedStyle 方法，或者 IE 里的 currentStyle 时，也会触发回流。原理是一样的，都为求一个“即时性”和“准确性”。\n\n\n避免方式：\n避免逐条改变样式，使用类名去合并样式；\n将 DOM “离线”，使用DocumentFragment；\n提升为合成层，如使用will-change\n\n#divId &#123;  will-change: transform;&#125;\n\n优点\n\n合成层的位图，会交由 GPU 合成，比 CPU 处理要快;\n当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层；\n对于 transform 和 opacity 效果，不会触发 layout 和 paint；\n\n注意：\n部分浏览器缓存了一个 flush 队列，把我们触发的回流与重绘任务都塞进去，待到队列里的任务多起来、或者达到了一定的时间间隔，或者“不得已”的时候，再将这些任务一口气出队。但是当我们访问一些即使属性时，浏览器会为了获得此时此刻的、最准确的属性值，而提前将 flush 队列的任务出队。\n渲染引擎什么情况下才会为特定的节点创建新的图层？层叠上下文是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。\n1、拥有层叠上下文属性的元素会被提升为单独的一层。拥有层叠上下文属性：\n\n根元素 (HTML),\nz-index 值不为 “auto”的 绝对&#x2F;相对定位元素，\nposition,固定（fixed） &#x2F; 沾滞（sticky）定位（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）\nz-index值不为 “auto”的 flex 子项 (flex item)，即：父元素 display: flex|inline-flex\nz-index值不为”auto”的grid子项，即：父元素display：grid\nopacity 属性值小于 1 的元素,\ntransform 属性值不为 “none”的元素，\nmix-blend-mode 属性值不为 “normal”的元素，\nfilter值不为”none”的元素，\nperspective值不为”none”的元素，\nclip-path值不为”none”的元素\nmask &#x2F; mask-image &#x2F; mask-border不为”none”的元素\nisolation 属性被设置为 “isolate”的元素\n在 will-change 中指定了任意CSS属性（参考 这篇文章）\n-webkit-overflow-scrolling 属性被设置 “touch”的元素\ncontain属性值为”layout”，”paint”，或者综合值比如”strict”，”content”\n\n2、需要剪裁（clip）的地方也会被创建为图层。这里的剪裁指的是，假如我们把 div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域。出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。\n","categories":["浏览器"],"tags":["浏览器"]},{"title":"CDN工作原理","url":"/2019/07/22/CDN%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","content":" \n\n\n什么是CDN？工作原理是什么？网站通常将其所有的服务器都放在同一个地方，当用户群增加时，公司就必须在多个地理位置不同的服务器上部署内容。\n为了缩短http请求的时间，我们应该把大量的静态资源放置的离用户近一点。\n&#x3D;&#x3D;内容发布网络CDN（Content Delivery Networks）&#x3D;&#x3D;（也叫内容分发网络）\n​         CDN是一组分布在多个不同地理位置的web服务器，用于更加有效的向用户发布内容。\n基本思路：\n尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。\n\n通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，\n\n&#x3D;&#x3D;CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息&#x3D;&#x3D;\n\n\n​        &#x3D;&#x3D;将用户的请求重新导向离用户最近的服务节点上。&#x3D;&#x3D;\n基础架构：最简单的CDN网络由一个DNS服务器和几台缓存服务器组成。\n用户输入的url，会经过DNS解析“翻译”成对应的ip地址，从而找到CDN专用的服务器。\n\nCDN “拿到” 用户的IP地址，随后和区域负载均衡设备配合，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。\n\n上述步骤中的“选择”依据：\n\n\n​        (1). 选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；\n​        (2). 根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；\n​        (3). 查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。\n当用户访问一个网站时，如果没有 CDN，过程是这样的：\n\n浏览器要将域名解析为 IP 地址，所以需要向本地 DNS(Domain Name System) 发出请求。\n本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址。\n本地 DNS 将 IP 地址发回给浏览器，浏览器向网站服务器 IP 地址发出请求并得到资源。\n\n\n\n\n\n如果用户访问的网站部署了 CDN，过程是这样的：\n\n浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。\n本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到&#x3D;&#x3D;全局负载均衡系统（GSLB）&#x3D;&#x3D;的 IP 地址。\n本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的&#x3D;&#x3D;本地负载均衡系统（SLB）&#x3D;&#x3D;，并将该 SLB 的 IP 地址作为结果返回给本地 DNS。\n本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。\nSLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。\n浏览器再根据 SLB 发回的地址重定向到缓存服务器。\n如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。\n\n","categories":["网络"],"tags":["网络"]},{"title":"HTTP相关","url":"/2019/08/07/HTTP%E7%9B%B8%E5%85%B3/","content":" \n\n1、http 和 https 的基本概念​\t\t**http (HyperText Transfer Protocol)**：是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的&#x3D;&#x3D;超文本传输协议&#x3D;&#x3D;。\n​\t\thttps：是以安全为目标的 HTTP 通道，即 HTTP 下 加入 &#x3D;&#x3D;SSL 层进行加密&#x3D;&#x3D;。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。\nHTTP + SSL&#x2F;TLS &#x3D; HTTPSSSL(Secure Sockets Layer，安全套接字协议)\nTLS(Transport Layer Security，传输层安全协议)\nHTTP(HyperText Transfer Protocol ，超文本传输协议)，让计算机之间可以进行明文数据交换，默认端口80.\nHTTPS(HyperText Transfer Protocol Secure，超文本传输安全协议)，用SSL&#x2F;TLS对数据加密，再通过HTTP传输，保证数据的安全性，默认端口443.\nTLS是基于SSL 3.0的一个新版本，原则上他的名字是SSL 4.0；只是IETF在把SSL标准化时把SSL名称改成了TLS。\n2、HTTP​\t\t在实际应用中，HTTP常被用于在Web浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密。\n特点如下：\n\n支持客户&#x2F;服务器模式；\n简单快速：客户向服务器请求服务时，只需传送请求方法和路径。**&#x3D;&#x3D;由于HTTP协议简单&#x3D;&#x3D;，使得HTTP服务器的程序规模小，因而&#x3D;&#x3D;通信速度很快&#x3D;&#x3D;**；\n灵活：HTTP**&#x3D;&#x3D;允许传输任意类型的数据对象&#x3D;&#x3D;**。正在传输的类型由Content-Type加以标记；\n无连接：无连接的含义是**&#x3D;&#x3D;限制每次连接只处理一个请求&#x3D;&#x3D;**。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间;\n无状态：HTTP协议无法根据之前的状态进行本次的请求处理;\n\n3、HTTPS​\t\t在上述介绍HTTP中，了解到HTTP传递信息是以明文的形式发送内容，这并不安全。而HTTPS出现正是为了解决HTTP不安全的特性。\n​\t\t为了保证这些隐私数据能加密传输，让HTTP运行安全的SSL/TLS协议上，即 &#x3D;&#x3D;HTTPS &#x3D; HTTP + SSL&#x2F;TLS&#x3D;&#x3D;，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。\n​\t\tSSL 协议位于TCP/IP 协议与各种应用层协议之间，浏览器和服务器在使用 SSL 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持\n流程如下：\n\n客户端向服务器发起 HTTPS 请求，请求中包含了 SSL&#x2F;TLS 支持的信息，比如支持的 SSL&#x2F;TLS 版本号、加密算法等。\n服务器返回证书给客户端，证书中包含了服务器的公钥、服务器的身份信息和证书的有效期等。\n客户端验证服务器的身份，包括验证证书的有效性、证书是否过期、证书中的域名与服务器的域名是否一致等。\n如果证书验证通过，客户端生成一个随机的加密密钥，并使用服务器的公钥进行加密，然后发送给服务器。\n服务器使用私钥解密客户端发来的密钥，然后生成一个随机数作为会话密钥，并将会话密钥加密后发送给客户端。\n客户端和服务器使用会话密钥进行数据传输，客户端和服务器之间的所有数据都使用会话密钥进行加密和解密，保证数据的机密性和完整性。\n\n简洁版：\n客户端使用https的url访问web服务器,要求与服务器建立ssl连接\nweb服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端\n客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥\n客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥\n之后服务器与客户端使用秘钥加密传输\n\n4、http 和 https 的区别及优缺点\nhttp 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。\nhttp 协议的默认端口为 80，https 的默认端口为 443。\nhttp 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。\nhttps 缓存不如 http 高效，会增加数据开销。\nHttps 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。\nSSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。\n\n5、http1和http1.1的区别\n&#x3D;&#x3D;持久连接&#x3D;&#x3D;：\n\nHTTP &#x2F; 1.1引入了持久连接，这意味着在单个TCP连接上可以发送多个请求&#x2F;响应对，从而减少了每个请求的延迟。\nHTTP &#x2F; 1.0在每个请求&#x2F;响应之后关闭TCP连接。\n\n\n&#x3D;&#x3D;块传输编码&#x3D;&#x3D;：\n​\t\tHTTP &#x2F; 1.1支持块传输编码，这意味着可以在接收响应时逐步解压缩数据，而不必等待整个响应。这对于处理大型响应或流式数据非常有用。\n\n&#x3D;&#x3D;身份验证&#x3D;&#x3D;：\n​\t\tHTTP &#x2F; 1.1提供了更安全的身份验证方法，例如基于令牌的身份验证方案，可以替代HTTP &#x2F; 1.0中的基本身份验证。\n\n&#x3D;&#x3D;缓存处理&#x3D;&#x3D;：\n​\tHTTP &#x2F; 1.1对缓存处理进行了改进，包括新的Cache-Control指令，可以更好地控制缓存行为。\n\n&#x3D;&#x3D;响应码&#x3D;&#x3D;：\n​\tHTTP &#x2F; 1.1引入了更多的响应码，例如“100 Continue”，这使得客户端可以更好地控制它们的请求行为。\n\n&#x3D;&#x3D;管道化&#x3D;&#x3D;：\n​\tHTTP &#x2F; 1.1支持管道化，允许客户端同时发送多个请求，从而提高性能。\n\n\n6、GET 和 POST 的区别1. POST请求相对安全，GET请求相对不安全\nGET请求参数会直接挂载在URL上。POST请求携带的参数在URL上看不见。\nPOST请求记录不会被保存在浏览器历史或web服务器日志中。但是GET请求会。\n\n当然，以上是相对的。这不表示POST请求就绝对安全，其实。\n从数据传输的角度来说，POST和GET都不是很安全，因为http协议本身是明文传输。对内行人来说，抓包解析GET和POST都是一样的。\n2. GET请求可以缓存，POST请求不能缓存​\t\tGET请求一般用于数据和静态资源的获取，有些GET请求不用和数据库交互。比如一些静态资源和固定的字典表。所以可以使用缓存。\n数据缓存👇\n![image-20230411143847289](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230411143847289.png)\n静态资源缓存👇\n![image-20230411143907562](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230411143907562.png)\nPOST请求则更多用于数据的新增和修改。新增数据无法具备固定内容。所以很多浏览器都不支持缓存POST请求\n3. GET请求有长度限制，POST请求没有长度限制GET请求本身是没有长度限制的，但是URL有。不同的浏览器对于GET的长度限制也不一样。\n4. GET只能传输字符串，POST可以传输多种类型数据​\t\t因为GET请求是挂载在URL上的，所以传输的数据类型只能是字符串，但是POST请求可以传输除字符串以外的数据，比如：视频，声音，图片，文档等。\n5. GET请求入参在URL上，POST请求入参在Request body上​\t\t\n6. POST有可能产生两个数据包，GET只会发送一个数据包​\t\tGET请求在任何情况下都会把http header和data一次性发送完成。\n​\t\tPOST在部分情况下，（这取决于 浏览器&#x2F;发送方 和它的版本），会产生两个数据包。第一个tcp发送header,确认服务器可以响应并且具备接受数据的能力，响应100。第二个TCP包在第一个请求成功（100后）才会发送。包含data。如果第一个请求（header）失败，则data不进行发送。\n7.  刷新和回退的时候GET请求无害，POST数据会被重新提交​\t\t以前我一直没搞明白这一点区别的含义，怎么GET就无害了，POST就又会重新提交了。后来我明白了。\n​\t\t这点区别指向的是那些页面加载时候就默认执行的请求。\n​\t\t比如静态资源获取，刷新了就得重新加载吧。如果是GET，GET主要用重新获取数据，因为是获取，请求不会对数据产生什么危害，何况有时候还直接返回的缓存。所以无害。\n​\t\t再说POST，POST主要用于数据的修改&#x2F;新增，针对默认执行的情况下，POST请求的每次执行都有可能改变数据库中的某一个值，比如文章的阅读量。刷新一下就+1（不信你刷一个试试）。所以这里说POST数据会被重新提交，这种提交他不一定有害，但确实不一定有用。\n7、HTTP状态码使用场景:\n1xx：表示目前是协议的中间状态，还需要后续请求。\n2xx：表示请求成功。\n3xx：表示重定向状态，需要重新请求。\n4xx：表示请求报文错误。\n5xx：服务器端错误。\n\n常用状态码：\n101 切换请求协议，从 HTTP 切换到 WebSocket\n200 请求成功，有响应体，服务器成功返回网页\n301 永久重定向：会缓存\n302 临时重定向：不会缓存\n304 协商缓存命中\n403 服务器禁止访问\n404 资源未找到，请求的网页不存在\n400 请求错误\n500 服务器端错误\n503 服务器繁忙\n\n8、跨域解决方案8.1 JSONPJSONP 主要就是利用了 script 标签没有跨域限制的这个特性来完成的。\n仅支持 GET 方法，如果想使用完整的 REST 接口，请使用 CORS 或者其他代理方式。\n后端获取前端声明的执行函数（jsonpCallback），并以带上参数并调用执行函数的方式传递给前端。\nfunction callback()&#123;    console.log(&quot;月薪一千五，心比美式苦&quot;)&#125;$.ajax(&#123;    url: &#x27;http://www.domain2.com:8080/login&#x27;,    type: &#x27;get&#x27;,    dataType: &#x27;jsonp&#x27;,  // 请求方式为jsonp  设置跨域的重点    jsonpCallback: &quot;callBack&quot;,  // 回调函数&#125;);\n\n\n\n8.2 添加Access-Control-Allow-Origin响应头res.writeHead(200, &#123;    Access-Control-Allow-Origin&#x27;:&#x27;http://192.168.0.103:8080&#x27;\t\t// 或者    Access-Control-Allow-Origin&#x27;:&#x27;*&#x27;&#125;);\n\n\n\n8.3 前端工具的Proxy代理devServer: &#123;  port: 8000,    proxy: &#123;      &quot;/api&quot;: &#123;        target: &quot;http://localhost:8080&quot;      &#125;    &#125;&#125;,\n\n\n\n8.4 Nginx 反向代理server &#123;  listen 80;  server_name local.test;  location /api &#123;    proxy_pass http://localhost:8080;  &#125;  location / &#123;    proxy_pass http://localhost:8000;  &#125;&#125;\n\n\n\n8.5 WebsocketWebSocket 规范定义了一种 API，可在网络浏览器和服务器之间建立“套接字”连接。简单地说：客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据\n这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制。\n8.6 document.domain + Iframe「该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式」。 只需要给页面添加 document.domain =&#39;test.com&#39; 表示二级域名都相同就可以实现跨域。\nwww.   baidu.  com     .三级域  二级域   顶级域   根域\n\n8.7 window.location.hash + Iframe8.8 window.name + Iframe","categories":["网络"],"tags":["网络","HTTP"]},{"title":"二叉树","url":"/2020/01/18/%E4%BA%8C%E5%8F%89%E6%A0%91/","content":" \n\n二叉树+ 特性\n\n一个二叉树第i层的最大节点树为： &#x3D;&#x3D;2^(i-1)&#x3D;&#x3D;, i &gt;&#x3D; 1;\n\n深度为K的二叉树有最大节点总数为：&#x3D;&#x3D;2^k - 1&#x3D;&#x3D;, k &gt;&#x3D; 1;\n\n对任何非空二叉树T，若n0表示叶节点的个数、n2是度为2的非叶节点个数，\n那么两者满足关系n0 &#x3D; n2 + 1;\n\n\n二叉搜索树（BST， Binary Search Tree）,也叫二叉排序树，或二叉查找树\n\n二又搜索树是一颗二叉树，可以为空;\n如果不为空，满足以下&#x3D;&#x3D;性质&#x3D;&#x3D;\n非空&#x3D;&#x3D;左子树&#x3D;&#x3D;的所有键值&#x3D;&#x3D;小于&#x3D;&#x3D;其&#x3D;&#x3D;根节点&#x3D;&#x3D;的键值\n非空&#x3D;&#x3D;右子树&#x3D;&#x3D;的所有键值&#x3D;&#x3D;大于&#x3D;&#x3D;其&#x3D;&#x3D;根节点&#x3D;&#x3D;的键值\n\n\n左、右子树本身也都是二叉搜索树\n\n![image-20230403220345266](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230403220345266.png)\n特点：\n相对较小的值总是保存在左节点上，相对较大的值总是保存在右节点上。\n查找效率非常高，这也是二又搜索树中，搜索的来源\n\n+ 二叉搜索树作为数据存储有重要优势：\n可以快速地找到给定关键字的数据项并且可以快速地插入和删除数据项.\n+ 问题\n如果插入的数据是有序的数据，树的深度会很大，反而影响效率；\n树的遍历适用于所有二叉树\n\n先序遍历\n\n\n1.访问根节点\n2.遍历其左子树\n3.遍历其右子树\n\n\n中序遍历\n\n\n1.遍历其左子树\n2.访问根节点\n3.遍历其右子树\n\n\n后序遍历\n\n\n1.遍历其左子树\n2.遍历其右子树\n3.访问根节点\n\n\n\n二叉搜索树-封装属性：node\nkey: 键\nleft：左子节点\nright：右子节点\n方法：\n\ninsert ()：向树中插入一个新的键;\n\nsearch (key)：搜索特定的节点（值），存在返回true，否则返回false;\n\nmidOrderTraversal ()：通过中序遍历方式遍历所有节点，根节点在中间时遍历\n\npreOrderTraversal ()：通过先序遍历方式遍历所有节点：\n根节点最先遍历：从上到左 -&gt; 从左到右 -&gt; 从子到父\n\npostOrderTraversal ()：通过后序遍历方式遍历所有节点，最后遍历根节点\n\nmin ()：返回树中最小的值&#x2F;键。一直往左节点查找\n\nmax ()：返回树中最大的值&#x2F;键\n\nremove (key)：从树中移除某个节点\n\n\n/***************  二叉搜索树的封装 ***********/\t/**   *             11   *        7             15   *    5      9      13      20   *  3   6  8  10  12  14  18  25   */function BinarySearchTree() &#123;  function Node(key) &#123;    this.key = key;    this.left = null    this.right = null;  &#125;  this.root = null;  /**     * @description 向树中插入一个新的键     *      * 思路：     * 1.从根节点开始查找，大于该节点，往右查找；小于该节点，往左查找；     * 2.直到 被计较的 节点为空，则在该位置插入新节点；     *      */  BinarySearchTree.prototype.insert = function (key) &#123;    // 1.创建节点    const newNode = new Node(key);    // 2.判断是否存在根节点    if (this.root == null) &#123;      this.root = newNode;    &#125; else &#123;      this.insertNode(this.root, newNode);    &#125;  &#125;  /**     * @description 内部调用的方式，不对外暴露     * @node 被计较的节点     * @newNode 要插入的节点     *      */  BinarySearchTree.prototype.insertNode = function (node, newNode) &#123;    if (newNode.key &lt; node.key) &#123; // 向左查找      if (node.left == null) &#123; // 左边节点不存在，直接插入        node.left = newNode;      &#125; else &#123; // 左边节点不为空，继续进行比较        this.insertNode(node.left, newNode);      &#125;    &#125; else &#123; // 向右查找      if (node.right == null) &#123;        node.right = newNode;      &#125; else &#123; // 右边节点不为空，继续进行比较        this.insertNode(node.right, newNode);      &#125;    &#125;  &#125;  // 通过中序遍历方式遍历所有节点，根节点在中间时遍历  BinarySearchTree.prototype.midOrderTraversal = function (handler) &#123;    this.midOrderTraversalNode(this.root, handler);  &#125;  BinarySearchTree.prototype.midOrderTraversalNode = function (node, handler) &#123;    if (node !== null) &#123;      // 1.处理经过节点的 左子节点      this.preOrderTraverseNode(node.left, handler);      // 2.处理经过的节点      handler(node.key);      // 3.处理经过节点的 右子节点      this.preOrderTraverseNode(node.right, handler);    &#125;  &#125;  // 通过先序遍历方式遍历所有节点：根节点最先遍历：从上到左 -&gt; 从左到右 -&gt; 从子到父  BinarySearchTree.prototype.preOrderTraversal = function (handler) &#123;    this.preOrderTraverseNode(this.root, handler);  &#125;  BinarySearchTree.prototype.preOrderTraverseNode = function (node, handler) &#123;    if (node !== null) &#123;      // 1.处理经过的节点      handler(node.key);      // 2.处理经过节点的 左子节点      this.preOrderTraverseNode(node.left, handler);      // 3.处理经过节点的 右子节点      this.preOrderTraverseNode(node.right, handler);    &#125;  &#125;  // 通过后序遍历方式遍历所有节点，最后遍历根节点  BinarySearchTree.prototype.postOrderTraversal = function (handler) &#123;    this.postOrderTraversalNode(this.root, handler);  &#125;  BinarySearchTree.prototype.postOrderTraversalNode = function (node, handler) &#123;    if (node !== null) &#123;      // 1.处理经过节点的 左子节点      this.postOrderTraversalNode(node.left, handler);      // 2.处理经过节点的 右子节点      this.postOrderTraversalNode(node.right, handler);      // 3.处理经过的节点      handler(node.key);    &#125;  &#125;  // 返回树中最小的值/键：一直往左节点查找  BinarySearchTree.prototype.min = function () &#123;    let node = this.root;    while (node.left !== null) &#123;      node = node.left;    &#125;    return node.key;  &#125;  // 返回树中最大的值/键  BinarySearchTree.prototype.max = function () &#123;    let node = this.root;    while (node.right !== null) &#123;      node = node.right;    &#125;    return node.key;  &#125;  // 搜索特定的节点（值）  BinarySearchTree.prototype.search = function (key) &#123;    // 一、循环方式    // 结束循环条件 node === null    // 1.获取根节点    let node = this.root;    // 2.遍历所有节点    while (node) &#123;      if (key &lt; node.key) &#123; // 向左查找        node = node.left;      &#125; else if (key &gt; node.key) &#123; // 向右查找        node = node.right;      &#125; else &#123;        return true;      &#125;    &#125;    return false;    // 二、递归方式    // return this.searchNode(this.root, key)  &#125;  // 退出递归的条件：  // 1.当前节点为null, node === null;   // 2.找到了key，node.key === key;  BinarySearchTree.prototype.searchNode = function (node, key) &#123;    if (node === null) &#123;      return false;    &#125;    if (key &lt; node.key) &#123; // 向左查找      return this.searchNode(node.left, key);    &#125; else if (key &gt; node.key) &#123; // 向右查找      return this.searchNode(node.right, key);    &#125; else &#123;      return true;    &#125;  &#125;  /**     * @description 从树中移除某个节点     *      * 1.找到要删除的节点，如果没有找到，不进行删除操作     * 2.如果找到了，则分为如下 三种情况：     *      * 一、没有子节点：叶节点     * 1.检测 当前节点的 left &amp; right === null     * 2.都为null之后，检测是否为 根节点，如果是，则清空二叉树     * 3.如果不是根节点，将父节点的 left 或者 right 设置为null 即可     *      * 二、只有一个子节点     *      * 三、有两个子节点     *      */  BinarySearchTree.prototype.remove = function (key) &#123;    // 1.寻找要删除的节点    // 1.1 保存当前节点，要删除的节点的父节点    let currentNode = this.root;    let parentNode = null;    let isLeftChild = true;    // 1.2 遍历查找    while (currentNode.key !== key) &#123;      parentNode = currentNode;      if (key &lt; currentNode.key) &#123; // 向左查找        isLeftChild = true;        currentNode = currentNode.left;      &#125; else &#123; // 向右查找        isLeftChild = false;        currentNode = currentNode.right;      &#125;      // 直到遍历到了最后的节点，依然没有找到 == key 的节点      if (currentNode === null) return false;    &#125;    // 2.根据对应的情况删除节点    // 2.1 删除的节点是叶子节点    if (currentNode.left === null &amp;&amp; currentNode.right === null) &#123;      if (currentNode === this.root) &#123;        this.root = null;      &#125; else if (isLeftChild) &#123;        parentNode.left = null;      &#125; else &#123;        parentNode.right = null;      &#125;    &#125;    // 2.2 删除的节点有一个子节点    /**       *             11       *        7             15       *    5      9      13      20       *  3  6   8  10  12  14  18  25       */    // 2.2.1 当前节点在左节点，currentNode.left === parentNode.left;(例如：5)    // left:  parentNode.left = currentNode.left;（有3无6的情况）    // right: parentNode.left = currentNode.right;（有6无3的情况）    else if (currentNode.right === null) &#123;      // 当前节点为根节点，父节点为null      if (currentNode === this.root) &#123;        this.root = currentNode.left;      &#125; else if (isLeftChild) &#123;        parentNode.left = currentNode.left; // （有3无6的情况）      &#125; else &#123;        parentNode.right = currentNode.left; // （有8无10的情况）      &#125;    &#125;    // 2.2.2 当前节点在右节点，currentNode.right === parentNode.right;(例如：9)    // left:  parentNode.right = currentNode.left;（有8无10的情况）    // right: parentNode.right = currentNode.right;（有10无8的情况）    else if (currentNode.left === null) &#123;      // 当前节点为根节点，父节点为null      if (currentNode === this.root) &#123;        this.root = currentNode.right;      &#125; else if (isLeftChild) &#123;        parentNode.left = currentNode.right; // （有6无3的情况）      &#125; else &#123;        parentNode.right = currentNode.right; // （有10无8的情况）      &#125;    &#125;    /**       *             11       *        7             15       *    5      9      13      20       *  3      8  10  12  14  18  25       *                          19       *        * 19连着18连着20       */    // 2.3 删除的节点有两个子节点    // 情况一：删除节点9，任选8或者10放到原本9的位置    // 情况二：删除节点7    // - 方案一：左边：将5移到7的位置，3移到原本5的位置；    // - 方案二：右边：将8放到7的位置    // 情况三：删除节点15    // - 方案一：左边：将14放到15的位置    // - 方案二：右边：将18放到15的位置，19移到原本18的位置；    // 规律 &amp; 思路    // + 如果我们要删除的节点有两个子节点甚至子节点还有子节点,    // 这种情况下我们需要从下面的子节点中找到个节点,来替换当前的节点    // + 但是找到的这个节点有什么特征呢?应该是 current节点下面所有节点中最接近 current节点的    // - 要么比 current节点小一点点要么比 current节点大一点点    // - 总之你最接近 current,你就可以用来替换 current的位置.    // + 这个节点怎么找呢？    // - 比 current小一点点的节点一定是 current左子树的最大值    // - 比 current大一点点的节点一定是 current右子树的最小值    // + 前驱&amp;后继    // - 在二叉搜索树中,这两个特别的节点有两个特别的名字    // - 比 current小一点点的节点称为 current节点的前区    // - 比 current大一点点的节点称为 current节点的后继    // + 也就是为了能够删除有两个子节点的α urrent,要么找到它的前驱,要么找到它的后继.    // + 所以接下来,我们先找到这样的节点(前驱或者后继都可以我这里以找后继为例)    else &#123;      // 1.获取后继节点      let successor = this.getSuccssor(currentNode)      // 2.判断是否为根节点      if (currentNode === this.root) &#123;        this.root = successor;      &#125;    &#125;  &#125;  // 找到后继  BinarySearchTree.prototype.getSuccssor = function (delNode) &#123;    // 1.定义变量，，保存找到的后继    let successor = delNode;    let current = delNode.right;    // 2.循环查找    while (current !== null) &#123;      successor = current;      current = current.left;    &#125;    return successor;  &#125;&#125;\n\n\n\n测试用例：\n/**   * 删除用的   *             11   *        7             15   *    5      9      13      20   *     6   8  10  12  14  18  25   */let bst = new BinarySearchTree();bst.insert(11);bst.insert(7);bst.insert(15);bst.insert(5);bst.insert(3);bst.insert(9);bst.insert(8);bst.insert(10);bst.insert(13);bst.insert(12);bst.insert(14);bst.insert(20);bst.insert(18);bst.insert(25);bst.insert(6);bst.insert(19);// 测试先序遍历let resultString1 = &quot;&quot;;bst.preOrderTraversal(function (key) &#123;  resultString1 += key + &#x27; &#x27;&#125;);console.log(&#x27;先序遍历：&#x27;, resultString1)// 测试中序遍历let resultString2 = &quot;&quot;;bst.midOrderTraversal(function (key) &#123;  resultString2 += key + &#x27; &#x27;&#125;);console.log(&#x27;先序遍历：&#x27;, resultString2)// 测试后续序遍历let resultString3 = &quot;&quot;;bst.postOrderTraversal(function (key) &#123;  resultString3 += key + &#x27; &#x27;&#125;);console.log(&#x27;后序遍历：&#x27;, resultString3)console.log(&#x27;最小值：&#x27;, bst.min())console.log(&#x27;最大值：&#x27;, bst.max())console.log(&#x27;是否存在 key = 3 的节点&#x27;, bst.search(3));console.log(&#x27;是否存在 key = 9 的节点&#x27;, bst.search(9));console.log(&#x27;是否存在 key = 13 的节点&#x27;, bst.search(13));console.log(&#x27;是否存在 key = 18 的节点&#x27;, bst.search(18));console.log(&#x27;是否存在 key = 21 的节点&#x27;, bst.search(21));console.log(&#x27;删除6&#x27;, bst.remove(6), bst)// console.log(&#x27;删除3&#x27;, bst.remove(3), bst)// console.log(&#x27;删除5&#x27;, bst.remove(5), bst)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"红黑树","url":"/2020/02/06/%E7%BA%A2%E9%BB%91%E6%A0%91/","content":" \n\n二叉树 对比+ 二叉搜索树+ 优点：\n\n可以快速地找到给定关键字的数据项并且可以快速地插入和删除数据项.\n\n+ 缺点\n\n如果插入的数据是&#x3D;&#x3D;有序&#x3D;&#x3D;的数据，树的深度会很大，反而影响效率；\n\n+ 非平衡树\n比较好的二叉搜索树数据应该是左右分布均匀的；\n\n但是插入连续数据后，&#x3D;&#x3D;分布的不均匀&#x3D;&#x3D;，我称这种树为&#x3D;&#x3D;非平衡树&#x3D;&#x3D;；\n\n对于一棵平衡二叉树来说，插入&#x2F;查找等操作的效率是O(logN)；\n\n对于一棵非平衡二叉树，相当于编写了—个链表，查找效率变成了O(N)。\n\n\n+ 为了能以较快的时间O(logN)来操作一棵树，我们需要保证树总是平衡的:\n\n至少大部分是平衡的那么时间复杂度也是接近O(logN)的；\n\n也就是说树中每个&#x3D;&#x3D;节点左边的子孙节点&#x3D;&#x3D;的个数应该尽可能的&#x3D;&#x3D;等于&#x3D;&#x3D;，&#x3D;&#x3D;右边的子孙节点&#x3D;&#x3D;的个数；\n\n常见的平衡树有哪些呢?\n\n\n+ AVL树AVL树是最早的—种平衡树.它有些办法保持树的平衡(每个节点多存储了一个额外的数据)；\n因为AVL树是平衡的所以时间复杂度也是O(logN)；\n但是，每次&#x3D;&#x3D;插入&#x2F;删除&#x3D;&#x3D;操作相对于红黑树&#x3D;&#x3D;效率都不高&#x3D;&#x3D;，所以整体效率&#x3D;&#x3D;不如红黑树&#x3D;&#x3D;。\n+ 红黑树红黑树也通过一些特性来保持树的平衡；\n因为是平衡树，所以时间复杂度也是在O(logN)；\n另外插入&#x2F;删除等操作，红黑树的性能要优于AVL树，所以现在平衡树的应用基本都是红黑树。\n二、特性 + 红黑树，除了符合二叉搜索树的基本规则外，还添加了一下特性\n\n\n\n节点是红色或黑色。\n&#x3D;&#x3D;根节点是黑色&#x3D;&#x3D;。\n每个&#x3D;&#x3D;叶子节点&#x3D;&#x3D;都是&#x3D;&#x3D;黑色&#x3D;&#x3D;的空节点(NIL节点)\n每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上&#x3D;&#x3D;不能有两个连续&#x3D;&#x3D;的&#x3D;&#x3D;红色&#x3D;&#x3D;节点)\n从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n\n+ 红黑树的关键特性:\n\n从根到叶子的&#x3D;&#x3D;最长可能路径&#x3D;&#x3D;，不会超过&#x3D;&#x3D;最短可能路径&#x3D;&#x3D;的&#x3D;&#x3D;两倍长&#x3D;&#x3D;;\n结果就是这个树基本是平衡的；\n虽然没有做到绝对的平衡，但是可以保证在最坏的情况下，依然是高效的；\n\n+ 为什么可以做到 最长路径不超过最短路径的两倍 呢?\n\n性质4决定了路径&#x3D;&#x3D;不能&#x3D;&#x3D;有两个&#x3D;&#x3D;相连&#x3D;&#x3D;的&#x3D;&#x3D;红色节点&#x3D;&#x3D;；\n最短的可能路径都是黑色节点；\n最长的可能路径是红色和黑色交替；\n性质5&#x3D;&#x3D;所有路径&#x3D;&#x3D;都有&#x3D;&#x3D;相同数目&#x3D;&#x3D;的&#x3D;&#x3D;黑色&#x3D;&#x3D;节点；\n这就表明了没有路径能多余任何其他路径的两倍长。\n\n+ 插入一个新节点时，有可能树不再平衡，可以通过三种方式的变换，让树保持平衡\n\n换色-左旋转一右旋转\n\n1.变色\n为了重新符合红黑树的规则，尝试把&#x3D;&#x3D;红色&#x3D;&#x3D;节点&#x3D;&#x3D;变&#x3D;&#x3D;为&#x3D;&#x3D;黑色&#x3D;&#x3D;，或者把&#x3D;&#x3D;黑色&#x3D;&#x3D;节点&#x3D;&#x3D;变&#x3D;&#x3D;为&#x3D;&#x3D;红色&#x3D;&#x3D;\n\n+ 插入的 &#x3D;&#x3D;新的节点&#x3D;&#x3D; 通常都是 &#x3D;&#x3D;红色&#x3D;&#x3D;节点.\n\n因为在插入节点为红色的时候，有可能插入一次是不违反红黑树任何规则的\n而 插入黑色节点，必然会导致有一条路径上多了黑色节点这是很难调整的\n红色节点 可能&#x3D;&#x3D;导致&#x3D;&#x3D;出现&#x3D;&#x3D;红红相连&#x3D;&#x3D; 的情况，但是这种情况可以通过 &#x3D;&#x3D;颜色调换&#x3D;&#x3D;和&#x3D;&#x3D;旋转&#x3D;&#x3D; 来调整\n\n2.旋转旋转后，依然符合二叉搜索树的特性\n\n左旋转：\n\n&#x3D;&#x3D;逆时针&#x3D;&#x3D;旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子\n\n\n\n图中，身为右孩子的Y取代了X的位置，而X变成了Y的左孩子。此为左旋转\n\n不影响子节点：b节点，旋转前后，都满足 x &lt; b &lt; y\n\n\n\n右旋转：\n\n&#x3D;&#x3D;顺时针&#x3D;&#x3D;旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子\n\n图中，身为左孩子的Y取代了X的位置，而X变成了Y的右孩子。此为右旋转\n不影响子节点：c节点，旋转前后，都满足 y &lt; c &lt; x\n\n\n\n\n接下来,讨论一下插入的情况:设要插入的节点为N,其父节点为P其祖父节点为G,其父亲的兄弟节点为U(即P和U是同一个节点的子节点)\n\n情况一：(简单变色即可)新节点N位于树的根上,没有父节点这种情况下,我们直接将红色变换成黑色即可,这样满足性质2\n\n情况二：(不用变)新节点的父节点P是黑色性质4没有失效(新节点是红色的),性质5也没有任何问题尽管新节点N有两个黑色的叶子节点nil但是新节点N是红色的,所以通过它的路径中黑色节点的个数依然相同,满足性质5\n\n情况三：P为红色，U也是红色，G是黑色（父红叔红祖黑 &#x3D;》 父黑叔黑 祖红）\n\n操作方案将P和U变换为黑色,并且将G变换为红色现在新节点N有了一个黑色的父节点P，所以每条路径上黑色节点的数目没有改变；而从更高的路径上必然都会经过G节点所以那些路径的黑色节点数目也是不变的.符合性质5.\n\n可能出现的问题但是，N的祖父节点G的父节点也可能是红色,这就违反了性质3,可以递归的调整颜色.但是如果递归调整颜色到了根节点,就需要进行旋转了,待会儿我们的例子中会遇到这个问题.\n\n情况四：N的叔叔∪是黑节点,且N是左孩子；（父红，叔黑，祖父黑，N左）\n\n操作方案对祖父节点G进行依次右旋转在旋转查收的树中,以前的父节点P现在是新节点以前祖父节点G的父节点交换以前的父节点P和祖父节点G的颜色(P为黑色,G变成红色——G原来一定是黑色,为什么?)B节点向右平移,成为G节点的左子节点\n\n情况五N的叔叔U是黑色节点,且N是有孩子.（父红叔黑祖父黑，N右）\n\n旋转以P为根，左旋转将P作为新插入的红色接地那考虑即可\n\n操作方案对P节点进行依次左旋转,形成情况四的结果.对祖父节点G进行一次右旋转,并且改变颜色即可\n\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"链表","url":"/2019/10/08/%E9%93%BE%E8%A1%A8/","content":" \n\n一、概念![image-20230402115800488](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230402115800488.png)\n数组\n要存储多个元素，数组可能是最常用的数据结构。\n几乎每一种编程语言都有默认实现数组结构。\n\n数组的缺点：\n\n数组的创建通常需要申请一段连续的内存空间（整块的内存），并且大小是固定的（大多数编程语言数组都是固定的）；\n所以当 当前数组 不能满足容量需求时，需要扩容（一般情况下是申请—个更大的数组，比如2倍。然后将原数组中的元素复制过去）。\n而且在数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移。\n尽管我们已经学过的 JavaScript 的Array类方法可以帮我们做这些事，但背后的原理依然是这样。\n\n链表结构\n不同于数组，链表中的元素在内存中不必是连续的空间。\n链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（有些语言称为指针或者连接）组成。\n\n优点：\n\n内存空间不是必须连续的。可以充分利用计算机的内存，实现灵活的内存动态管理。\n链表不必在创建时就确定大小，并且大小可以无限的延伸下去。\n链表在插入和删除数据时，时间复杂度可以达到O(1)。相对数组效率高很多。\n\n结构模型\n​    head -&gt; { data, next } -&gt; { data, next } -&gt; { data, next } -&gt; null;\n\nhead 指向头部节点；\nnext 指向下一个节点；\ndata 当前节点数据\n二、属性和方法链表的属性：\n\nhead: 头部节点\nnode: 节点\ndata: 节点数据\nnext：指向下一个节点的指针\n\n\nlength: 链表长度\n\n链表的方法（6个）：\n\nappend(data)：向链表尾部添加一个新的项\ninsert(position, data)：向链表的特定位置 插入一个新的项\nget(position)：获取对应位置的元素\nindexOf(data)：返回元素在链表中的索引。如果链表中没有该元素，则返回-1\nupdate(position, data)：修改某个位置的元素\nremoveAt(position)：从链表的特定位置删除一项\nremove(data)：从列表中删除一项\nisEmpty()：如果链表中不包含任何元素，返回true；否则返回false\nsize()：返回链表中包含的元素个数\ntoString()：将链表中的内容，转换成字符串形式\n\n具体实现：\n/***************  链表封装 ***********/function LinkedList() &#123;  // 内部类：节点类  function Node(data) &#123;    this.data = data;    this.next = null;  &#125;  // 属性  this.head = null;  this.length = 0;  // 向链表尾部添加一个新的项  LinkedList.prototype.append = function (data) &#123;    const node = new Node(data);    // 1.是否是第一个节点，是，则将head指向新节点    if (this.length === 0) &#123;      this.head = node;    &#125; else &#123; // 2.找到最后一个节点，将next等于当前的新节点      let currentNode = this.head;      // 找到最后一个节点      while (currentNode.next) &#123;        currentNode = currentNode.next;      &#125;      // 最后一个节点的 next 指向新节点      currentNode.next = node;    &#125;    this.length++;  &#125;  // 向链表的特定位置 插入一个新的项  LinkedList.prototype.insert = function (position, data) &#123;    // 1.对 position 进行越界判断    if (position &lt; 0 || position &gt; this.length) &#123;      return false    &#125;    // 2.创建节点数据    const node = new Node(data);    // 3.判断是否插入的是第一个位置    if (position === 0) &#123;      node.next = this.head;      this.head = node;    &#125; else &#123;      // 4.插入的是中间位置      // 3.1 当前节点      let currentNode = this.head;      // 3.2 前一个节点      let prevNode = null;      // 3.2 当前节点索引      let index = 0;      while (index++ &lt; position) &#123;        prevNode = currentNode;        currentNode = currentNode.next;      &#125;      node.next = currentNode;      prevNode.next = node;    &#125;    this.length++;    return true;  &#125;  // 获取对应位置的元素  LinkedList.prototype.get = function (position) &#123;    // 1.对 position 进行越界判断    if (position &lt; 0 || position &gt;= this.length) &#123;      return null    &#125;    // 2.获取对应的data    let currentNode = this.head;    let index = 0;    while (index++ &lt; position) &#123;      currentNode = currentNode.next;    &#125;    return currentNode.data;  &#125;  // 返回元素在链表中的索引。如果链表中没有该元素，则返回-1  LinkedList.prototype.indexOf = function (data) &#123;    let currentNode = this.head;    let index = 0;    while (currentNode) &#123;      if (data === currentNode.data) &#123;        return index;      &#125;      currentNode = currentNode.next;      index++;    &#125;    return -1;  &#125;  // 修改某个位置的元素  LinkedList.prototype.update = function (position, data) &#123;    // 1.对 position 进行越界判断    if (position &lt; 0 || position &gt;= this.length) &#123;      return false    &#125;    // 2.获取对应的data    let currentNode = this.head;    let index = 0;    while (index++ &lt; position) &#123;      currentNode = currentNode.next;    &#125;    // 修改数据    currentNode.data = data;    return true;  &#125;  // 从链表的特定位置删除一项  LinkedList.prototype.removeAt = function (position) &#123;    // 1.对 position 进行越界判断    if (position &lt; 0 || position &gt;= this.length) &#123;      return false    &#125;    let currentNode = this.head;    // 2.判断是否删除的是第一个元素    if(position === 0) &#123;      this.head = this.head.next;    &#125; else &#123;      let index = 0;      let prevNode = null;      while(index++ &lt; position) &#123;        prevNode = currentNode;        currentNode = currentNode.next;      &#125;      // 前一个节点的next指向currentNode的next即可      prevNode.next = currentNode.next;    &#125;    this.length--;    return currentNode.data;  &#125;  // 从链表中删除一项  LinkedList.prototype.remove = function (data) &#123;    // 1.根据元素获取 其位置    const postion = this.indexOf(data);    // 2.根绝位置信息，删除节点    return this.removeAt(postion);  &#125;  // 如果链表中不包含任何元素，返回true；否则返回false  LinkedList.prototype.isEmpty = function () &#123;    return this.length === 0;  &#125;  // 返回链表中包含的元素个数  LinkedList.prototype.size = function () &#123;    return this.length  &#125;  // 由于链表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值  LinkedList.prototype.toString = function () &#123;    let current = this.head;    let listString = &#x27;&#x27;;    while (current) &#123;      listString += current.data + &#x27; &#x27;;      current = current.next;    &#125;    return listString;  &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"哈希表","url":"/2019/11/26/%E5%93%88%E5%B8%8C%E8%A1%A8/","content":" \n\n一、哈希表 vs 数组哈希表：基于数组进行实现的，相对于数组，有很多优势。\n\n提供 非常&#x3D;&#x3D;快速的插入-删除-查找&#x3D;&#x3D;操作。\n无论多少数据，插入和删除值需要接近常量的时间：即O(1)的时间级。实际上只需要几个机器指令即可完成。\n哈希表的 &#x3D;&#x3D;速度 比 树&#x3D;&#x3D; 还要快，基本可以瞬间查找到想要的元素。\n哈希表相对于 树 来说&#x3D;&#x3D;编码要容易&#x3D;&#x3D;的很多。\n哈希表的结构就是&#x3D;&#x3D;数组，对下标值的一种变换&#x3D;&#x3D;，这种变换称之为&#x3D;&#x3D;哈希函数&#x3D;&#x3D;，通过哈希函数可以获得HashCode;\n\n相对于数组的不足：\n数据没有顺序，不能以一种固定的方式（比如从小大）来遍历其中的元素\n通常情况下，哈希表中的key是不允许充重复的，不能放置相同的key，用于保存不同的元素\n\n数组查找效率：\n如果是基于索引进行查找，效率非常高\n如果是基于内容查找(name&#x3D;’why’)，效率比较低\n进行删除操作，效率也不高\n\n二、哈希表自定义编码：\n\n规则：用1表示a，用26表示z，用0表示空格\n\n字母转数组：\n  2.1 数组相加。\n\n\n\n方法：cats &#x3D; 3 + 1 + 20 + 19 &#x3D; 43;\n问题：很多单词的数字之和都相同，会造成数据覆盖。\n结果：数组下标太少\n\n​\t2.2 &#x3D;&#x3D;幂的连乘&#x3D;&#x3D;。\n\n方法：7654 &#x3D; 710^3 + 610^2 + 5*10 + 4;（基本保证唯一性）\n\n问题： \n\n单词太长，得到的结果非常大，数组能否表示这么大的下标值吗？\n就算能够创建这么大的数组，实时上有很多是无效的单词\n创建这么大的数组时没有意义的、\n\n\n结果：数组下标太多\n\n改进：压缩范围，将巨大的整数范围压缩到可以接受的数组范围中。\n\n压缩实现：取余操作。\n​\n\n\n哈希化：将大数字转化成数组范围内下标的过程。\n哈希函数：通常会将单词转成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数被称为哈希函数。\n哈希表：最终将数据插入到的这个数组，对整个结构的封装，称之为一个哈希表\n冲突下标值仍然可能相同，冲突不可避免，只能解决冲突。\n解决冲突：\n\n链地址法（拉链法）。\n开放地址法。\n\n链地址法\n\n\n每个数组单元中存储的不再是单个数据，而是一个&#x3D;&#x3D;链条&#x3D;&#x3D;。\n链条的数据结构通常是 数组或&#x3D;&#x3D;链表&#x3D;&#x3D;。\n比如是链表，也就是每个数组单元中存储着一个链表。一旦发现重复，将重复的元素插入到链表的首端或者未端即可。\n当查询时，先根据哈希化后的下标值找到对应的位置，再取出链表，依次查询找寻找的数据。\n\n开放地址法\n\n寻找空白的单元格来添加重复的数据\n探索这个位置的方式：\n\n线性探测：\n二次探测\n再哈希法\n\n1.线性探测（82和32）\n\n插入：\n\n​\t经过哈希化得到index &#x3D; 2，在插入的时候，发现该位置已经有了82；\n​\t从 index+1 的位置开始一点点查找合适位置（空白位置）来放置32\n\n查找：\n\n​\t经过哈希化得到index &#x3D; 2，比如2的位置结果和查询的数据是否相同，相同则直接返回；\n​\t不相同，则从 index+1 位置开始查找和32一样的\n​\t如果32的位置 我们之前 没有插入，则查询到空位置就停止，因为查询到这里有空位置，32之前不可能跳过空位置去其他的位置。\n\n删除：\n\n​\t删除一个数据项时，不可以将这个下标的内容设置为null；\n​\t如果设置为null可能会影响之后的查询操作，通常删除一个位置的数据项时，可以进行特殊处理（比如设置为-1）；\n​\t当看到-1位置的数据项时，就知道要继续查询，但是插入时这个位置可以放置数据。\n\n问题：聚集\n\n​\t比如在没有任何数据的时候，插入的是22-23-24-25-26，那么意味着下标值2-3-4-5的位置都有元素；\n​\t这种一连串填充单元就叫做聚集；\n​\t聚集会影响哈希表的性能，无论是插入&#x2F;查询&#x2F;删除 都有影响\n​\t比如插入一个32，会发现连续的单元都不允许放置数据，并且在这个过程中需要探测多次；\n​\t二次探测可以解决一部分这个问题。\n2.二次探测\n\n二次探测主要优化的是&#x3D;&#x3D;探测时的步长&#x3D;&#x3D;；\n&#x3D;&#x3D;线性探测&#x3D;&#x3D;，可以看成是&#x3D;&#x3D;步长为1&#x3D;&#x3D;的探测，比如从下标值x开始,那么线性测试就是x+1，X+2，X+3依次探测；\n二次探测，对步长做了优化，比如从下标值x开始，x+1^2，x+2^2，x+3^2；\n这样就可以&#x3D;&#x3D;一次性探测比较长的距离&#x3D;&#x3D;，比避免那些聚集带来的影响；\n\n问题：\n​\t二次探测依然存在问题，比如我们连续插入的是32-112-82-2-192,那么它们依次累加的时候步长的相同的；\n​\t也就是这种情况下会造成&#x3D;&#x3D;步长不一的一种聚集&#x3D;&#x3D;，还是会影响效率、(当然这种可能性相对于连续的数字会小一些)\n3.再哈希法\n\n二次探测的算法产生的探测序列步长是固定的：1，4，9，16，依次类推；\n现在需要一种方法：产生一种 &#x3D;&#x3D;依赖关键字的探测序列&#x3D;&#x3D;，而不是每个关键字都一样；\n那么，&#x3D;&#x3D;不同的关键字&#x3D;&#x3D; 即使映射到 &#x3D;&#x3D;相同的数组下标&#x3D;&#x3D;，也可以使用 &#x3D;&#x3D;不同的探测序列&#x3D;&#x3D;；\n再哈希法的做法就是：把关键字用另外一个哈希函数，再做一次哈希化，用这次哈希化的结果作为步长；\n对于&#x3D;&#x3D;指定的关键字，步长&#x3D;&#x3D;在整个探测中是&#x3D;&#x3D;不变&#x3D;&#x3D;的，不过&#x3D;&#x3D;不同的关键字&#x3D;&#x3D;使用&#x3D;&#x3D;不同的步长&#x3D;&#x3D;\n\n第二次哈希化需要具备如下特点：\n\n和&#x3D;&#x3D;第一个哈希函数不同&#x3D;&#x3D; (不要再使用上一次的哈希函数了，不然结果还是原来的位置)；\n&#x3D;&#x3D;不能输岀为0&#x3D;&#x3D; (否则，将没有步长每次探测都是原地踏步，算法就进入了死循环)\n\n其实，我们不用费脑细胞来设计了，计算机专家已经设计出一种工作很好的哈希函数:\n\nstepsize &#x3D; constant - (key % constant);\n其中 constant是质数，且小于数组的容量;\n例如: stepsize &#x3D; 5 - (key % 5)，满足需求，并且结果不可能为0\n\n哈希表中执行插入和搜索操作效率是非常高的：\n\n如果没有产生冲突，那么效率就会更高；\n如果发生冲突，存取时间就依赖后来的探测长度；\n平均探测长度以及平均存取时间，取决于墳装因子，随着填装因子变大，探测长度也越来越长；\n随着填裝因子变大，效率下降的情况，在不同开放地址法方案中比链地址法更严重；\n所以我们来对比-下他们的效率，再决定我们选取的方案\n\n在分析效率之前，我们先了解一个概念：裝填因子\n\n装填因子表示当前哈希表中 已经包含的数据项 和 整个哈希表长度的 比值；\n装填因子 &#x3D; 总数据项 &#x2F; 哈希表长度；\n开放地址法 的 装填因子 最大 是多少呢?1，因为它必须寻找到空白的单元才能将元素放入\n链地址法 的 装填因子 呢?可以大于1，因为拉链法可以无限的延伸下去，只要你愿意(当然后面效率就变低了)。\n\n三、哈希函数好的哈希函数应该尽可能让计算的过程变得简单提高计算的效率。\n\n哈希表的主要&#x3D;&#x3D;优点是它的速度&#x3D;&#x3D;，所以在速度上不能满足，那么就达不到设计的目的了；\n提高速度的一个办法就是让哈希函数中&#x3D;&#x3D;尽量少的有乘法和除法&#x3D;&#x3D;。因为它们的&#x3D;&#x3D;性能是比较低&#x3D;&#x3D;的；\n\n+ 设计好的哈希函数应该具备哪些优点呢?\n\n快速的计算\n\n\n哈希表的优势就在于效率，所以快速获取到对应的 hash Code非常重要；\n我们需要通过快速的计算来获取到元素对应的 hash Code；\n\n\n均匀的分布\n\n\n哈希表中，无论是链地址法还是开放地址法，当多个元素映射到同一个位置的时候都会影响效率；\n所以优秀的哈希函数应该尽可能将元素映射到不同的位置，让元素在哈希表中均匀的分布；\n\n​\t在设计哈希表时，我们已经有办法处理 映射到相同下标值 的情况：链地址法或者开放地址法.\n​\t但是无论哪种方案，为了提供效率，最好的情况还是让数据在哈希表中均匀分布.\n​\t因此，我们需要在使用常量的地方，尽量使用质数.\n哪些地方我们会使用到常量呢?\n+ 质数的使用\n\n哈希表的长度.\nN次幂的底数(我们之前使用的是27)\n\n/***************  哈希函数 ***********/// 1.将字符串转成比较大的数字：hashCode// 2.将大的数字hashCode压缩到数组范围（大小）之内function hashFunc(str, size) &#123;  // 1.定义hashCode边浪  let hashCode = 0;  // 2.霍纳算法，来计算hashCode的值  // cats -&gt; Unicode编码  for (let i = 0; i &lt; str.length; i++) &#123;    hashCode = 37 * hashCode + str.charCodeAt(i);  &#125;  // 3.取余操作  return hashCode % size;&#125;console.log(hashFunc(&#x27;abc&#x27;, 7)) // 4console.log(hashFunc(&#x27;cba&#x27;, 7)) // 3console.log(hashFunc(&#x27;nba&#x27;, 7)) // 5console.log(hashFunc(&#x27;mba&#x27;, 7)) // 1\n\n\n\n四、哈希表的实现结构：\n[  [], [[&#x27;name&#x27;,&#x27;Alice&#x27;]], [[&#x27;age&#x27;, 20]]]\n\n\n\n代码实现：\n/***************  哈希表 ***********/function HashTable() &#123;  // 数组中存放相关的元素  this.storage = [];  // 当前哈希表已经存放的元素个数  this.count = 0;  // 哈希表 数组当前的总长度  this.limit = 7;  // 加载因子/装载因子 loadFactor &gt; 0.75 || loadFactor &lt; 0.25 ; loadFactor = count / limit  // 哈希函数  HashTable.prototype.hashFunc = function (str, size) &#123;    // 1.定义hashCode边浪    let hashCode = 0;    // 2.霍纳算法，来计算hashCode的值    for (let i = 0; i &lt; str.length; i++) &#123;      hashCode = 37 * hashCode + str.charCodeAt(i);    &#125;    // 3.取余操作    return hashCode % size;  &#125;  // 插入和修改操作  HashTable.prototype.put = function (key, value) &#123;    // 1.根据key获取索引值（目的：将数据插入到对应的位置）    let index = this.hashFunc(key, this.limit);    // 2.根据索引值取出bucket    let bucket = this.storage[index];    // 3.判断该bucket是否为null    if (!bucket) &#123;      bucket = [];      this.storage[index] = bucket;    &#125;    // 4.判断是否是修改数据    for (let i = 0; i &lt; bucket.length; i++) &#123;      let tuple = bucket[i];      if(tuple[0] === key) &#123;        tuple[1] = value;        return;      &#125;    &#125;    // 5.进行添加操作    bucket.push([key, value])    this.count += 1;  &#125;  HashTable.prototype.get = function (key) &#123;    // 1.根据key获取对应的index    let index = this.hashFunc(key, this.limit);    // 2.根据index获取对应的bucket    let bucket = this.storage[index];    // 3.判断bucket是否为null，是，直接返回null    if(bucket === null) return null;    // 4.线性查找bucket中每一个key是否等于传入的key    for (let i = 0; i &lt; bucket.length; i++) &#123;      const tuple = bucket[i];      if (tuple[0] === key) &#123;        return tuple[1]      &#125;    &#125;    // 5.依然没有知道    return null;  &#125;  HashTable.prototype.remove = function (key) &#123;    // 1.根据key获取对应的index    let index = this.hashFunc(key, this.limit);    // 2.根据index获取对应的bucket    let bucket = this.storage[index];    // 3.判断bucket是否为null，是，直接返回null    if(bucket === null) return null;    // 4.线性查找bucket中每一个key是否等于传入的key    for (let i = 0; i &lt; bucket.length; i++) &#123;      const tuple = bucket[i];      if (tuple[0] === key) &#123;        bucket.splice(i, 1);        this.count--;        return tuple[1];      &#125;    &#125;    // 5.依然没有找到    return null;  &#125;  // 判断哈希表是否为空  HashTable.prototype.isEmpty = function () &#123;    return this.count === 0;  &#125;  // 判断哈希表元素的个数  HashTable.prototype.size = function () &#123;    return this.count;  &#125;&#125;\n\n\n\n五、哈希表扩容+ 为什么需要扩容\n\n目前，我们是将所有的数据项放在长度为7的数组中的。\n因为我们使用的是链地址法， load Factor可以大于1，所以这个哈希表可以无限制的插入新数据。\n但是，随着数据量的增多，每—个 index对应的 bucket会越来越长，也就造成效率的降低。\n所以在合适的情况对数组进行扩容。比如扩容两倍。\n\n+ 如何进行扩容\n\n扩容可以简单的将容量增大两倍(不是质数吗?质数的问题后面再讨论)。\n但是这种情况下，所有的数据项一定要同时进行修改(重新调用哈希函数来获取到不同的位置)。\n比如 hash Code&#x3D;12的数据项在 length&#x3D;8的时候 index&#x3D;5。在长度为16的时候呢? index&#x3D;12。\n这是一个耗时的过程，但是如果数组需要扩容，那么这个过程是必要的。\n\n+ 什么情况下需要扩容\n\n比较常见的情况是 Lload Factor&gt;0.75的时候进行扩容。\n比如Java的哈希表就是在&#x3D;&#x3D;装填因子大于0.75&#x3D;&#x3D;的时候，对哈希表进行扩容。\n\n容量质数+ 我们前面提到过，容量最好是质数\n\n虽然在链地址法中将容量设置为质数，没有在开放地址法中重要。\n但是其实链地址法中质数作为容量也更利于数据的均匀分布。\n\n+ 质数的特点\n\n质数也称为素数\n质数表示大于1的自然数中，只能被1和自己整除的数。\n在 2到n-1 中间有可以被整除的数\n\n\n\n+ 判定质数\n\n对于每个数n，其实并不需要从2判断到n-1\n一个数若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n).\n比如16可以被分解。那么是2*8, 2小于sqrt(16)，也就是4，8大于4。而4*4都是等于sqrt(n)\n所以其实我们遍历到等于sqrt(n)即可\n\n // 判断是否是质数HashTable.prototype.isPrime = function (number) &#123;  if(number &lt;= 1) return false;  // 获取number的平方根  const sqrt = parseInt(Math.sqrt(number));  for (let i = 2; i &lt;= sqrt; i++) &#123;    if (number % i === 0) &#123;      return false;    &#125;  &#125;  return true;&#125;// 获取质数：实现恒为质数HashTable.prototype.getPrime = function(number) &#123;  while(!this.isPrime(number)) &#123;    number++;  &#125;  return number;&#125;\n\n// 哈希表扩容/缩容HashTable.prototype.resize = function (newLimit) &#123;  // 1.保存旧数组内容  let oldStorage = this.storage;  // 2.重置所有属性  this.storage = [];  this.count = 0;  this.limit = newLimit  // 3.遍历oldStorage 中所有的bucket  for (let i = 0; i &lt; oldStorage.length; i++) &#123;    // 3.1 取出对应的bucket    const bucket = oldStorage[i];    // 3.2 判断bucket是否为null    if(!bucket) &#123;      continue;    &#125;    // 3.3 bucekt中有数据，那么取出数据，重新插入    for (let i = 0; i &lt; bucket.length; i++) &#123;      const tuple = bucket[i];      this.put(tuple[0], tuple[0])    &#125;  &#125;&#125;// 插入时，扩容HashTable.prototype.put = function (key, value) &#123;  // 1.根据key获取索引值（目的：将数据插入到对应的位置）  let index = this.hashFunc(key, this.limit);  // 2.根据索引值取出bucket  let bucket = this.storage[index];  // 3.判断该bucket是否为null  if (!bucket) &#123;    bucket = [];    this.storage[index] = bucket;  &#125;  // 4.判断是否是修改数据  for (let i = 0; i &lt; bucket.length; i++) &#123;    let tuple = bucket[i];    if(tuple[0] === key) &#123;      tuple[1] = value;      return;    &#125;  &#125;  // 5.进行添加操作  bucket.push([key, value])  this.count += 1;  // 6.判断是否需要扩容  if(this.count &gt; this.limit * 0.75) &#123;    let newPrime = this.getPrime(this.limit * 2);    this.resize(newPrime);  &#125;&#125;// 删除时，减小容量HashTable.prototype.remove = function (key) &#123;  // 1.根据key获取对应的index  let index = this.hashFunc(key, this.limit);  // 2.根据index获取对应的bucket  let bucket = this.storage[index];  // 3.判断bucket是否为null，是，直接返回null  if(bucket === null) return null;  // 4.线性查找bucket中每一个key是否等于传入的key  for (let i = 0; i &lt; bucket.length; i++) &#123;    const tuple = bucket[i];    if (tuple[0] === key) &#123;      bucket.splice(i, 1);      this.count--;      // 缩小容量      if(this.limit &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25) &#123;        let newPrime = this.getPrime(Math.floor(this.limit / 2));        this.resize(newPrime)      &#125;      return tuple[1];    &#125;  &#125;  // 5.依然没有找到  return null;&#125;\n\n\n\n\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"遍历算法","url":"/2020/03/16/%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/","content":" \n\nconst tree = [   &#123;     value: 1,     children: [       &#123;         value: 2,         children: [&#123; value: 4 &#125;, &#123; value: 5 &#125;]       &#125;,       &#123;         value: 10,         children: [&#123; value: 11 &#125;, &#123; value: 12 &#125;]       &#125;,       &#123;         value: 3,         children: [           &#123;             value: 6,             children: [&#123; value: 7 &#125;, &#123; value: 8 &#125;]           &#125;,           &#123; value: 9 &#125;         ]       &#125;     ]   &#125;]\n\n\n\n深度优先遍历：深度优先搜索算法将会从第—个指定的顶点开始遍历图，沿着路径直到这条路径最后被访问了，接着原路回退并探索条路径。\n\n\nfunction dfs(arr, handler) &#123;  arr.forEach(item =&gt; &#123;    handler(item.value)    if (item.children) &#123;      dfs(item.children, handler);    &#125;  &#125;)&#125;\n\n\n\n广度优先遍历：广度优先算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深的访问顶点。\n\n\nfunction bfs(arr, handler) &#123;  while (arr.length) &#123;    let temp = arr.shift();    handler(temp.value);    if (temp.children) &#123;      temp.children.forEach(item =&gt; &#123;        arr.push(item);      &#125;)    &#125;  &#125;&#125;\n\n\n\n模拟二叉树结构：\nconst node = &#123;  root: &#123;    key: 11,    left: &#123;      key: 7,      left: &#123;        key: 5,        left: &#123;          key: 3,        &#125;,        right: &#123;          key: 6,        &#125;      &#125;,      right: &#123;        key: 9,        left: &#123;          key: 8,        &#125;,        right: &#123;          key: 10,        &#125;      &#125;    &#125;,    right: &#123;      key: 15,      left: &#123;        key: 13,        left: &#123;          key: 12,        &#125;,        right: &#123;          key: 14,        &#125;      &#125;,      right: &#123;        key: 20,        left: &#123;          key: 18,          right: &#123;            key: 19,          &#125;        &#125;,        right: &#123;          key: 25,        &#125;      &#125;    &#125;  &#125;&#125;\n\n前序遍历：function prevSearch(node) &#123;  let resultString1 = &#x27;&#x27;;  prevSearchNode(node.root, (v) =&gt; &#123;    resultString1 += v + &#x27; &#x27;  &#125;)  console.log(resultString1)&#125;function prevSearchNode(node, handler) &#123;  if (node) &#123;    handler(node.key);    prevSearchNode(node.left, handler);    prevSearchNode(node.right, handler);  &#125;&#125;\n\n\n\n","categories":["数据结构"],"tags":["算法"]},{"title":"树","url":"/2019/12/12/%E6%A0%91/","content":" \n\n普通表示法：\n![image-20230403172700286](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230403172700286.png)\n儿子-兄弟 表示法：(模拟二叉树)\n![image-20230403173159644](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230403173159644.png)\nB: {\n​\tthis.data &#x3D; data;\n​\tthis.leftChild &#x3D; E,\n​\tthis.sibling &#x3D; C（this.rightChild &#x3D; E）\n}\nD : {\n​\tthis.data &#x3D; data;\n​\tthis.leftChild &#x3D; H,\n​\tthis.sibling &#x3D; Null（this.rightChild &#x3D; Null）\n}\n树结构 vs 【数组】- 优点：\n\n数组的主要优点是根据&#x3D;&#x3D;下标值访问效率&#x3D;&#x3D;会很高。\n但是如果我们希望根据元素来查找对应的位置呢?\n比较好的方式是先对数组进行排序，再进行二分查找。\n\n- 缺点：\n\n需要&#x3D;&#x3D;先&#x3D;&#x3D;对数组进行&#x3D;&#x3D;排序&#x3D;&#x3D;，生成有序数组，才能提高査找效率。\n另外数组在插入和删除数据时，需要有大量的位移操作(插入到首位或者中间位置的时候，效率很低)。\n\n树结构 vs 【链表】- 优点：\n\n链表的&#x3D;&#x3D;插入和删除操作效率很高&#x3D;&#x3D;。\n\n- 缺点\n\n&#x3D;&#x3D;查找效率很低&#x3D;&#x3D;，需要从头开始依次访问链表中的每个数据项直到找到。\n而且即使插入和删除操作效率很高，但是如果要插入和删除中间位置的数据，还是需要重头先找到对应的数据。\n\n树结构 vs 【哈希表】- 优点：\n\n哈希表的&#x3D;&#x3D;插入&#x2F;查询&#x2F;删除效率&#x3D;&#x3D;都是非常&#x3D;&#x3D;高&#x3D;&#x3D;的。\n\n- 缺点：\n\n&#x3D;&#x3D;空间利用率不高&#x3D;&#x3D;，底层使用的是数组，并且某些单元是没有被利用的。\n哈希表中的元素是无序的，不能按照固定的顺序来遍历哈希表中的元素。\n不能快速的找出哈希表中的最大值或者最小值这些特殊的值。\n\n树结构我们不能说树结构比其他结构都要好，因为每种数据结构都有自己特定的应用场景。\n但是树确实也综合了上面的数据结构的优点(当然优点不足于盖过其他数据结构，比如效率一般情况下没有哈希表高)。\n并且也弥补了上面数据结构的缺点。\n树结构是非线性的，可以表示一对多的关系。\n树的术语n(n&gt;&#x3D;0)个节点构成的有限集合，当n &#x3D; 0时，称为空树；\n1.节点的度(Degree)：节点的子树个数。\n2.树的度：树的所有节点中最大的度数。\n3.叶节点(Leaf)：度为0的节点。(也称为叶子节点)\n4.父节点(Parent)：有子树的节点是其子树的根节点的父节点。\n5.子节点(Chid)：若A节点是B节点的父节点，则称B节点是A节点的子节点；子节点也称孩子节点。\n6.兄弟节点(Sibling)：具有同一父节点的各节点彼此是兄弟节点。\n7.路径和路径长度：从节点η1到nk的路径为一个节点序列n1,n2….,nk,ni是ni+1的父节点。路径所包含边的个数为路径的长度。\n8.节点的层次(Level)：规定根节点在1层，其它任一节点的层数是其父节点的层数加1。\n9.树的深度(Depth)：树中所有节点中的最大层次是这棵树的深度。\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"图论","url":"/2020/02/27/%E5%9B%BE%E8%AE%BA/","content":" \n\n\n\n一、什么是图？\n图结构是一种与&#x3D;&#x3D;树&#x3D;&#x3D;结构有些&#x3D;&#x3D;相似&#x3D;&#x3D;的数据结构.\n图论是数学的一个分支，在数学的概念上，&#x3D;&#x3D;树是图的一种&#x3D;&#x3D;\n它以图为研究对象，研究&#x3D;&#x3D;顶点&#x3D;&#x3D;和&#x3D;&#x3D;边&#x3D;&#x3D;组成的图形的数学理论和方法.\n主要研究的目的是事物之间的关系，顶点代表事物，边代表两个事物间的关系\n\n那么，什么是图呢?\n我们会发现，上面的结点(图中叫&#x3D;&#x3D;顶点 Vertex&#x3D;&#x3D;)之间的关系是不能使用树来表示使用几叉树都不可以模拟\n，这个时候,我们就可以使用图来模拟它们。\n图的特点\n&#x3D;&#x3D;一组顶点&#x3D;&#x3D;：通常用 &#x3D;&#x3D;V(Vertex)&#x3D;&#x3D;表示顶点的集合\n\n&#x3D;&#x3D;一组边&#x3D;&#x3D;∶ 通常用&#x3D;&#x3D;E(Edge)&#x3D;&#x3D;表示边的集合\n\n边是顶点和顶点之间的连线\n\n边可以是&#x3D;&#x3D;有向&#x3D;&#x3D;的也可以是&#x3D;&#x3D;无向&#x3D;&#x3D;的\n\n比如A–B,通常表示无向。A–&gt;B,通常表示有向\n\n\n\n\n二、图的概念顶点:\n表示图中的一个&#x3D;&#x3D;节点&#x3D;&#x3D;\n比如地铁站中某个站&#x2F; 多个村庄中的某个村庄&#x2F; 互联网中的某台主机&#x2F;人际关系中的人\n\n边:\n表示顶点和&#x3D;&#x3D;顶点之间&#x3D;&#x3D;的&#x3D;&#x3D;连线&#x3D;&#x3D;\n比如地铁站中两个站点之间的直接连线，就是—个边\n注意: 这里的边不要叫做路径，路径有其他的概念。\n\n相邻顶点\n由&#x3D;&#x3D;一条边连接在一起的顶点&#x3D;&#x3D;称为相邻顶点\n\n度\n一个顶点的度是&#x3D;&#x3D;相邻顶点的数量&#x3D;&#x3D;.\n\n图一\n\n\n路径\n路径是顶点V1,V2…,Vn的一个&#x3D;&#x3D;连续序列&#x3D;&#x3D;。比如上图中的 0-1-5-9是一条简单的路径\n简单路径:：简单路径要求&#x3D;&#x3D;不包含重复&#x3D;&#x3D;的顶点.\n回路：&#x3D;&#x3D;第一个顶点&#x3D;&#x3D;和&#x3D;&#x3D;最后一个顶点相同的路径&#x3D;&#x3D;称为回路。比如0-1-5-6-3-0\n\n无向图:\n所有的边都&#x3D;&#x3D;没有方向&#x3D;&#x3D;（边没有箭头）\n比如 0 - 1之间有边，那么说明这条边可以保证0 -&gt; 1，也可以保证 1 -&gt; 0\n\n图二\n\n\n有向图:\n图中的边是有方向的（边有箭头）\n比如 0 -&gt; 1，不能保证一定可以 1 -&gt; 0，要根据方向来定\n\n无权图:\n图一\n边没有携带权重(边无关长度和时间的长短)\n边是没有任何意义\n\n带权图：\n图二\n边有一定的权重。这里的权重可以是任意你希望表示的数据\n比如距离或者花费的 时间 或者 票价.\n\n三、图的表示顶点的表示\n使用&#x3D;&#x3D;数组&#x3D;&#x3D;来储存所有&#x3D;&#x3D;顶点&#x3D;&#x3D;\n\n边的表示1.邻接矩阵（非重点）\n\n\n每个节点和一个整数相关联，该整数作为数组的下标值\n用一个二维数组来表示顶点之间的连接.\n在二维数组中，0表示没有连线，1表示有连线\n通过二维数组,我们可以很快的找到一个顶点和哪些顶点有连线\n另外,A-A,B-B(也就是顶点到自己的连线)通常使用O表示\n\n2.邻接表（&#x3D;&#x3D;重点&#x3D;&#x3D;）\n\n\n邻接表由图中每个顶点以及和&#x3D;&#x3D;顶点相邻的顶点列表&#x3D;&#x3D;组成\n这个列表有很多中方式来存储，&#x3D;&#x3D;数组&#x2F;链表&#x2F;字典(哈希表)&#x3D;&#x3D;都可以\n\n- 邻接表的问题\n\n邻接表计算”出度”是比较简单的(出度:指向别人的数量,入度:指向自己的数量)\n邻接表如果需要计算有向图的”λ度”,那么是一件非常麻烦的事情.\n它必须构造一个“逆邻接表”,才能有效的计算“入度”但是开发中“出度”相对用的比较少\n\n四、图的遍历图的遍历思想\n图的遍历思想和&#x3D;&#x3D;树的遍历&#x3D;&#x3D;思想是一样的.\n图的遍历意味着需要将图中&#x3D;&#x3D;毎个顶点访问一遍&#x3D;&#x3D;，并且&#x3D;&#x3D;不能有重复&#x3D;&#x3D;的访问\n\n有两种算法可以对图进行遍历\n&#x3D;&#x3D;广度&#x3D;&#x3D;优先搜索( Breadth-First-search,简称&#x3D;&#x3D;BFS&#x3D;&#x3D;)\n&#x3D;&#x3D;深度&#x3D;&#x3D;优先搜索(Depth-First-search,简称&#x3D;&#x3D;DFS&#x3D;&#x3D;)\n两种遍历算法，都需要明确指定 第一个被访问的顶点\n\n广度优先搜索的思路：广度优先算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层.换句话说，就是先宽后深的访问顶点\n\n\n\n\n广度优先搜索的实现：\n创建一个&#x3D;&#x3D;队列&#x3D;&#x3D;Q\n将V标注为被发现的(灰色)，并将v将入队列Q\n如果Q非空，执行下面的步骤:\n将v从Q中取出队列.\n将ν标注为被发现的灰色\n将ν所有的未被访问过的邻接点(白色)，加入到队列中\n将v标志为黑色.\n\n\n\n深度优先搜索的思路:深度优先搜索算法将会从第—个指定的顶点开始遍历图，沿着路径直到这条路径最后被访问了接着原路回退并探索条路径。\n\n\n\n深度优先搜索算法的实现广度优先搜索算法我们使用的是队列,这里可以使用栈完成,也可以使用递归.方便代码书写,我们还是使用递归(递归本质上就是函数栈的调用)\n\n为了记录顶点是否被访问过，我们使用三种颜色来反应它们的状态\n\n&#x3D;&#x3D;白色&#x3D;&#x3D;：表示该顶点还&#x3D;&#x3D;没有被访问&#x3D;&#x3D;.\n&#x3D;&#x3D;灰色&#x3D;&#x3D;：表示该顶点被访问过，但并&#x3D;&#x3D;未被探索&#x3D;&#x3D;过\n&#x3D;&#x3D;黑色&#x3D;&#x3D;：表示该顶点被访问过且被&#x3D;&#x3D;完全探索&#x3D;&#x3D;过.\n\n五、图结构的封装属性和方法属性：\nvertexes：所有顶点（数组）\nedges：边（字典）\n\n方法：\naddVertex（）：添加顶点；\naddEdge（v1, v2）：添加边, v1,v2表示顶点；\ntoString（）：输出所有顶点\nbfs（）：广度优先搜索\ndfs（）：深度优先搜索；\n\n具体代码： // 封装图结构function Graph() &#123;  // 属性：  // 定点：数组  this.vertexes = [];  // 边：字典  this.edges = new Dictionay();  // 添加定点  Graph.prototype.addVertex = function (v) &#123;    this.vertexes.push(v);    this.edges.set(v, []);  &#125;  // 添加边, v1,v2表示顶点  Graph.prototype.addEdge = function (v1, v2) &#123;    this.edges.get(v1).push(v2);    this.edges.get(v2).push(v1);  &#125;  Graph.prototype.toString = function () &#123;    // 1.定义字符串，保存最终的结果    let resultStr = &#x27;&#x27;;    // 2.遍历所有的顶点，以及顶点对应的边    for (let i = 0; i &lt; this.vertexes.length; i++) &#123;      const vertex = this.vertexes[i];      resultStr += vertex + &#x27;-&gt;&#x27;;      let vEdges = this.edges.get(vertex);      for (let j = 0; j &lt; vEdges.length; j++) &#123;        resultStr += vEdges[j] + &#x27; &#x27;;      &#125;      resultStr += &#x27;\\n&#x27;;    &#125;    return resultStr;  &#125;  Graph.prototype.initializeColor = function () &#123;    let color = [];    for (let i = 0; i &lt; this.vertexes.length; i++) &#123;      const vertex = this.vertexes[i];      color[vertex] = &#x27;white&#x27;;    &#125;    return color;  &#125;  // 广度优先搜索  // initV: 初始化的顶点  Graph.prototype.bfs = function (initV, handler) &#123;    // 1.初始化颜色    const colors = this.initializeColor();    // 2.创建队列    const queue = new Queue();    // 3.将顶点加入到队列中    queue.enqueue(initV);    // 4.循环从队列中取出元素    while (!queue.isEmpty()) &#123;      // 4.1 从队列中取出一个顶点      const v = queue.dequeue();      // 4.2 获取和顶点相连的另外顶点      const vList = this.edges.get(v);      // 4.3 将v的颜色设置成灰色      colors[v] = &#x27;gray&#x27;;      // 4.4 遍历所有的顶点，加入到队列中      for (let i = 0; i &lt; vList.length; i++) &#123;        const e = vList[i];        if (colors[e] === &#x27;white&#x27;) &#123;          colors[e] = &#x27;gray&#x27;;          queue.enqueue(e);        &#125;      &#125;      // 4.5 访问顶点      handler(v);      // 4.6 将顶点设置为黑色      colors[v] = &#x27;black&#x27;;    &#125;  &#125;  // 深度优先搜索  Graph.prototype.dfs = function (initV, handler) &#123;    // 1.初始化颜色    const colors = this.initializeColor();    // 2.从某个顶点开始一次递归访问    this.dfsVisit(initV, colors, handler);  &#125;  Graph.prototype.dfsVisit = function (v, colors, handler) &#123;    // 1.将颜色设置成灰色    colors[v] = &#x27;gray&#x27;;    // 2.处理v顶点    handler(v);    // 3.访问v相连的顶点    const vList = this.edges.get(v);    for (let i = 0; i &lt; vList.length; i++) &#123;      const e = vList[i];      if (colors[e] === &#x27;white&#x27;) &#123;        this.dfsVisit(e, colors, handler);      &#125;    &#125;    // 4.将v设置成黑色    colors[v] = &#x27;black&#x27;;  &#125;&#125;\n\n测试用例：const g = new Graph();// 添加顶点let myVertexes = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;];for (let i = 0; i &lt; myVertexes.length; i++) &#123;  const item = myVertexes[i];  g.addVertex(item)&#125;// 添加边g.addEdge(&#x27;A&#x27;, &#x27;B&#x27;);g.addEdge(&#x27;A&#x27;, &#x27;C&#x27;);g.addEdge(&#x27;A&#x27;, &#x27;D&#x27;);g.addEdge(&#x27;C&#x27;, &#x27;D&#x27;);g.addEdge(&#x27;C&#x27;, &#x27;G&#x27;);g.addEdge(&#x27;D&#x27;, &#x27;G&#x27;);g.addEdge(&#x27;D&#x27;, &#x27;H&#x27;);g.addEdge(&#x27;B&#x27;, &#x27;E&#x27;);g.addEdge(&#x27;B&#x27;, &#x27;F&#x27;);g.addEdge(&#x27;E&#x27;, &#x27;I&#x27;);console.log(g.toString())// 广度优先遍历var bfsResult = &#x27;&#x27;;g.bfs(g.vertexes[0], function (v) &#123;  bfsResult += v + &#x27; &#x27;;&#125;)console.log(&#x27;广度优先搜索：&#x27; + bfsResult)// 深度优先遍历var dfsResult = &#x27;&#x27;;g.bfs(g.vertexes[0], function (v) &#123;  dfsResult += v + &#x27; &#x27;;&#125;)console.log(&#x27;深度优先搜索：&#x27; + dfsResult)\n\n\n\n字典结构// 封装字典结构function Dictionay() &#123;  // 字典属性  this.item = &#123;&#125;;  // 在字典中添加键值对  Dictionay.prototype.set = function (key, value) &#123;    this.item[key] = value;  &#125;  // 判断字典中是否有某个Key  Dictionay.prototype.has = function (key) &#123;    return this.item.hasOwnProperty(key);  &#125;  // 从字典中移除元素  Dictionay.prototype.remove = function (key) &#123;    // 1.判断字典中是否有这个key    if (!this.has(key)) return false;    // 2.从字典中删除key    delete this.item[key];    return true;  &#125;  Dictionay.prototype.get = function (key) &#123;    return this.has(key) ? this.item[key] : undefined;  &#125;  Dictionay.prototype.gets = function () &#123;    return Object.keys(this.item);  &#125;&#125;\n\n\n\n队列结构：function Queue() &#123;  this.items = [];  // 向队列尾部天机一个或多个新的项  Queue.prototype.enqueue = function (el) &#123;    this.items.push(el);  &#125;  // 移出队列的第一项（排在队列最前面的）项，并返回被移出的元素  Queue.prototype.dequeue = function () &#123;    return this.items.shift();  &#125;  // 返回队列中第一个元素——最先被添加，也将是最先被移除的元素。  // 队列不做任何变动，不移除元素，只返回元素  Queue.prototype.front = function () &#123;    return this.items[0]  &#125;  // 如果队列中不包含任何元素，返回true，否则返回false  Queue.prototype.isEmpty = function () &#123;    return this.items.length === 0  &#125;  // 返回队列包含的元素个数，与数组的length属性类似  Queue.prototype.size = function () &#123;    return this.items.length;  &#125;  // 将队列中的内容，转换成字符串形式  Queue.prototype.toString = function () &#123;    return this.items.toString();  &#125;&#125;\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"队列","url":"/2019/08/22/%E9%98%9F%E5%88%97/","content":" \n\n\n一、概念![image-20230401213838127](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230401213838127.png)\n队列（Queue）\n受限的线性结构，&#x3D;&#x3D;先进先出&#x3D;&#x3D;（FIFO First In First Out）\n\n只允许在表的&#x3D;&#x3D;前端进行删除&#x3D;&#x3D;操作，在表的&#x3D;&#x3D;后端进行插入&#x3D;&#x3D;操作\n\n\n队列结构的实现\n基于数组实现\n基于链表实现（链表：也是一种数据结构，JavaScript中没有自带的链表结构）\n\n二、属性和方法队列的方法（6个）：\n\nenqueue(): 向队列尾部添加一个或多个新的项\ndequeue(): 移出队列的第一项，并返回被移出的元素\nfront(): 返回队列中第一个元素\nisEmpty(): 如果队列中不包含任何元素，返回true，否则返回false\nsize(): 返回队列包含的元素个数\ntoString(): 将队列中的内容，转换成字符串形式\n\n代码实现\n/***************  队列的封装 ***********/function Queue() &#123;  this.items = [];  // 向队列尾部天机一个或多个新的项  Queue.prototype.enqueue = function (el) &#123;    this.items.push(el);  &#125;  // 移出队列的第一项（排在队列最前面的）项，并返回被移出的元素  Queue.prototype.dequeue = function () &#123;    return this.items.shift();  &#125;  // 返回队列中第一个元素——最先被添加，也将是最先被移除的元素。  // 队列不做任何变动，不移除元素，只返回元素  Queue.prototype.front = function () &#123;    return this.items[0]  &#125;  // 如果队列中不包含任何元素，返回true，否则返回false  Queue.prototype.isEmpty = function () &#123;    return this.items.length === 0  &#125;  // 返回队列包含的元素个数，与数组的length属性类似  Queue.prototype.size = function () &#123;    return this.items.length;  &#125;  // 将队列中的内容，转换成字符串形式  Queue.prototype.toString = function () &#123;    return this.items.toString();  &#125;&#125;\n\n\n\n三、算法实例击鼓传花游戏\n原游戏规则：\n\n班级中玩一个游戏，所有学生围成一圈，从某位同学手里开始向旁边的同学传一束花。\n这个时候某个人(比如班长)在击鼓，鼓声停下的一颗，花落在谁手里，谁就出来表演节目。\n\n修改游戏规则：\n\n几个朋友一起玩—个游戏，围成一圈，开始数数，数到某个数字的人自动淘汰。\n最后剩下的这个人会获得胜利，请问最后剩下的是原来在哪一个位置上的人?\n\n封装一个基于队列的函数\n\n参数: 所有参与人的姓名，基于的数字。\n结果: 最终剩下的一人的姓名。\n\nfunction passGame(nameList, num) &#123;  // 1.创建一个队列结构  const queue = new Queue();  // 2.将所有人添加到 队列 中  for (const item of nameList) &#123;    queue.enqueue(item)  &#125;  // 3.开始数数  while(queue.size() &gt; 1) &#123;    // - 不是num的时候，重新添加到队列的 末尾    // - 是num这个数字的时候，将其从队列中删除    // 3.1 num数字之前的人，添加到队列的末尾    for (let i = 0; i &lt; num - 1; i++) &#123;      queue.enqueue(queue.dequeue());    &#125;    // 3.2 num数字的这个人，直接从队列中删除    queue.dequeue();  &#125;  // 4.获取最后剩下的那个人  const lastName = queue.front();  console.log(&#x27;剩下的人：&#x27;, lastName)  return nameList.indexOf(lastName);&#125;const index = passGame([&#x27;红&#x27;, &#x27;橙&#x27;, &#x27;黄&#x27;, &#x27;绿&#x27;, &#x27;青&#x27;, &#x27;蓝&#x27;, &#x27;紫&#x27;], 3);console.log(&#x27;剩下人的索引：&#x27;, index)\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"双链表","url":"/2019/10/24/%E5%8F%8C%E9%93%BE%E8%A1%A8/","content":" \n\n一、概念![image-20230402124602154](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230402124602154.png)\n单向链表\n只能从头遍历到尾或者从尾遍历到头(一般从头到尾)，也就是链表相连的过程是 单向 的。\n实现的原理是上一个链表中有一个指向下一个的引用。\n\n单链表的缺点：\n\n我们可以轻松的到达下一个节点，但是回到前一个节点是很难的。\n但是，在实际开发中，经常会遇到需要回到上一个节点的情况。\n\n举个例子：\n假设一个文本编辑用链表来存储文本。每一行用一个 String 对象存储在链表的一个节点中。\n当编辑器用户向下移动光标时，链表直接操作到下一个节点即可。但是当用于将光标向上移动呢？\n这个时候为了回到上一个节点，我们可能需要从first开始，依次走到想要的节点上。\n\n\n双向链表\n既可以从头遍历到尾，又可以从尾遍历到头。也就是链表的相连过程是双向的，\n一个节点既有向前连接的引用，也有一个向后连接的引用。\n\n优点：\n\n每次在插入或删除某个节点时，需要处理四个引用，而不是两个。实现起来要困难一些。\n相对于单向链表，占用的内存空间更大一些。\n\n结构模型\nhead -&gt; { prev, data, next } -&gt; { prev, data, next } -&gt; { prev, data, next(tail) } -&gt; null;\n\n\nhead 指向头部节点；\n\ntail 指向尾部节点；\n\nprev 指向上一个节点；\n\nnext 指向下一个节点；\n\ndata 当前节点数据\n\n\n第一个节点的  prev 是 null\n最后一个节点的 next 是 null\n二、属性和方法链表的属性：\n\nhead: 头部节点\nnode: 节点\ndata: 节点数据\nprev：指向下一个节点的\nnext：指向下一个节点的\n\n\ntail: 尾部节点\nlength: 链表长度\n\n链表的方法（6个）：\n\nappend(data)：向链表尾部添加一个新的项\ninsert(position, data)：向链表的特定位置 插入一个新的项\nget(position)：获取对应位置的元素\nindexOf(data)：返回元素在链表中的索引。如果链表中没有该元素，则返回-1\nupdate(position, data)：修改某个位置的元素\nremoveAt(position)：从链表的特定位置删除一项\nremove(data)：从列表中删除一项\ngetHead()：获取头部节点\nforwardString()：返回向前遍历的节点字符串形式\nbackwordString()：返回向后遍历的节点字符串形式\ngetTail()：获取尾部节点\nisEmpty()：如果链表中不包含任何元素，返回true；否则返回false\nsize()：返回链表中包含的元素个数\ntoString()：将链表中的内容，转换成字符串形式\n\n具体实现：\n/***************  链表封装 ***********/function DoublyLinkedList() &#123;  // 内部类：节点类  function Node(data) &#123;    this.data = data;    this.prev = null;    this.next = null;  &#125;  // 属性  this.head = null;  this.tail = null;  this.length = 0;  // 向列表尾部添加一个新的项  DoublyLinkedList.prototype.append = function (data) &#123;    const node = new Node(data);    // 第一个节点    if (this.length === 0) &#123;      this.head = node;      this.tail = node;    &#125; else &#123;      node.prev = this.tail;      this.tail.next = node;      this.tail = node;    &#125;    this.length++;  &#125;  // 向列表的特定位置 插入一个新的项  DoublyLinkedList.prototype.insert = function (position, data) &#123;    // 1.越界判断    if (position &lt; 0 || position &gt; this.length) &#123;      return false    &#125;    // 2.创建节点数据    const node = new Node(data);    // 3.判断 原列表 是否为空    if (this.length === 0) &#123;      this.head = node;      this.tail = node;    &#125; else &#123;      // 3.1 插入的是第一个节点      if (position === 0) &#123;        this.head.prev = node;        node.next = this.head;        this.head = node;      &#125; else if (position === this.length) &#123; // 3.2 插入的是 最后一个节点        this.tail.next = node;        node.prev = this.tail;        this.tail = node;      &#125; else &#123; // 3.3 在中间位置插入        let currentNode = this.head;        let index = 0;        while (index++ &lt; position) &#123;          currentNode = currentNode.next;        &#125;        node.next = currentNode;        node.prev = currentNode.prev        currentNode.prev.next = node;        currentNode.prev = node;      &#125;    &#125;    this.length++;    return true;  &#125;  // 获取对应位置的 元素  DoublyLinkedList.prototype.get = function (position) &#123;    if (position &lt; 0 || position &gt;= this.length) &#123;      return null;    &#125;    let currentNode = this.head;    let index = 0;    while(index++ &lt; position) &#123;      currentNode = currentNode.next;    &#125;    return currentNode.data;  &#125;  // 返回元素在列表中的索引。如果列表中没有该元素，则返回-1  DoublyLinkedList.prototype.indexOf = function (data) &#123;    let curentNode = this.head;    let index = 0;    while(index &lt; this.length) &#123;      if (curentNode.data === data) &#123;        return index;      &#125;      curentNode = curentNode.next;      index++    &#125;    return -1;  &#125;  // 修改某个位置的元素  DoublyLinkedList.prototype.update = function (position, data) &#123;    if(position &lt; 0 || position &gt;= this.length) &#123;      return false;    &#125;    let curentNode = this.head;    let index = 0;    while(index++ &lt; position) &#123;      curentNode = curentNode.next;    &#125;    curentNode.data = data;    return true;  &#125;  // 从列表的特定位置删除一项  DoublyLinkedList.prototype.removeAt = function (position) &#123;    if(position &lt; 0 || position &gt;= this.length) &#123;      return null;    &#125;    let curentNode = this.head;    // 只有一个节点    if (this.length === 1) &#123;      this.head = null      this.tail = null;    &#125; else &#123;      if (position === 0) &#123; // 删除的是 第一个节点        this.head.next.prev = null;        this.head = this.head.next;      &#125; else if (position === this.length - 1) &#123; // 删除的是 最后一个节点        curentNode = this.tail;        this.tail.prev.next = null;        this.tail = this.tail.prev;      &#125; else &#123; // 删除的是 中间部分的节点        let index = 0;        while(index++ &lt; position) &#123;          curentNode = curentNode.next;        &#125;        curentNode.prev.next = curentNode.next;        curentNode.next.prev = curentNode.prev;      &#125;    &#125;    this.length--;    return curentNode.data;  &#125;  // 从列表中删除一项  DoublyLinkedList.prototype.remove = function (data) &#123;    // 1.根据元素获取 其位置    const postion = this.indexOf(data);    // 2.根绝位置信息，删除节点    return this.removeAt(postion);  &#125;  DoublyLinkedList.prototype.getHead = function () &#123;    return this.head.data;  &#125;  DoublyLinkedList.prototype.getTail = function () &#123;    return this.tail.data;  &#125;  // 如果链表中不包含任何元素，返回true；否则返回false  DoublyLinkedList.prototype.isEmpty = function () &#123;    return this.length === 0;  &#125;  // 返回链表中包含的元素个数  DoublyLinkedList.prototype.size = function () &#123;    return this.length  &#125;  // 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值  DoublyLinkedList.prototype.toString = function () &#123;    return this.backwordString();  &#125;  // 返回向前遍历的节点字符串形式  DoublyLinkedList.prototype.forwardString = function () &#123;    let current = this.tail;    let listString = &#x27;&#x27;;    while (current) &#123;      listString += current.data + &#x27; &#x27;;      current = current.prev;    &#125;    return listString;  &#125;  // 返回向后遍历的节点字符串形式  DoublyLinkedList.prototype.backwordString = function () &#123;    let current = this.head;    let listString = &#x27;&#x27;;    while (current) &#123;      listString += current.data + &#x27; &#x27;;      current = current.next;    &#125;    return listString;  &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"栈","url":"/2019/09/21/%E6%A0%88/","content":" \n\n一、概念\n\n\n\n数组和栈\n数组是一种线性结构，可以在 任意位置 插入和删除数据\n栈和队列 是 &#x3D;&#x3D;受限制的线性结构&#x3D;&#x3D;\n\n栈结构\n是一种受限的线性表，&#x3D;&#x3D;先进后出&#x3D;&#x3D; LIFO（last in first out）， 后进先出。\n仅允许在表的一端进行插入和删除，这一端成为&#x3D;&#x3D;栈顶&#x3D;&#x3D;。相对地，另一端为栈底。\n向一个栈插入新元素又称 &#x3D;&#x3D;进栈&#x3D;&#x3D;、入栈或压栈)、出栈(退栈)\n向一个栈删除元素又称作 &#x3D;&#x3D;出栈&#x3D;&#x3D;、退栈\n\n程序中的栈实现\n函数调用栈\nA调用B，B中又调用了C，C中又调用D；\n执行过程中，先将A压入栈，A没有执行完，不会退出栈\n依次将B&#x2F;C&#x2F;D压入到栈中，D压入到栈顶。当前栈顺序是 栈底A-&gt;B-&gt;C-&gt;D栈顶\nD执行完，弹出栈。C&#x2F;B&#x2F;A 依次出栈\n函数调用栈的称呼，就来自于其内部的实现机制（通过栈来实现的）。\n\n\n递归（容易引发栈溢出）\n\n栈结构的实现\n基于数组实现\n基于链表实现（链表：也是一种数据结构，JavaScript中没有自带的链表结构）\n\n二、属性和方法栈的方法（6个）：\n\npush(element): 添加一个新元素到栈顶位置\npop(): 移出栈顶位置，同时返回被移出的元素\npeek(): 返回栈顶的元素，不对栈做任何修改\nisEmpty(): 如果栈里没有任何元素就返回true，否则返回false\nsize(): 返回栈元素的个数\ntoString(): 将栈结构的内容以字符形式返回\n\n具体代码实现\n// 基于数组的实现function Stack() &#123;  // 栈的属性  this.items = [];  // push(element): 添加一个新元素到栈顶位置  Stack.prototype.push = function (element) &#123;    this.items.push(element);  &#125;  // pop(): 移出栈顶位置，同时返回被移出的元素  Stack.prototype.pop = function () &#123;    return this.items.pop();  &#125;  // peek(): 返回栈顶的元素，不对栈做任何修改  Stack.prototype.peek = function () &#123;    return this.items[this.items.length - 1];  &#125;  // isEmpty(): 如果栈里没有任何元素就返回true，否则返回false  Stack.prototype.isEmpty = function () &#123;    return this.items.length === 0;  &#125;  // size(): 返回栈元素的个数  Stack.prototype.size = function () &#123;    return this.items.length;  &#125;  // toString(): 将栈结构的内容以字符形式返回  Stack.prototype.toString = function () &#123;    return this.items.toString();  &#125;&#125;\n\n\n\n// 栈的使用const stack = new Stack();stack.push(1)stack.push(2)stack.push(3)stack.items = [1,2,3]console.log(stack.items)console.log(stack.peek())\n\n\n\n三、算法实例/***************  十进制转二进制 ***********/// 方法：除以2，直到商为0，倒着取全部的余数function dec2bin(decNumber) &#123;  // 1.定义栈对象，用于保存余数  let stack = new Stack();  // 2.循环取余数  while(decNumber &gt; 0) &#123;    // 2.1 获取余数，放入到栈中    stack.push(decNumber % 2);    // 2.2 获取整除后的结果，作为下一次循环的数字    decNumber = Math.floor(decNumber / 2);  &#125;  // 3.从栈中取出余数  let binaryString = &#x27;&#x27;;  while(!stack.isEmpty()) &#123;    binaryString += stack.pop();  &#125;  return binaryString;&#125;\n\n\n\n\n\n\n\n\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"优先级队列","url":"/2019/09/05/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/","content":" \n\n一、概念![image-20230401213838127](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230401213838127.png)\n优先级队列的特点：\n优先级队列，在插入一个元素的时候会考虑该数据的优先级。\n和其他数据优先级进行比较。\n比较完成后，可以得出这个元素在队列中正确的位置。\n其他处理方式和基本队列的处理方式一样。\n\n优先级队列主要考虑的问题\n每个元素不再只是一个数据，而且包含数据的优先级。\n在添加方式中，根据优先级放入正确的位置。\n\n优先级队列的应用\n登机顺序（头等舱、商务舱、经济舱）\n急诊科（严重患者，普通排号患者）\n计算机中，通过 优先级队列 来重新排序队列中任务的顺序\n\n二、属性和方法队列的方法（6个）：\n\nenqueue(): 向队列尾部添加一个或多个新的项\ndequeue(): 移出队列的第一项，并返回被移出的元素\nfront(): 返回队列中第一个元素\nisEmpty(): 如果队列中不包含任何元素，返回true，否则返回false\nsize(): 返回队列包含的元素个数\ntoString(): 将队列中的内容，转换成字符串形式\n\n代码实现\n/***************  优先级队列的封装 ***********/function PriorityQueue() &#123;  function QueueElement(element, priority) &#123;    this.element = element;    this.priority = priority;  &#125;  // 属性  this.items = [];  // 插入方法  PriorityQueue.prototype.enqueue = function (element, priority) &#123;    // 1.创建QueueElement 对象    let queueElement = new QueueElement(element, priority);    // 2.判断队列是否为空    if (this.items.length === 0) &#123;      this.items.push(queueElement);    &#125; else &#123;      let added = false;      for (let i = 0; i &lt; this.items.length; i++) &#123;        const item = this.items[i];        if (queueElement.priority &lt; item.priority) &#123;          this.items.splice(i, 0, queueElement);          added = true;          break;        &#125;      &#125;      if (!added) &#123;        this.items.push(queueElement);      &#125;    &#125;  &#125;  // 移出队列的第一项（排在队列最前面的）项，并返回被移出的元素  PriorityQueue.prototype.dequeue = function () &#123;    return this.items.shift();  &#125;  // 返回队列中第一个元素——最先被添加，也将是最先被移除的元素。  // 队列不做任何变动，不移除元素，只返回元素  PriorityQueue.prototype.front = function () &#123;    return this.items[0]  &#125;  // 如果队列中不包含任何元素，返回true，否则返回false  PriorityQueue.prototype.isEmpty = function () &#123;    return this.items.length === 0  &#125;  // 返回队列包含的元素个数，与数组的length属性类似  PriorityQueue.prototype.size = function () &#123;    return this.items.length;  &#125;  // 将队列中的内容，转换成字符串形式  PriorityQueue.prototype.toString = function () &#123;    return this.items.toString();  &#125;&#125;\n\n测试：\nconst pq = new PriorityQueue();pq.enqueue(&#x27;aa&#x27;, 100)pq.enqueue(&#x27;bb&#x27;, 200)pq.enqueue(&#x27;cc&#x27;, 50)pq.enqueue(&#x27;dd&#x27;, 80)pq.enqueue(&#x27;ee&#x27;, 60)console.log(pq)\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"排序算法","url":"/2020/04/01/z%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","content":" \n\n排序算法排序算法有很多：冒泡排序&#x2F;选择排序&#x2F;插入排序&#x2F;归并排序&#x2F;计数排序( counting sort)&#x2F;基数排序(radix sort)&#x2F;希尔排序&#x2F;堆排序&#x2F;桶排序；\n\n简单排序：冒泡排序 - 选择排序 - 插入排序；\n高级排序：希尔排序 - 快速排序 - 归并排序 - 堆排序。\n非比较排序：计数排序 - 基数排序 - 桶排序；\n\n一、冒泡排序\n从序列的一端开始往另一端冒泡，依次&#x3D;&#x3D;比较相邻&#x3D;&#x3D;的两个数的大小\n\n如果 左边的数大，则两数交换位置；\n向右移动一个位置 比较下面两个数；\n当走到 最右端时，最大的数 一定被放在了最右边；\n按照这个思路，从最左端重新开始，这次走到倒数第二个位置的数；\n即可依次类推，就可以将数据排序完成。\n\nArray.prototype.swap = function (m, n) &#123;  let temp = this[m];  this[m] = this[n];  this[n] = temp;&#125;function bubbleSort(array) &#123;  const len = array.length;  for (let i = 0; i &lt; len - 1; i++) &#123;    for (let j = 0; j &lt; len - i - 1; j++) &#123;      if (array[j] &gt; array[j + 1]) &#123;        array.swap(j, j + 1);      &#125;    &#125;  &#125;&#125;\n\n\n\n代码解析:\n\n获取数组的长度；\n外层循环应该让j依次减少，因此我们这里使用了反向的遍历；\n内层循环我们使用i &lt; j。因为上面的j在不断减小，这样就可以控制内层循环的次数；\n比较两个数据项的大小，如果前面的大，那么就进行交换；\n\n比较次数：\n\n假如一共有7个数字；\n第一次循环6次比较，第二次5次比较，第三次4次比较…到最后一趟进行了1次比较；\n对于7个数据项比较次数：6+5+4+3+2+1；\n对于N个数据项：(N-1)+(N-2)+(N-3)+…+1 &#x3D; N*(N-1)&#x2F;2。\n\n冒泡排序的O表示法：\n\nN*(N-1)&#x2F;2 &#x3D; N²&#x2F;2 - N&#x2F;2，根据规则2，只保留最高阶项变成N²&#x2F;2；\nN²&#x2F;2，根据规则3，去除最高项的常量，变成N²；\n因此冒泡排序的比较次数的大O表示法为&#x3D;&#x3D;O(N²)&#x3D;&#x3D;；\n\n冒泡排序交换次数：\n\n真实的次数: N*(N-1)&#x2F;4；【两次比较，需要一次交换】\n冒泡排序的交换次数是多少呢?\n如果有两次比较才需要交换一次(不可能每次比较都交换一次)，那么交换次数为 N²&#x2F;4\n由于常量不算在大O表示法中，因此，我们可以认为交换次数的大O表示也是&#x3D;&#x3D;O(N²)&#x3D;&#x3D;\n\n二、选择排序\n思路：\n\n1.取第一个数，和其他数依次比较，获得最小的数，将最小的数与第一个数交换位置，\n这样第一个数就是最小的数；\n\n2.依次取2、3、4…个数，重复第一步；\n\n\nfunction selectionSort(array) &#123;  for (let i = 0; i &lt; array.length - 1; i++) &#123;    let minIndex = i;    for (let j = i + 1; j &lt; array.length; j++) &#123;      if (array[minIndex] &gt; array[j]) &#123;        minIndex = j;      &#125;    &#125;    array.swap(minIndex, i);  &#125;&#125;\n\n代码解析：\n\n1.取一个临时变量min，表示最小值的索引；\n2.取第一个数，去和其他数比较，当arr[min] &gt; arr[other]时，min &#x3D; other;\n3.一轮比较下来之后，min就是最小值的索引，然后与第一个数 交换位置，这样第一个数就是最小的数；\n4.取第二个数，循环以上操作，得到剩余元素中最小的值，与第二个数交换位置；\n5.重复以上步骤，即可排序；\n\n比较次数：\n\n假如一共有7个数字；\n第一次循环6次比较，第二次5次比较，第三次4次比较…到最后一趟进行了1次比较；\n对于7个数据项比较次数：6+5+4+3+2+1；\n对于N个数据项：(N-1)+(N-2)+(N-3)+…+1 &#x3D; N*(N-1)&#x2F;2。\n\n选择排序的O表示法：\n\n与冒泡排序一样，O(N²)；\n\n选择排序交换次数：\n\n每次比较最多（也可能不交换）只需要交换一次，一共需要 N-1 次;\n用大O表示法，就是O(N);\n所以选择排序通常认为在执行&#x3D;&#x3D;效率上是 高于 冒泡排序&#x3D;&#x3D;的。\n\n三、插入排序\n插入排序：\n\n插入排序是&#x3D;&#x3D;简单排序中效率最好&#x3D;&#x3D;的一种\n插入排序也是学习其他&#x3D;&#x3D;高级排序的基础&#x3D;&#x3D;，比如希尔排序&#x2F;快速排序，所以也非常重要.\n\n局部有序：\n\n插入排序思想的核心是局部有序。什么是局部有序呢？\n比如在一个队列中的人，我们选择其中一个作为标记的队员；\n这个 被标记的队员左边 的所有队员已经是局部有序的；\n这意味着，有一部分人是按顺序排列好的，有一部分还没有顺序。\n\n思路：\n\n从第一个元素开始，该元素可以认为已经被排序；\n取出下一个元素，在已经排序的元素序列中从后向前扫描；\n如果该元素(已排序)大于新元素，将该元素移到下一位置；\n重复上一个步骤，直到找到已排序的元素小于或者等于新元素的位置；\n将新元素插入到该位置后，重复上面的步骤。\n\nfunction insertionSort(array) &#123;  for (let i = 1; i &lt; array.length; i++) &#123;    let j = i;    let current = array[i];    while (current &lt; array[j - 1] &amp;&amp; j &gt; 0) &#123;      array[j] = array[j - 1]      j--;    &#125;    array[j] = current;  &#125;&#125;\n\n\n\n比较次数：\n\n第一次，最多需要比较一次，第二次最多需要2次，以此类推，最后一次是 N-1 次；\n因此插入排序的最多比较次数是：1+2+3+…+N-1 &#x3D; N*(N-1)&#x2F;2;\n然而毎趟发现插入点之前，平均只有全体数据项的一半需要进行比较我们可以除以2得到N*(N-1)&#x2F;4.\n所以相对于选择排序，其比较次数是少了一半的。\n\n插入排序的复制次数：\n\n第一趟时，需要的最多复制次数是1，第二趟最多次数是2，依次类推，最后一趟是N-1次；\n因此复制次数最多是1+2+3+…+N-1&#x3D;N*N-1)&#x2F;2；\n平均次数N*(N-1)&#x2F;4。\n\n对于基本有序的情况:\n\n对于已经有序或基本有序的数据来说，插入排序要好很多；\n当数据有序的时候 while循环的条件总是为假，所以它变成了外层循环中的个简单语句，执行N-1次；\n在这种情况下，算法运行至需要O(N)的时间，效率相对来说会更高；\n另外别忘了，我们的比较次数是选择排序的一半，所以这个算法的 效率 是 高于 选择排序 的。\n\n四、希尔排序希尔排序：\n\n希尔排序是插入排序的一种高效的改进版,并且效率比插入排序要更快.\n插入排序也是学习其他高级排序的基础，比如希尔排序&#x2F;快速排序，所以也非常重要.\n\n思路：\n比如下面的数字，81,94,11,96,12,35,17,95,28,58,41,75,15：\n\n\n\n我们先让间隔为5，进行排序：\n\n(35,81)，(94,17)，(11,95)，(96,28)，(12,58)，(35,41)，(17,75)，(95,15)\n\n排序后的新序列一定可以让数字离自己的正确位置更近一步。\n\n\n\n我们再让间隔位3，进行排序：\n\n(35,28,75,58,95)，(17,12,15,81)，(11,41,96,94)\n\n排序后的新序列，一定可以让数字离自己的正确位置又近了一步最后。\n\n\n\n我们让间隔为1，也就是正确的插入排序。\n\n这个时候数字都离自己的位置更近，那么需要复制的次数一定会减少很多。\n\n\n\nfunction shellSort(array) &#123;   // 1.获取数组长度  const len = array.length;  // 2.初始化增量  let gap = Math.floor(len / 2);  // 3.while循环，gap不断减小至1  while (gap &gt;= 1) &#123;    // 4.以gap作为间隙，进行分组，对分组进行插入排序    for (let i = gap; i &lt; len; i++) &#123;      let j = i;      let current = array[i];      while (current &lt; array[j - gap] &amp;&amp; j - gap &gt; -1) &#123;        array[j] = array[j - gap]        j-= gap;      &#125;      // 5.将j位置元素赋值 current      array[j] = current;    &#125;    // 6.增量变化    gap = Math.floor(gap / 2);  &#125;&#125;\n\n\n\n\n\n希尔排序的效率：\n\n希尔排序的效率很增量是有关系的；\n但是，它的效率证明非常困难，甚至某些增量的效率到目前依然没有被证明岀来；\n但是经过统计，希尔排序使用原始增量，最坏的情况下时间复杂度为O(N²)，通常&#x3D;&#x3D;情况下都要好于O(N²)&#x3D;&#x3D;。\n\n总之我们使用希尔排序大多数情况下效率都高于简单排序：\n\n这个可以通过统计排序算法的时间来证明；\n甚至在合适的增量和某些数量N的情况下，还好好于快速排序。\n\n五、快速排序\n\n\n\n\n\n快速排序：\n\n快速排序几乎可以说是目前所有排序算法中，&#x3D;&#x3D;最快&#x3D;&#x3D;的一种&#x3D;&#x3D;排序算法&#x3D;&#x3D;；\n当然，没有任何一种算法是在任意情况下都是最优的；\n比如希尔排序确实在某些情况下可能好于快速排序；\n但是大多数情况下，快速排序还是比较好的选择。\n\n&#x3D;&#x3D;希尔&#x3D;&#x3D;排序相当于&#x3D;&#x3D;插入&#x3D;&#x3D;排序的升级版，\n&#x3D;&#x3D;快速&#x3D;&#x3D;排序是&#x3D;&#x3D;冒泡&#x3D;&#x3D;排序的升级版\n&#x3D;&#x3D;枢纽&#x3D;&#x3D; (pivot) 的选择：\n\n一种方案是直接选择第一个元素作为枢纽，但是效率不高\n另一种比较优秀的方案是，取&#x3D;&#x3D;头、中、尾的中位数&#x3D;&#x3D;。例如：8、12、3、的中位数是8。\n\n\n\n\n\n&#x3D;&#x3D;最坏&#x3D;&#x3D;情况效率：\n\n每次选择的&#x3D;&#x3D;枢纽&#x3D;&#x3D;都是&#x3D;&#x3D;最左边&#x3D;&#x3D;或者&#x3D;&#x3D;最后边&#x3D;&#x3D;的，那么效率等&#x3D;&#x3D;同于冒泡排序&#x3D;&#x3D;；\n而我们的例子可能有最坏的情况吗？是不可能的.因为我们是选择三个值的中位值。\n\n&#x3D;&#x3D;平均效率&#x3D;&#x3D;：\n\n快速排序的平均效率是&#x3D;&#x3D;O(N*logN)&#x3D;&#x3D;\n虽然其他某些算法的效率也可以达到O(N*logN)，但是快速排序是最好的\n\n枢纽为中位数：\nfunction quickSort(array) &#123;  sort(0, array.length - 1);  function sort(left, right) &#123;    if (left &gt;= right) return;    const pivot = median(array, left, right);    let i = left;    let j = right - 1;    while (i &lt; j) &#123;      while (array[++i] &lt; pivot) &#123; &#125;;      while (array[--j] &gt; pivot) &#123; &#125;;      if (i &lt; j) &#123;        swap(array, i, j);      &#125;    &#125;    swap(array, i, right - 1);    sort(left, i - 1);    sort(i + 1, right)  &#125;  function swap(array, m, n) &#123;    const temp = array[m];    array[m] = array[n]    array[n] = temp;  &#125;  function median(array, left, right) &#123;    let center = Math.floor((left + right) / 2);    // 2.判断大小，并进行交换位置    if (array[left] &gt; array[center]) &#123;      swap(array, left, center);    &#125;    if (array[center] &gt; array[right]) &#123;      swap(array, center, right);    &#125;    if (array[left] &gt; array[center]) &#123;      swap(array, left, center);    &#125;    // 3.将中位数与倒数第二个数交换    swap(array, center, right - 1);    // 4.返回枢纽数（即：交换后的中位数，倒数第二个数）    return array[right - 1];  &#125;&#125;\n\n\n\n枢纽为 最左边&#x2F;最右边&#x2F;中间数&#x2F;任意数：\nfunction quickSort(array) &#123;  sort(0, array.length - 1);  function sort(left, right) &#123;    if (left &gt;= right) return;    const pivotIndex = Math.floor((left + right) / 2);    const pivot = array[pivotIndex];    swap(array, right, pivotIndex);    let i = left;    let j = right - 1;    while (i &lt;= j) &#123;      while (array[i] &lt; pivot) &#123; i++ &#125;;      while (array[j] &gt; pivot) &#123; j-- &#125;;      if (i &lt;= j) &#123;        swap(array, i, j);      &#125;    &#125;    swap(array, i, right);    sort(left, i - 1);    sort(i + 1, right)  &#125;  function swap(array, m, n) &#123;    const temp = array[m];    array[m] = array[n]    array[n] = temp;  &#125;&#125;\n\n\n\n![image-20230410143729163](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230410143729163.png)\n","categories":["数据结构"],"tags":["算法"]},{"title":"集合","url":"/2019/11/11/%E9%9B%86%E5%90%88Set/","content":" \n\n一、概念集合结构\n集合通常是由一组无序的，不能重复的元素构成。\n集合中的元素不允许重复。\n特殊的数组：\n元素&#x3D;&#x3D;没有顺序，不能重复&#x3D;&#x3D;。\n没有顺序意味着&#x3D;&#x3D;不能通过下标访问&#x3D;&#x3D;；\nES6 中的 Set结构 就是一种集合结构\n\n\n\n二、属性和方法集合的方法：\n\nadd()：向集合中添加一个新的元素\nremove()：从集合中移除一个元素\nhas()：检查元素是否存在于集合中，若存在，返回true，否则返回false\nclear()：移除集合中的所有元素\nsize()：返回集合所包含的元素的数量\nvalues()：返回一个包含集合中所有值的数组\nunion()：并集\nintersection()：交集\ndefference()：差集\nsubset()：子集， A是否是B的子集\n\n具体实现\n/***************  集合结构 ***********/function Set() &#123;  // 属性（不用数组，用对象的原因：数组允许元素重复）  this.items = &#123;&#125;;  // 向集合中添加一个新的元素  Set.prototype.add = function (value) &#123;    if (this.has(value)) &#123;      return false;    &#125;    this.items[value] = value;    return true;  &#125;  // 从集合中移除一个元素  Set.prototype.remove = function (value) &#123;    if(!this.has(value))&#123;      return false;    &#125;    delete this.items[value];    return true;  &#125;  // 检查元素是否存在于集合中，若存在，返回true，否则返回false  Set.prototype.has = function (value) &#123;    return this.items.hasOwnProperty(value);  &#125;  // 移除集合中的所有元素  Set.prototype.clear = function () &#123;    this.items = &#123;&#125;;  &#125;  // 返回集合所包含的元素的数量  Set.prototype.size = function () &#123;    return Object.keys(this.items).length;  &#125;  // 返回一个包含集合中所有值的数组  Set.prototype.values = function () &#123;    return Object.keys(this.items);  &#125;  // 集合间的操作  // 并集  Set.prototype.union = function(otherSet) &#123;    // this:     集合A    // otherSet: 集合B    // 1.创建新集合    const unionSet = new Set();    // 2.将A集合的成员添加到 新集合 中    const values = this.values();    for (let i = 0; i &lt; values.length; i++) &#123;      unionSet.add(values[i]);    &#125;    // 3取出B集合中的元素，添加到新集合中    const values2 = otherSet.values();    for (let i = 0; i &lt; values2.length; i++) &#123;      unionSet.add(values2[i]);    &#125;    return unionSet;  &#125;  // 交集  Set.prototype.intersection = function(otherSet) &#123;    // this:     集合A    // otherSet: 集合B    // 1.创建新集合    const intersectionSet = new Set();    // 2取出 同时存在于 B集合中 和 A集合 的元素，添加到 新集合中    const values = this.values();    for (let i = 0; i &lt; values.length; i++) &#123;      const item_a = values[i]      if (otherSet.has(item_a)) &#123;        intersectionSet.add(item_a);      &#125;    &#125;    return intersectionSet;  &#125;  // 差集  Set.prototype.defference = function(otherSet) &#123;    // this:     集合A    // otherSet: 集合B    // 1.创建新集合    const defferenceSet = new Set();    // 2.将不存在B集合 中的元素添加到 新集合中    const values = this.values();    for (let i = 0; i &lt; values.length; i++) &#123;      const item_a = values[i]      if (!otherSet.has(item_a)) &#123;        defferenceSet.add(item_a);      &#125;    &#125;    return defferenceSet;  &#125;  // 子集， A是否是B的子集  Set.prototype.subset = function(otherSet) &#123;    // this:     集合A    // otherSet: 集合B    // 1.创建新集合    const subSet = new Set();    // 2.遍历A集合中的所有元素，如果发现集合A中的元素，在集合B中不存在，则返回flase    const values = this.values();    for (let i = 0; i &lt; values.length; i++) &#123;      const item = values[i];      if(!otherSet.has(item)) &#123;        return false;      &#125;    &#125;    return true;  &#125;&#125;\n\n测试用例：\nconst set = new Set();set.add(&#x27;aa&#x27;);set.add(&#x27;bb&#x27;);set.add(&#x27;cc&#x27;);set.add(&#x27;dd&#x27;);set.remove(&#x27;dd&#x27;);set.values(); // [&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;]set.has(&#x27;aa&#x27;); // trueset.has(&#x27;dd&#x27;); // falseset.size(); // 3 [&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;]const otherSet = new Set();otherSet.add(&#x27;cc&#x27;);otherSet.add(&#x27;dd&#x27;);console.log(&#x27;集合A：&#x27;, set.values());console.log(&#x27;集合B：&#x27;, otherSet.values());const unionSet = set.union(otherSet);console.log(&#x27;并集：&#x27;, unionSet.values());const intersectionSet = set.intersection(otherSet);console.log(&#x27;交集：&#x27;, intersectionSet.values());const defferenceSet = set.defference(otherSet);console.log(&#x27;差集：&#x27;, defferenceSet.values());console.log(&#x27;*************** 子集 *****************&#x27;)const setC = new Set();setC.add(&#x27;aa&#x27;);setC.add(&#x27;bb&#x27;);setC.add(&#x27;cc&#x27;);setC.add(&#x27;dd&#x27;);console.log(&#x27;集合C：&#x27;, setC.values());const subSet1 = set.subset(otherSet);console.log(&#x27;A是B的子集：&#x27;, subSet1);const subSet2 = set.subset(setC);console.log(&#x27;A是C的子集：&#x27;, subSet2);\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"1px的问题","url":"/2020/04/22/1px%E9%97%AE%E9%A2%98/","content":"\n\n一、前言像素：是组成图片的色彩和亮度的最小图像单元，是显示屏的画面上能表现出来的最小单位。\n分辨率屏幕分辨率是指纵横向上的像素点数，单位是px。\n两个大小尺寸相同的屏幕而言：\n当屏幕分辨率低时（例如 640 x 480），在屏幕上显示的像素少，单个像素尺寸比较大。\n屏幕分辨率高时（例如 1600 x 1200），在屏幕上显示的像素多，单个像素尺寸比较小。\n逻辑像素那么问题出现了：现在各尺寸、分辨率的设备层出不穷，固定尺寸参数的图片，如果设备的分辨率翻了一倍，那么我们的图片在设备上就缩小了一倍。（1CSS像素在屏幕上表现为1设备物理像素，分辨率翻倍，设备的长和宽方向上的像素数量翻了一倍）\n值得一提的是，在PC端，1CSS像素仍表现为1物理像素，但是在移动端设备上（包括安卓手机），此后就出现了逻辑像素的概念，1CSS像素在物理上具体的像素值由设备不同的逻辑像素决定。（有点绕）\n举个例子: iPhone6的物理像素是750 * 334，逻辑像素是375 * 667, 设备像素比是2，这意味着我们把2 * 2的物理像素当成1 * 1的像素来使用。当我们设置某元素的宽度为10px时，我们实际上是在设置逻辑像素\n设备像素比dpr设备像素比（device pixel ratio），即设备逻辑像素与物理像素的比值。\n常见的有2dpr、3dpr。\n二、1px问题如果我们要画一条物理像素为1px的边框，我们可以先通过媒体查询来查询本设备的dpr，那么在像素比为2dpr的设备上，我们在css中要设置border:0.5px solid red，这很容易理解，因为css中我们写的是逻辑像素。\n如果我们这样实现，在不同浏览器中，实际上展现效果大不相同。\n\nchrome：把小于0.5px的当成0，大于等于0.5px的当作1px\nfirefox：会把大于等于0.55px的当作1px\nsafiri:把大于等于0.75px的当作1px 进一步在手机上观察iOS的Chrome会画出0.5px的边，而安卓(5.0)原生浏览器是不行的。所以直接设置0.5px不同浏览器的差异比较大。\n\n我们可以采用 伪元素 + transform 的方式解决该问题：\nh1 &#123;  position: relative;&#125;h1:after &#123;  content: &#x27;&#x27;;  display: block;  width: 100%;  height: 1px;  position: absolute;  left: 0;  bottom: 0;  background: red;  transform: scaleY(1);  transform-origin: 0 0;&#125;@media screen and (min-device-pixel-ratio: 2),(-webkit-min-device-pixel-ratio: 2) &#123;  h1:after &#123;    transform: scaleY(0.5);  &#125;&#125;\n\n\n\n三、解决办法1、0.5px缺点，不兼容，如上面第二点，pc端浏览器处理方式不一致。\n所以要使用css媒体查询或js获取设备像素比，进行区分。\ndiv &#123;  border: 1px solid #bbb;&#125;@media screen and (min-device-pixel-ratio: 2),(-webkit-min-device-pixel-ratio: 2) &#123;  h1 &#123;\t\tborder-width: 0.5px;  &#125;&#125;\n\n\n\n2、使用border-image实现还可以使用 border-image 设置一个透明到边框色的线性渐变\n.div&#123;  width: 100px;  height: 100px;  margin-top: 20px;  border-bottom: 1px solid transparent;  border-image: linear-gradient(to bottom, transparent 50%, red 50%) 0 0 100%/1px 0;&#125;\n\n我们将其中的小方块放大就可以看出， 方块的底部 border 被分成了两部分，上半部是透明的，下半部是红色的。\n3、box-shadow 模拟边框.box-shadow-1px&#123;    box-shadow: 0px 0.5px 0px 0px #ee2c2c;&#125;\n\n缺点：边框有阴影，颜色浅，同样也有兼容性问题，Safari 不支持 1px 以下的 box-shadow。\n4、伪元素 + transform用媒体查询根据设备像素比用“伪元素+transform”对边框进行缩放。\n@media (-webkit-min-device-pixel-ratio:2),(min-device-pixel-ratio:2)&#123;  .border-bt-1px&#123;    position: relative;    :before&#123;      content: &#x27;&#x27;;      position: absolute;      left:0;                 bottom: 0;      width: 100%;      height: 1px;      background: #ee2c2c;      transform: scaleY(0.5);    &#125;  &#125;&#125;\n\n","categories":["CSS"],"tags":["CSS"]},{"title":"ES6-Class解析","url":"/2020/10/27/Class/","content":"\n\n1.实例和原型：\n&#x3D;&#x3D;实例属性现在除了可以定义在constructor()方法里面的this上面，也可以定义在类内部的最顶层。&#x3D;&#x3D;\n&#x3D;&#x3D;类的方法，是定义在原型上的；&#x3D;&#x3D;\n\nclass Point &#123; \tcount = 0;    constructor(x, y) &#123;    this.x = x;    this.y = y;  &#125;    increment() &#123;    this.count++;  &#125;  toString() &#123;    return &#x27;(&#x27; + this.x + &#x27;, &#x27; + this.y + &#x27;)&#x27;;  &#125;  &#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty(&#x27;x&#x27;) // truepoint.hasOwnProperty(&#x27;y&#x27;) // truepoint.hasOwnProperty(&#x27;count&#x27;) // truepoint.hasOwnProperty(&#x27;toString&#x27;) // falsepoint.__proto__.hasOwnProperty(&#x27;toString&#x27;) // true\n\n\n\n2.getter和setter与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\nclass MyClass &#123;  constructor() &#123;    // ...  &#125;  get prop() &#123;    return &#x27;getter&#x27;;  &#125;  set prop(value) &#123;    console.log(&#x27;setter: &#x27;+value);  &#125;&#125;let inst = new MyClass();inst.prop = 123;\t// setter: 123inst.prop; // &#x27;getter&#x27;\n\n\n\n3.静态方法和属性3.1 方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。\n如果在一个方法前，加上static关键字，就表示该方法&#x3D;&#x3D;不会被实例继承&#x3D;&#x3D;，而是直接通过&#x3D;&#x3D;类来调用&#x3D;&#x3D;，这就称为“静态方法”。\nclass Foo &#123;  static classMethod() &#123;    return &#x27;hello&#x27;;  &#125;&#125;Foo.classMethod() // &#x27;hello&#x27;var foo = new Foo();foo.classMethod(); // TypeError: foo.classMethod is not a function\n\n父类的静态方法，可以&#x3D;&#x3D;被子类继承&#x3D;&#x3D;。\nclass Foo &#123;  static classMethod() &#123;    return &#x27;hello&#x27;;  &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod() // &#x27;hello&#x27;\n\n\n\n3.2 属性静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。\n// 老写法class Foo &#123;  // ...&#125;Foo.prop = 1;// 新写法class Foo &#123;  static prop = 1;&#125;\n\n\n\n4.私有属性和方法ES2022正式为class添加了私有属性，方法是在属性名之前使用#表示。\nclass IncreasingCounter &#123;  #count = 0;  get value() &#123;    console.log(&#x27;Getting the current value!&#x27;);    return this.#count;  &#125;  #increment() &#123;    this.#count++;  &#125;&#125;const counter = new IncreasingCounter();counter.#count // 报错counter.#count = 42 // 报错\n\n私有属性，只能在类的内部使用（this.#count）。如果在类的外部使用，就会报错。\n5.this指向类的方法内部如果含有this，它&#x3D;&#x3D;默认指向类的实例&#x3D;&#x3D;。\n但是，必须非常小心，一旦单独使用该方法，很可能报错。\nclass Logger &#123;  printName(name = &#x27;there&#x27;) &#123;    this.print(`Hello $&#123;name&#125;`);  &#125;  print(text) &#123;    console.log(text);  &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property &#x27;print&#x27; of undefined\n\n上面代码中，如果将printName方法提取出来单独使用，this会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是undefined），从而导致找不到print方法而报错。\n一个比较简单的解决方法是，在&#x3D;&#x3D;构造方法中绑定this&#x3D;&#x3D;，这样就不会找不到print方法了。\nclass Logger &#123;  constructor() &#123;    this.printName = this.printName.bind(this);  &#125;  // ...&#125;\n\n另一种解决方法是&#x3D;&#x3D;使用箭头函数&#x3D;&#x3D;。\nclass Obj &#123;  constructor() &#123;    this.getThis = () =&gt; this;  &#125;    // 或者  getThis() =&gt; &#123;    return this;  &#125;&#125;const myObj = new Obj();myObj.getThis() === myObj // true\n\n箭头函数内部的this总是指向定义时所在的对象。\n上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以this会总是指向实例对象。\n","categories":["ES6"],"tags":["ES6"]},{"title":"CommonJS, AMD, CMD","url":"/2020/11/11/CommonJS,%20AMD,%20CMD/","content":"\n\n1、异同对比\n\n\n名称\nAMD\nCMD\nCommonJs\nES6\n\n\n\n全称\nAsynchronous Module Definition\nCommon Module Definition\nCommonJs\nECMAScript6.0\n\n\n同步&#x2F;异步\n异步\n异步\n同步\n同步 &#x2F; 异步取决于采用什么loader API\n\n\n实现实例\nRequireJs\nSeajs\nNodeJS\nJavaScript\n\n\n运行环境\n浏览器\n浏览器\n服务端\n浏览器&#x2F;服务端\n\n\n2、详细说明2.1 AMDAMD 是 RequireJS 在推广过程中对模块定义的规范化产出。\n注意：\n\nrequire([ ],callback) 首先异步加载数组内的模块，随后才会去执行callback;\n\nrequire([&#x27;jquery&#x27;, &#x27;math&#x27;, &#x27;getStyle&#x27;], function($, math, getStyle)&#123;  // ...&#125;)\n\nrequire() 异步加载moduleA，moduleB，moduleC，浏览器不会失去响应;\n它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。\n2.2 CMDCMD 是 SeaJS 在推广过程中对模块定义的规范化产出。\nCMD与AMD的区别：\n\n&#x3D;&#x3D;对于依赖的模块，AMD是提前执行，CMD是延迟执行。（不过RequireJS从2.0开始，也改成可以延迟执行）&#x3D;&#x3D;\n&#x3D;&#x3D;AMD推崇依赖前置，CMD推崇依赖就近。&#x3D;&#x3D;\n\n// AMDdefine([&#x27;./a&#x27;, &#x27;./b&#x27;], function(a, b) &#123;\t// 依赖一开始就写好  a.test();  b.test();&#125;)// CMDdefine(function(require, exports, module) &#123;  // 依赖可以就近书写  var a = require(&#x27;./a&#x27;)&#125;)\n\n\n\n2.3 CommonJS在模块中，通过require()方法来引入外部的模块。\n上下文提供了**exports 对象**导出当前模块的方法和变量， 并且它是唯一导出的出口。\n在模块中还存在一个module对象，它代表模块自身，而exports是module的属性。\n// lib.jsvar counter = 3;function incCounter() &#123;  counter++;&#125;module.exports = &#123;  counter,  incCounter&#125;;\n\n// main.jsvar mod = require(&#x27;./lib&#x27;);console.log(mod.counter);  // 3mod.incCounter();console.log(mod.counter); // 3\n\n\n\n与 ES6 模块的差异：它们有三个重大差异。\n\nCommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\nCommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\nCommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。\n\n&#x3D;&#x3D;第二个差异&#x3D;&#x3D;是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。\n而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n","categories":["JS"],"tags":["JS"]},{"title":"DOM尺寸","url":"/2021/01/23/DOM%E5%B0%BA%E5%AF%B8/","content":"\n\n浏览器尺寸的兼容性一、浏览器兼容模式怪异模式和标准模式\nBackCompat    CSS1Compat\n二、浏览器窗口可视区域尺寸IE8及以下：\n标准：document.documentElement.clientWidth&#x2F;clientHeight;\n怪异：document.body.clientWidth&#x2F;clientHeight;\n获取可视区域大小：\nfunction getViewportSize() &#123;  if(window.innerWidth) &#123;    return &#123;      width: window.innerWidth,      height: window.innerHeight    &#125;  &#125; else &#123;    if(document.compatMode === &#x27;BackCompat&#x27;) &#123;      return &#123;        width: document.body.clientWidth,        height: document.body.clientHeight,      &#125;    &#125; else &#123;      /** 不包含滚动条宽、高 */      return &#123;        width: document.documentElement.clientWidth,        height: document.documentElement.clientHeight,      &#125;    &#125;  &#125;&#125;\n\n三.滚动条距离![image-20210717171120766](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210717171120766.png)\n获取滚动条距离（兼容性处理）：\nfunction getScrollOffset() &#123;  if(window.pageXOffset)&#123;    return &#123;            left: window.pageXOffset,      top: window.pageYOffset,    &#125;  &#125; else &#123;    return &#123;      left: document.body.scrollLeft + document.documentElement.scrollLeft,      top: document.body.scrollTop + document.documentElement.scrollTop    &#125;  &#125;&#125;\n\n四、文档尺寸文档的真实大小，包括不可见部分。\nfunction getScrollSize() &#123;  if(document.body.scrollWidth)&#123;    return &#123;            width: document.body.scrollWidth,      height: document.body.scrollHeight,    &#125;  &#125; else &#123;    return &#123;      width: document.documentElement.scrollWidth,      height: document.documentElement.scrollHeight    &#125;  &#125;&#125;\n\n五、盒子外边距相对边距\n1、offsetTop&#x2F;offsetLeft：相对于定位的祖先元素的上&#x2F;左边距离，如果没有定位的祖先元素，则为距离浏览器窗口的边距；\n2、offsetParent：获取该元素最近的有定位的祖先元素，如果没有找到定位的祖先元素，则为body元素；\n绝对边距\n获取盒子距离浏览器左&#x2F;上的距离。\nfunction getElemDocPosition(el) &#123;  let parent = el.offsetParent;  let offsetLeft = el.offsetLeft;  let offsetTop = el.offsetTop;  while(parent) &#123;    offsetLeft += parent.offsetLeft;    offsetTop += parent.offsetTop;    parent = parent.offsetParent;  &#125;  return &#123;    left: offsetLeft,    top: offsetTop    &#125;&#125;\n\n六、操控滚动条window.scroll(x, y)\nwindow.scrollTo(x, y)\nwindow.scrollBy(x, y)\n","categories":["JS"],"tags":["JS"]},{"title":"ES6-Iterator","url":"/2020/10/12/Iterator/","content":"\n\n1、Iterator一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。\n原生具备 Iterator 接口的数据结构如下：(&#x3D;&#x3D;for…of可以遍历具备iterator的结构&#x3D;&#x3D;)\n-Array\n-Map\n-Set\n-String\n-TypedArray\n-函数的 arguments 对象\n-NodeList 对象\n类似数组的对象调用数组的Symbol.iterator方法\nlet iterable = &#123;  0: &#x27;a&#x27;,  1: &#x27;b&#x27;,  2: &#x27;c&#x27;,  length: 3,  [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;for (let item of iterable) &#123;  console.log(item); // &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;\n\n1.1、调用Iterator的场合\n数组的解构赋值\n\n扩展运算符\n\nyield* (后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口)\n\n其他场合\nfor…of\nArray.form()\nMap()、Set()\nPromise.all()\nPromise.race()\n\n\n1.2、Array.form()方法用于将两类对象转为真正的数组:\n类似数组的对象;\n\nIterator对象\n\n\n2、Generator函数2.1、yield表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\n遍历器对象的next方法的运行逻辑如下。\n（1）&#x3D;&#x3D;遇到yield表达式，就暂停执行后面的操作&#x3D;&#x3D;，并将紧跟在yield&#x3D;&#x3D;后面的那个表达式的值&#x3D;&#x3D;，作为返回的对象的value属性值。\n（2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。\n（3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。\n（4）如果该函数没有return语句，则返回的对象的value属性值为undefined。\nfunction* helloWorldGenerator() &#123;  yield &#x27;hello&#x27;;  yield &#x27;world&#x27;;  return &#x27;ending&#x27;;&#125;var hw = helloWorldGenerator();hw.next()// &#123; value: &#x27;hello&#x27;, done: false &#125;hw.next()// &#123; value: &#x27;world&#x27;, done: false &#125;hw.next()// &#123; value: &#x27;ending&#x27;, done: true &#125;hw.next()// &#123; value: undefined, done: true &#125;\n\n\n\n2.2、与 Iterator 接口的关系var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123;  yield 1;  yield 2;  yield 3;&#125;;[...myIterable] // [1, 2, 3]\n\n\n\n2.3、next参数yield表达式本身没有返回值，或者说总是返回undefined。\nnext方法可以带一个参数，该&#x3D;&#x3D;参数就会被当作上一个yield表达式的返回值&#x3D;&#x3D;。\nfunction* foo(x) &#123;  var y = 2 * (yield (x + 1));  var z = yield (y / 3);  return (x + y + z);&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;a.next() // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125;\n\n\n\n2.4、for…offunction* foo() &#123;  yield 1;  yield 2;  yield 3;  yield 4;  yield 5;  return 6;&#125;for (let v of foo()) &#123;  console.log(v);&#125;// 1 2 3 4 5\n\n这里需要注意，一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for...of循环之中。\n","categories":["ES6"],"tags":["ES6"]},{"title":"ES6-Object的新增方法","url":"/2020/09/12/Object/","content":"\n\n\n1、新增方法1.1.Object.is();等价于严格相等（&#x3D;&#x3D;&#x3D;）\n+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true\n\n1.2.Object.assign();拷贝对象，浅拷贝\nconst target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;const res = Object.assign(target, source1, source2);// target =&gt; &#123;a:1, b:2, c:3&#125;res === target; // true\n\n1.3.Object.getOwnPropertyDescriptors();ES5 的Object.getOwnPropertyDescriptor()方法会返回某个对象属性的描述对象（descriptor）\nES6 的Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。\n// 实现拷贝 get/set方法const source = &#123;  set foo(value) &#123;    console.log(value);  &#125;&#125;;const target2 = &#123;&#125;;Object.defineProperties(    target2,     Object.getOwnPropertyDescriptors(source));Object.getOwnPropertyDescriptor(target2, &#x27;foo&#x27;)// &#123; get: undefined,//   set: [Function: set foo],//   enumerable: true,//   configurable: true &#125;// 实现继承const obj = Object.create(  prot,  Object.getOwnPropertyDescriptors(&#123;    foo: 123,  &#125;));\n\n1.4.Object.create();一个对象继承另一个对象，另一个对象作为该对象的原型；\n// es5 的写法const obj = &#123;  method: function() &#123; ... &#125;&#125;;obj.__proto__ = someOtherObj;// es6 的写法var obj = Object.create(someOtherObj);obj.method = function() &#123; ... &#125;;\n\n1.5.Object.setPrototypeOf();设置对象的原型\nObject.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的原型对象（prototype），返回参数对象本身\n// 格式Object.setPrototypeOf(object, prototype)// 例子let proto = &#123;&#125;;let obj = &#123; x: 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40\n\n1.6.Object.getPrototypeOf();读取对象的原型对象\nObject.tetPrototypeOf(obj) === obj.__proto__Object.getPrototypeOf(1) === Number.prototype // trueObject.getPrototypeOf(&#x27;foo&#x27;) === String.prototype // trueObject.getPrototypeOf(true) === Boolean.prototype // true\n\n1.7.Object.keys();1.8.Object.values();1.9.Object.entries();1.用途是遍历对象的属性\nlet obj = &#123; one: 1, two: 2 &#125;;for (let [k, v] of Object.entries(obj)) &#123;  console.log(    `$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;`  );&#125;// &quot;one&quot;: 1// &quot;two&quot;: 2\n\n2.将对象转为真正的Map结构。\nconst obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;const map = new Map(Object.entries(obj));map // Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;\n\n1.10.Object.hasOwn();对象实例有一个hasOwnProperty()方法，可以判断某个属性是否为原生属性。\nES2022 在Object对象上面新增了一个静态方法Object.hasOwn()，也可以判断是否为自身的属性\nconst foo = Object.create(&#123; a: 123 &#125;);foo.b = 456;Object.hasOwn(foo, &#x27;a&#x27;) // falseObject.hasOwn(foo, &#x27;b&#x27;) // true\n\nObject.hasOwn()的一个好处是，对于不继承Object.prototype的对象不会报错，而hasOwnProperty()是会报错的。\nconst obj = Object.create(null);obj.hasOwnProperty(&#x27;foo&#x27;) // 报错Object.hasOwn(obj, &#x27;foo&#x27;) // false\n\n1.11.Object.fromEntries();Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。\nObject.fromEntries([  [&#x27;foo&#x27;, &#x27;bar&#x27;],  [&#x27;baz&#x27;, 42]])// &#123; foo: &quot;bar&quot;, baz: 42 &#125;\n\n主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。\nconst entries = new Map([  [&#x27;foo&#x27;, &#x27;bar&#x27;],  [&#x27;baz&#x27;, 42]]);\n\n2.preventExtensions、seal、freeze2.1 Object.preventExtensions()Object.preventExtensions()是防止对象新增属性，也防止对象的原型被重新赋值。\nconst o1 = &#123; a: 1 &#125;Object.preventExtensions(o1);o1.a = 111;\t// o1:&#123; a = 111 &#125;o1.b = 222; // o1:&#123; a = 111 &#125;delete o1.a;\t// true o1:&#123; &#125;\n\n\n\n2.2 Object.seal()bject.seal的效果相当于： 在Object.defineProperty时将configurable设置成false，同时对对象调用Object.preventExtensions。但是原有的属性值是可以修改的。\nconst o1 = &#123; a: 1 &#125;Object.seal(o1);Object.getOwnPropertyDescriptors(o1); // a: &#123;value: 1, writable: true, enumerable: true, configurable: false&#125;o1.a = 111;\t// o1:&#123; a = 111 &#125;o1.b = 222; // o1:&#123; a = 111 &#125;delete o1.a;\t// false o1:&#123; a = 111 &#125;\n\n\n\n2.3 Object.freeze()Object.freeze是在Object.seal的基础上再防止属性值被修改，将属性都变成 只读型（Readonly）。\nconst o1 = &#123; a: 1 &#125;Object.freeze(o1);Object.getOwnPropertyDescriptors(o1); // a: &#123;value: 1, writable: false, enumerable: true, configurable: false&#125;o1.a = 111;\t// o1:&#123; a = 1 &#125;o1.b = 222; // o1:&#123; a = 1 &#125;delete o1.a;\t// false o1:&#123; a = 1 &#125;\n\n\n\n总结：\n\n&#x3D;&#x3D;Object.preventExtensions()：可以修改、删除，不能新增；&#x3D;&#x3D;\n&#x3D;&#x3D;Object.seal()：可以修改，不能删除、新增；&#x3D;&#x3D;\n&#x3D;&#x3D;Object.freeze()：不能修改、删除、新增；&#x3D;&#x3D;\n\n","categories":["ES6"],"tags":["ES6"]},{"title":"ES6-Promise的方法比较","url":"/2020/09/27/Promise/","content":"\n\n1.Promise.all()Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。\nconst p = Promise.all([p1, p2, p3]);\n\n\n只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled。此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\n只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。\n\n总结：**&#x3D;&#x3D;必须全部fulfilled才返回fulfilled的数组，否则返回第一个rejected&#x3D;&#x3D;**。\n2.Promise.race()Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。\nconst p = Promise.race([p1, p2, p3]);\n\n上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。\n总结：**&#x3D;&#x3D;只返回第一个改变的状态，无乱成功或是失败。&#x3D;&#x3D;**\n3.Promise.allSettled()Promise.allSettled()方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。\n&#x3D;&#x3D;只有等到参数数组的所有 Promise 对象都发生状态变更（不管是fulfilled还是rejected）&#x3D;&#x3D;，返回的 Promise 对象才会发生状态变更。\nconst promises = [  fetch(&#x27;/api-1&#x27;),  fetch(&#x27;/api-2&#x27;),  fetch(&#x27;/api-3&#x27;),];await Promise.allSettled(promises);removeLoadingIndicator();\n\n上面示例中，数组promises包含了三个请求，只有等到这三个请求都结束了（不管请求成功还是失败），removeLoadingIndicator()才会执行。\n4.Promise.any()\n只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；\n如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。\n\n&#x3D;&#x3D;跟 Promise.all() 是完全相反的。&#x3D;&#x3D;\nPromise的实现原理function MyPromise(constructor) &#123;  const that = this;  this.status = &#x27;pending&#x27;;  // 定义状态改变前的初始状态  this.value;  // 定义状态为resolved的时候的状态  this.reason; // 定义状态为rejected的时候的状态  function resolev(value) &#123;    // 两个 === &quot;pending&quot;，保证了状态的改变是不可逆的    if (that.status === &#x27;pending&#x27;) &#123;      that.status = &#x27;resolved&#x27;;      that.value = value;    &#125;  &#125;  function reject(reason) &#123;    if (that.status === &#x27;pending&#x27;) &#123;      that.status = &#x27;resolved&#x27;;      that.reason = reason;    &#125;  &#125;  // 捕获构造异常  try &#123;    constructor(resolev, reject);  &#125; catch (error) &#123;    reject(err)  &#125;&#125;MyPromise.prototype.then = function (onFullfilled, onRejected) &#123;  switch (this.status) &#123;    case &quot;resolved&quot;:      onFullfilled(this.value);      break;    case &quot;rejected&quot;:      onRejected(this.reason)      break;  &#125;&#125;\n\n上述就是一个初始版本的myPromise，在myPromise里发生状态改变，然后在相应的then方法里面根据不同的状态可以执行不同的操作。\nvar p=new myPromise(function(resolve,reject)&#123;resolve(1)&#125;);p.then(function(x)&#123;console.log(x)&#125;)//输出1\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["源码"],"tags":["ES6"]},{"title":"CSS两栏布局","url":"/2020/06/18/%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80/","content":"\n\n\n一般两栏布局指的是左边一栏宽度固定，右边一栏宽度自适应\n\n浮动 + margin.outer, .left, .right &#123;  height: 100px;&#125;.left &#123;  float: left;  width: 200px;  background: tomato;&#125;.right &#123;  margin-left: 200px;  width: auto;  background: gold;&#125;\n\n\n\n浮动 + 右盒子BFC利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。\n.left &#123;  width: 100px;  background: red;  float: left;&#125;.right &#123;  background: blue;  overflow: hidden;&#125;\n\n\n\n父元素相对定位，左子元素绝对定位（跟“1”对应）将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。\n.outer,.left,.right &#123;  height: 100px;&#125;.outer &#123;  position: relative;&#125;.left &#123;  position: absolute;  width: 200px;  background: tomato;&#125;.right &#123;  margin-left: 200px;  background: gold;&#125;\n\n\n\n利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。\n.outer &#123;  position: relative;  height: 100px;&#125;.left &#123;  width: 200px;  background: tomato;&#125;.right &#123;  position: absolute;  top: 0;  right: 0;  bottom: 0;  left: 200px;  background: gold;&#125;\n\n\n\n利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。\n.outer &#123;  display: flex;  height: 100px;&#125;.left &#123;  width: 200px;  background: tomato;&#125;.right &#123;  flex: 1;  background: gold;&#125;\n\n","categories":["CSS"],"tags":["CSS"]},{"title":"JS事件循环机制","url":"/2021/04/24/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/","content":"\n\n宏任务：\nscript全部代码、setTimeout、setInterval、setImmediate（只有IE10支持）、I/O、UI Rendering、ajax、requestAnimationFrame。\n\n微任务：\nProcess.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver\n\nJavascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。\nJavascript单线程任务被分为同步任务和异步任务。同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。\n![image-20230417101412980](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230417101412980.png)\n\n如果有两个setTimeout，则先执行完第一个setTimeout里面所有的任务，再执行第二个里面的任务；\n\n\njs先执行同步任务，再执行异步任务，异步任务又可分为宏任务跟微任务；\n将需要执行的js当作一个宏任务，第一次事件循环中，将所有代码推入到执行栈中，然后执行，执行过程中，将宏任务推入到宏任务队列中，将微任务推入到微任务队列中。\n当第一次事件循环中的执行栈为空时，就去执行微任务队列中的事件，微任务队列为空时开始第二次事件循环；\n第二次事件循环会将宏任务队列中最顶端的事件加入到执行栈中执行，执行过程中遇到微任务则推入到微任务队列中，如果遇到宏任务则把宏任务推入到宏任务队列中，当执行栈为空时，再去执行微任务队列中的事件，直到微任务队列为空，重复第4步中的操作开始下一次事件循环，直到所有宏任务，微任务都为空为止。\n\n","categories":["JS"],"tags":["JS"]},{"title":"事件冒泡与捕获","url":"/2021/03/21/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1/","content":"\n\n1、事件冒泡与捕获JavaScript 事件分为三个阶段：\n\n捕获阶段：事件从父元素开始向目标元素传播，从 Window 对象开始传播。\n目标阶段：该事件到达目标元素或开始该事件的元素。\n冒泡阶段：这时与捕获阶段相反，事件向父元素传播，直到 Window 对象。\n\n事件冒泡事件会从最内层的元素开始发生，一直向上传播，直到document对象。\n因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是：\np -&gt; div -&gt; body -&gt; html -&gt; document\n事件捕获与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。\n上面的例子在事件捕获的概念下发生click事件的顺序应该是：\ndocument -&gt; html -&gt; body -&gt; div -&gt; p\n事件冒泡和事件捕获过程图：\n&#x3D;&#x3D;先捕获、后冒泡&#x3D;&#x3D;\n\n\n1-5是捕获过程，5-6是目标阶段，6-10是冒泡阶段；\n2、addEventListener 的第三个参数element.addEventListener(event, function, useCapture)\n\n\ntrue - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）\nfalse– 默认。事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数）\n\n阻止事件冒泡\nevent.stopPropagation( )\n在事件处理函数中返回 false\n\n但是这两种方式是有区别的。return false 不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。event.stopPropagation()则只阻止事件往上冒泡，不阻止事件本身。\n先冒泡后捕获1.根据w3c标准，应先捕获再冒泡。若要实现先冒泡后捕获，给一个元素绑定两个addEventListener，其中一个第三个参数设置为false（即冒泡），另一个第三个参数设置为true（即捕获），调整它们的代码顺序，将设置为false的监听事件放在设置为true的监听事件前面即可。\n2.还有一种，在执行捕获时，设置setTimeOut(方法名，0)，把它放到下一个宏任务\n","categories":["JS"],"tags":["JS"]},{"title":"《你不知道的JS上卷》","url":"/2020/12/12/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E4%B8%8A%E5%8D%B7/","content":"\n\n第一部分：作用域和闭包第1章：作用域1.1. 编译原理\n所谓编译指的是：源代码执行之前进行的操作。\n\n而对于 JS 而言，它的整个编译过程被粗略分为三大步：\n\n分词 - &#x3D;&#x3D;词法分析&#x3D;&#x3D;\n解析 - &#x3D;&#x3D;语法分析&#x3D;&#x3D;\n&#x3D;&#x3D;代码生成&#x3D;&#x3D;\n\n首先对于 词法分析 而言，它的主要作用就是： 把一段 JS 代码，解析成多个词法单元（token）。我们以 var a = 2; 为例，他会被解析成 5 个 token：var、a、=、2、;\n其次是 语法分析，它的作用是： **把 token 流转化为 AST （抽象语法树） **。所谓抽象语法树就是一个 树形结构的 JS 对象\n最后是 代码生成，它的作用是：把 AST 解析成可执行的代码（机器指令）\n1.2. 理解作用域明确好了这三步基础的 JS 编译原理 之后，那么下面我们来尝试理解一下作用域。\n作者告诉我们：“作用域的理解需要从一个故事开始~~”。\n既然是故事嘛，那肯定得有演员。咱们这次出动了三个演员：\n\n&#x3D;&#x3D;引擎&#x3D;&#x3D;：负责整个 JavaScript 程序的&#x3D;&#x3D;编译及执行&#x3D;&#x3D;过程（核心）\n\n&#x3D;&#x3D;编译器&#x3D;&#x3D;：负责语法分析及代码生成等（编译三步）\n\n&#x3D;&#x3D;作用域&#x3D;&#x3D;：负责收集并维护由所有变量查询，并确定访问权限\n\n\n明确好这些演员之后，接下来咱们来看这个故事：\n\n引擎 有一天看见了一段代码 var a = 2; ，这段代码在引擎看来是两段完全不同的内容，所以引擎把这段代码拆成了两部分：\n\nvar a\na = 2\n\n然后把第一段代码交给了 编译器，编译器就拿着这段代码问 作用域，你那有 a 这个变量吗？作用域如果说有，那么编译器就会忽略掉这段声明。否则，则进行 a 变量声明。\n接下来，编译器 会为 引擎 生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。\n引擎 会首先询问 作用域：在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎 就会使用这个变量。否则，引擎 会继续查找该变量（这就涉及到另外一个概念 作用域嵌套）。\n\n在这样的一个故事中，会涉及到两个关键术语：&#x3D;&#x3D;LHS&#x3D;&#x3D; 和 &#x3D;&#x3D;RHS&#x3D;&#x3D;。\n\nLHS：赋值操作的左侧查询。这并不意味着 LHS 就是赋值符号左侧的操作。大家可以用这句话进行理解 找到变量，对其赋值\nRHS：赋值操作的右侧查询。同样的道理，它也并不是赋值符号的右侧操作。大家可以用这句话进行理解 取得某变量的值\n\n如果只是这么说，可能大多数同学依然听不懂，咱们下面通过一个例子来看一下。\n\nfunction foo(a) { \n​\tconsole.log( a ); &#x2F;&#x2F; 2 \n}\nfoo( 2 ); \n\n让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。 \n\n引擎：我说作用域，我需要为foo进行RHS引用。你见过它吗？ \n作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。 \n引擎：哥们太够意思了！好吧，我来执行一下foo。 \n引擎：作用域，还有个事儿。我需要为a进行LHS引用，这个你见过吗？ \n作用域：这个也见过，编译器最近把它声名为foo的一个形式参数了，拿去吧。 \n引擎：大恩不言谢，你总是这么棒。现在我要把2赋值给a。 \n引擎：哥们，不好意思又来打扰你。我要为console进行RHS引用，你见过它吗？ \n作用域：咱俩谁跟谁啊，再说我就是干这个的。这个我也有，console是个内置对象。给你。 \n引擎：么么哒。我得看看这里面是不是有log(..)。太好了，找到了，是一个函数。 \n引擎：哥们，能帮我再找一下对a的RHS引用吗？虽然我记得它，但想再确认一次。 \n作用域：放心吧，这个变量没有变动过，拿走，不谢。 \n引擎：真棒。我来把a的值，也就是2，传递进log(..)。 \n查询步骤为：\n\nRHS：foo(2)\nLHS：a &#x3D; 2\nRHS：console\nRHS：xxx.log(a)\n\n\n1.3. 作用域嵌套当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法 \n找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。 \n考虑以下代码： \n\nfunction foo(a) { \n​\tconsole.log( a + b ); \n}\nvar b &#x3D; 2; \nfoo( 2 ); &#x2F;&#x2F; 4 \n\n对b进行的RHS引用无法在函数foo内部完成，但可以在上一级作用域（在这个例子中就是全局作用域）中完成。 \n遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。 \n1.4. 异常在 逐层向上 的查找过程中，引擎会从变量当前作用域开始，一直查找到全局作用域。如果到全局作用域还如法查找到变量的话，那么就会抛出 ReferenceError 异常 。\nReferenceError 异常 表示 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量。\n而对于 LHS 查询 而言，如果在非严格模式下（例 a = 2），编译器会在全局作用于下声明该变量，然后再为其赋值。\n而如果在严格模式下，同样会抛出 ReferenceError 异常\n\n第2章：词法作用域2.1词法阶段简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将 \n变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情 \n况下是这样的）\n\n\n在这段代码中，我们知道它包含了三级作用域：\n\n① 包含着整个全局作用域，其中只有一个标识符：foo\n② 包含着 foo 所创建的作用域，其中有三个标识符：a、bar 和 b\n③ 包含着 bar 所创建的作用域，其中只有一个标识符：c\n\n这三个作用域其实就是词法作用域的概念。\n2.2 欺骗词法如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（也可以说欺骗）词法作用域呢？ \nJavaScript中有两种机制来实现这个目的。社区普遍认为在代码中使用这两种机制并不是什么好主意。但是关于它们的争论通常会忽略掉最重要的点：&#x3D;&#x3D;欺骗词法作用域会导致性能下降&#x3D;&#x3D;。\n JS 中为我们提供了两个 API 来 “欺骗” 作用域，也就是 欺骗词法。\nevaleval() 函数会将传入的字符串当做 JavaScript 代码进行执行。利用该语法我们可以把 指定代码，指定在局部作用域下执行：\n\nfunction foo(str, a) { \n​\teval( str ); &#x2F;&#x2F; 欺骗！ \n​\tconsole.log( a, b ); \n}\nvar b &#x3D; 2; \nfoo( “var b &#x3D; 3;”, 1 ); &#x2F;&#x2F; 1, 3 \n\nwith它的作用是 扩展一个语句的作用域链。比如在如下代码中 with 内的代码，会自动指向 obj 对象：\n![image-20230407102605990](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407102605990.png)\n但是要注意，with 语法可能会导致内存泄漏：\nfunction foo(obj) &#123;  with(obj) &#123;    a = 2;  &#125;&#125;foo(&#123;&#125;)consle.log(a); // 2, a被泄漏到全局作用域上了！\n\n并且 with 会让作用域变得混乱，所以 它是一个不被推荐使用的语法。\n不光是 with，包括 eval ，它们两个都不应该是我们在日常开发时的首选项，因为它们改变作用域的特性，会导致 引擎无法在编译时对作用域查找进行优化 ，所以我们应该尽量避免使用 eval 和 with。\n\n第3章：函数作用域与块作用域首先针对函数作用于而言，它表示 一个函数的作用域范围。属于这个函数的全部变量都可以在整个函数的范围内使用及复用\n我们之前很多次的说过 函数是 js 世界的第一公民。创建函数的目的，本质上其实就是为了 把代码 “隐藏” 起来。也就是 最小特权原则。\n所谓 最小特权原则，指的是：最小限度地暴露必要内容，而将其他内容都“隐藏”起来。\n隐藏内部实现但是在某些情况下，如果我们的代码不够完善的话，那么虽然创建了函数，但是依然不符合最小特权原则。比如下面这段代码：\n![image-20230407103832164](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407103832164.png)\n在这段代码中，我们声明了一个全局变量 var b。然后在函数中对 b 进行了操作。但是因为 b 是全局变量，所以我们可以在任意位置修改 b 的值，那么这样的一个操作就是 “非常危险” 的。此时的代码就不符合最小特权原则。\n我们可以对当前代码进行下修改，把 b 的定义放到函数之后，以避免被全局访问 ：\n![image-20230407103619173](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407103619173.png)\n规避冲突\n![image-20230407104059592](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407104059592.png)\nECMAScript 在 ES6 之后新增了 let 和 const 两个声明变量的关键字，这两个关键字具备块级作用域（&#123;&#125; 组成块级作用域），同时 var 也不再被推荐使用了。所以冲突问题倒是可以比较轻松的避免。\n\n第4章：提升4.1 变量提升所谓提升指的是 变量提升 的问题，什么是变量提升呢？咱们来看这两段代码：\n![image-20230407105947634](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407105947634.png)\n![image-20230407110000228](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407110000228.png)\n大家可以猜一下这两段代码输出的内容是什么？\n第一段代码的输出结果是 2。\n第二段代码的输出结果是 undefined。\n如果我们从一个标准的程序设计角度，这样的代码是肯定不能正常运行的。但是因为 var 存在变量提升的问题，所以我们得到了以上两个对应的输出结果。\n那么这个变量提升到底是怎么提升的呢？此时啊，编译器就有话说了。\n整个 var a = 2; 的代码编译器在处理会分成两部分：\n\n在 编译阶段，进行定义声明：var a\n在 执行阶段，进行赋值声明：a = 2\n\n根据声明提升，第一段代码会被解析为以下代码：\n![image-20230407110044411](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407110044411.png)\n第二段代码会被解析为以下代码：\n![image-20230407110104747](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407110104747.png)\n4.2 函数优先而对于函数而言，同样存在变量提升的问题，同时 当函数和变量同时需要提升时，遵循 函数优先原则。例如，以下代码：\n![image-20230407110408667](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407110408667.png)\n被提升之后的内容为：\n![image-20230407110449859](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407110449859.png)\n注意，var foo尽管出现在function foo()…的声明之前，但它是重复的声明（因此被忽略了），因为 \n函数声明会被提升到普通变量之前。 \n尽管重复的var声明会被忽略掉，但出现在&#x3D;&#x3D;后面的函数声明&#x3D;&#x3D;还是可以&#x3D;&#x3D;覆盖前面&#x3D;&#x3D;的。 \n![image-20230407110645895](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407110645895.png)\n\n第5章：作用域闭包到这里，对作用域咱们了解的其实就差不多了。作者分别从 词法作用域、函数作用域、块作用域 三个方面对作用域进行了解释。\n那么什么是闭包呢？所为闭包一定是一个函数。通常情况下我们把 能够访问其它函数作用域中变量的函数 叫做闭包函数。\n闭包函数在前端开发中是非常常见的，比如：\n![image-20230407141834715](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407141834715.png)\n![image-20230407141903755](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407141903755.png)\n循环和闭包要说明闭包，for循环是最常见的例子。 \n![image-20230407142116582](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407142116582.png)\n\n正常情况下，我们对这段代码行为的预期是分别输出数字1~5，每秒一次，每次一个。 \n但实际上，这段代码在运行时会以每秒一次的频率输出五次6。 \n首先解释6是从哪里来的。这个循环的终止条件是i不再&lt;&#x3D;5。条件首次成立时i的值是6。因此，输出显示的是循环结束时i的最终值。 \n仔细想一下，这好像又是显而易见的，延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是setTimeout(.., 0)，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个6出来。 \n\n我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域.\n第3章介绍过，IIFE会通过&#x3D;&#x3D;声明并立即执行一个函数来创建作用域&#x3D;&#x3D;。 \n我们来试一下： \n![image-20230407142329128](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407142329128.png)\n\n这样也不行。我们现在显然拥有更多的词法作用域了。的确每个延迟函数都会将IIFE在每次迭代中创建的作用域封闭起来。 \n如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的IIFE只是一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。 \n\n它需要有自己的变量，用来在每个迭代中储存i的值： \n![image-20230407142546985](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407142546985.png)\n行了！它能正常工作了！。 \n可以对这段代码进行一些改进：\n![image-20230407142610723](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407142610723.png)\n重返块作用域 \n我们使用IIFE在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。第3章介绍let声明，可以用来劫持块作用域，并且在这个块作用域中声明一个变量\n本质上这是将一个块转换成一个可以被关闭的作用域。因此，下面这些看起来很酷的代码就可以正常运行了： \n![image-20230407143050841](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407143050841.png)\n但是，这还不是全部！for循环头部的let声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的&#x3D;&#x3D;每个迭代都会使用上一个迭代结束时的值&#x3D;&#x3D;来初始化这个变量。 \n![image-20230407143211762](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407143211762.png)\n第二部分：this 和 对象原型第1章：关于this所谓 this ，大家首先需要知道 它是在运行时进行绑定的，它的上下文取决于函数调用时的各种条件。 也就是说， this 的值到底是什么，取决于它所在的函数被调用时的上下文，而和它所在的函数定义时没有关系。\n同时大家要注意，以上这些描述 仅针对于 function 声明的普通函数，因为我们知道 箭头函数是不会修改 this 指向的。\n第2章：this全面解析2.1 绑定规则2.1.1 默认绑定function foo() &#123;  // this 指向 window。即：this.a === window.a  console.log(this.a);&#125;var a = 2;// foo() 等同于 window.foo()foo(); // 2\n\n如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，因此this会绑定到undefined： \nfunction foo() &#123;   &quot;use strict&quot;;\tconsole.log( this.a );&#125;var a = 2;foo(); // TypeError: this is undefined\n\n\n\n2.1.2 隐式绑定以对象方法的形式进行的函数调用，此时 this 指向调用该函数的对象：\n![image-20230407151233142](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407151233142.png)\n对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说： \n![image-20230407151350054](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407151350054.png)\n隐式丢失 \n一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而&#x3D;&#x3D;把this绑定到全局对象&#x3D;&#x3D;或者undefined上，取决于是否是严格模式。\n![image-20230407151604958](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407151604958.png)\n虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。\n一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时： \n![image-20230407153502347](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407153502347.png)\n&#x3D;&#x3D;参数传递&#x3D;&#x3D;其实就是一种&#x3D;&#x3D;隐式赋值&#x3D;&#x3D;，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。\nJavaScript环境中内置的setTimeout()函数实现和下面的伪代码类似： \n![image-20230407153651576](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407153651576.png)\n2.1.3 显式绑定\ncall (obj, p1, p2, …)\napply (obj, [ p1, p2, …])\nbind(obj)(p1, p2, …)\n\n2.1.4 new绑定主要针对构造函数。在这种情况下 this 指向构造生成的实例对象\n![image-20230407154658360](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407154658360.png)\n2.2 绑定例外2.2.1 被忽略的 this如果你把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被 忽略，实际应用的是&#x3D;&#x3D;默认绑定规则&#x3D;&#x3D;\n![image-20230407155143182](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407155143182.png)\n2.2.2  间接引用间接引用最容易在赋值时发生\n![image-20230407155523469](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407155523469.png)\n赋值表达式p.foo &#x3D; o.foo的返回值是目标函数的引用，因此&#x3D;&#x3D;调用位置是foo()&#x3D;&#x3D;而不是p.foo()或 者o.foo()。根据我们之前说过的，这里会应用&#x3D;&#x3D;默认绑定&#x3D;&#x3D;。 \n\n第3章：对象3.1 类型基础类型：stirng, number, boolean, undefined, null  ES6新增了两种，symbol, bigint\n引用类型：object\ntypeof的值：stirng, number, boolean, undefined, object, function, symbol\n3.2 复制对象3.2.1 浅拷贝：浅拷贝表示多个变量引用了同一块内存地址。\n操作方式也比较简单，可以直接通过 = 赋值符 或 Object.assgin 进行实现。\n3.2.2 深拷贝：\n浅层的深拷贝：JSON.parse( JSON.stringify( obj ) )\n深层的深拷贝:  递归。（如：Lodash.cloneDeep()）\n\n3.3 属性描述符对象中每个属性，都存在属性描述符。可以通过 Object.getOwnPropertyDescriptor() 方法来获取对应的属性描述符。不同的属性描述符代表了不同的作用：\n![image-20230407163515085](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407163515085.png)\n\n**value**：该属性的值 (仅针对数据属性描述符有效)\n**writable**：当且仅当属性的值可以被改变时为 true。\n**configurable**：当且仅当指定对象的属性描述可以被改变或者属性可被删除时，为 true。\n**enumerable**：当且仅当指定对象的属性可以被枚举出时，为 true。\n\n也可以通过 Object.defineProperty() 方法修改指定属性的属性描述符。\n![image-20230407163456199](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230407163456199.png)\n3.4 不变性对象属性不可变的方法：\n\n对象常量：结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性\n禁止扩展：Object.preventExtensions(..)。（不允许添加属性）\n密封：Object.seal。（调用preventExtensions，并标记为configurable: false。不能添加、配置、删除）\n冻结：Object.freeze()。（调用Object.seal，标记为writable: false。全都不能）\n\n3.5 遍历for...in: 遍历的是所有&#x3D;&#x3D;可枚举&#x3D;&#x3D;的属性（包括原型）。\nfor...of：遍历&#x3D;&#x3D;可迭代&#x3D;&#x3D;对象的&#x3D;&#x3D;属性值&#x3D;&#x3D;\n第4章：类的机制第5章：原型第6章：行为委托","categories":["JS"],"tags":["JS"]},{"title":"圣杯和双飞翼布局","url":"/2020/07/06/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E3%80%81%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/","content":"\n\n布局效果![image-20230317173443033](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230317173443033.png)\n这两个种三列布局效果是一样的，实现的效果如上图示所示，其特点为：\n\nheader和footer的宽度为整个浏览器的宽度\n中间是个三列布局，left和right的宽度是固定的。\n而middle的内容的宽度是自适应占满中间位置的，高度为三栏中的最大高度\n\n圣杯布局\n首先把left、middle、right都放出来\n给它们三个设置上float: left, 脱离文档流；\n一定记得给container设置上overflow: hidden; 可以形成BFC撑开文档\nleft、right设置上各自的宽度\nmiddle设置width: 100%;\n\n#middle,#left,#right&#123;\t  position: relative;    float: left;&#125;#middle&#123;    overflow: hidden;    padding: 0 200px;&#125;#left&#123;    margin-left:-100% ;    left:-200px;&#125; #right&#123;\t\tmargin-left: -200px;    left:200px; &#125;\n\n\n\n双飞翼布局双飞翼布局和圣杯布局很类似，不过是在middle的div里又插入一个div，通过调整内部div的margin值，实现中间栏自适应，内容写到内部div中。\n#middle,#left,#right&#123;    float: left;&#125;#middle&#123;    overflow: hidden;&#125;#middle .middle-inner&#123;    margin: 0 200px;&#125;#left&#123;    margin-left: -100% ;&#125; #right&#123;\t\tmargin-left: -200px;&#125;\n\n\n\n代码圣杯布局：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;  \t&lt;style&gt;      *&#123;        margin: 0;        padding: 0;      &#125;      body&#123;          min-width: 600px;      &#125;      #header,#footer&#123;          height: 50px;          width: 100%;          background: grey;      &#125;      #middle,#left,#right&#123;          float: left;      &#125;      #content&#123;          overflow: hidden;          padding: 0 200px;      &#125;      #left,#right&#123;          width: 200px;          height: 200px;          background: pink;      &#125;      #middle&#123;          width: 100%;          height: 200px;          background: yellowgreen;       &#125;       #left&#123;          margin-left:-100% ;          position: relative;          left:-200px;      &#125;       #right&#123;          margin-left: -200px;          position: relative;          left:200px;       &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;wrap&quot;&gt;        &lt;div id=&quot;header&quot;&gt;header&lt;/div&gt;        &lt;div id=&quot;content&quot;&gt;            &lt;div id=&quot;middle&quot;&gt;                middle            &lt;/div&gt;            &lt;div id=&quot;left&quot;&gt;left&lt;/div&gt;                     &lt;div id=&quot;right&quot;&gt;right&lt;/div&gt;        &lt;/div&gt;        &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n双飞翼布局:\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;  \t&lt;style&gt;  \t\t*&#123;          margin: 0;          padding: 0;      &#125;      .wrap&#123;          min-width: 600px;      &#125;      #header,#footer&#123;          height: 50px;          width: 100%;          background:grey;      &#125;      #left,#right&#123;          width: 200px;          height: 200px;          background: green;      &#125;      #middle&#123;          background: pink;          width: 100%;          float: left;          height:200px;      &#125;      #content&#123;          overflow: hidden;      &#125;      #left&#123;          float: left;          margin-left: -100%;      &#125;      #right&#123;          float: left;          margin-left: -200px;      &#125;      .middle-inner&#123;          margin: 0 200px;      &#125;  \t&lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;wrap&quot;&gt;        &lt;div id=&quot;header&quot;&gt;header&lt;/div&gt;        &lt;div id=&quot;content&quot;&gt;            &lt;div id=&quot;middle&quot;&gt;                &lt;div class=&quot;middle-inner&quot;&gt;                    middle                &lt;/div&gt;            &lt;/div&gt;            &lt;div id=&quot;left&quot;&gt;left&lt;/div&gt;                     &lt;div id=&quot;right&quot;&gt;right&lt;/div&gt;        &lt;/div&gt;        &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n\n\n\n\n","categories":["CSS"],"tags":["CSS"]},{"title":"垃圾回收机制","url":"/2021/05/10/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","content":"\n\n\n项目中，如果存在大量不被释放的内存（堆&#x2F;栈&#x2F;上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。\n\n浏览器垃圾回收机制&#x2F;内存回收机制:\n\n\n\n浏览器的Javascript具有自动垃圾回收机制(GC:Garbage Collecation)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。\n\n标记清除：在js中，最常用的垃圾回收机制是标记清除：当变量进入执行环境时，被&#x3D;&#x3D;标记为“进入环境”&#x3D;&#x3D;，当变量离开执行环境时，会被&#x3D;&#x3D;标记为“离开环境”&#x3D;&#x3D;。垃圾回收器会&#x3D;&#x3D;销毁那些带标记的值&#x3D;&#x3D;并回收它们所占用的内存空间。\n谷歌浏览器：&#x3D;&#x3D;“查找引用”&#x3D;&#x3D;，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。\nIE浏览器：&#x3D;&#x3D;“引用计数法”&#x3D;&#x3D;，当前内存被占用一次，计数累加1次，移除占用就减1，减到0时，浏览器就回收它。\n总结一下：\n有两种垃圾回收策略：\n\n标记清除：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。\n引用计数：它把对象是否不再需要简化定义为对象有没有其他对象引用到它。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。\n\n标记清除的缺点：\n\n内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。\n分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。\n\n\n优化手段：内存优化 ; 手动释放：取消内存的占用即可。\n\n（1）堆内存：fn &#x3D; null 【null：空指针对象】\n（2）栈内存：把上下文中，被外部占用的堆的占用取消即可。\n\n内存泄漏：\n\n在 JS 中，常见的内存泄露主要有 4 种，&#x3D;&#x3D;全局变量、闭包、DOM 元素的引用、定时器&#x3D;&#x3D;\n","categories":["JS"],"tags":["浏览器"]},{"title":"水平垂直居中的几种方式","url":"/2020/07/28/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/","content":"\n\n公共代码：\n/* 公共代码 */&lt;style&gt;.wp &#123;    border: 1px solid red;    width: 300px;    height: 300px;&#125;.box &#123;    background: green;    &#125;.box.size&#123;    width: 100px;    height: 100px;&#125;&lt;/style&gt;&lt;div class=&quot;wp&quot;&gt;    &lt;div class=&quot;box size&quot;&gt;123123&lt;/div&gt;&lt;/div&gt;/* 公共代码 */\n\n\n\n1.absolute + 负margin适用于盒子定宽的情况\n.wp &#123;\tposition: relative;&#125;.box &#123;  position: absolute;  top: 50%;  left: 50%;  margin-left: -50px;  margin-top: -50px;&#125;\n\n\n\n2.absolute + margin auto适用于盒子定宽的情况\n这种方式通过设置各个方向的距离都是0，此时再将margin设为auto，就可以在各个方向上居中了\n.wp &#123;    position: relative;&#125;.box &#123;    position: absolute;;    top: 0;    left: 0;    right: 0;    bottom: 0;    margin: auto;&#125;\n\n\n\n3.absolute + calc适用于盒子定宽的情况\n.wp &#123;    position: relative;&#125;.box &#123;    position: absolute;;    top: calc(50% - 50px);    left: calc(50% - 50px);&#125;\n\n\n\n4.absolute + transform.wp &#123;    position: relative;&#125;.box &#123;    position: absolute;    top: 50%;    left: 50%;    transform: translate(-50%, -50%);&#125;\n\n\n\n5.line-height利用行内元素居中属性也可以做到水平垂直居中\n把box设置为行内块元素，通过text-align就可以做到水平居中，vertical-align也可以在垂直方向做到居中。\n.wp &#123;\tline-height: 300px;  /* 水平居中 */  text-align: center;  font-size: 0px;&#125;.box &#123;  /* 修正文字 */  font-size: 16px;  line-height: initial;  text-align: left;    display: inline-block;  /* 在父元素中居中 */  vertical-align: middle;&#125;\n\n\n\n6.css-table.wp &#123;    display: table-cell;    text-align: center;    vertical-align: middle;&#125;.box &#123;    display: inline-block;&#125;\n\n\n\n7.flex布局.wp &#123;    display: flex;    justify-content: center;    align-items: center;&#125;\n\n\n\n8.grid.wp &#123;    display: grid;&#125;.box &#123;    align-self: center;    justify-self: center;&#125;\n\n","categories":["CSS"],"tags":["CSS"]},{"title":"浏览器兼容性问题","url":"/2020/08/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/","content":"\n\n\n1、样式兼容 css\n因为历史原因，不同的浏览器样式存在差异，可以通过 Normalize.css 抹平差异，也可以定制自己的 reset.css，例如通过通配符选择器，全局重置样式。\n\n* &#123; margin: 0; padding: 0; &#125;\n\n\n\n\n在CSS3还没有成为真正的标准时，浏览器厂商就开始支持这些属性的使用了。提供了针对浏览器的前缀，直到现在还是有部分的属性需要加上浏览器前缀。\n\n\n\n\n\n2、交互兼容 JS2.1 事件兼容：添加事件句柄：addEventListener、attchEvent；\n移除事件句柄：removeEventListener、deleteEvent；\n取消默认事件：preventDefault、returnValue = false;\n阻止事件冒泡：stopPropagation、cancelBabble = true;\n2.2 new Date() 构造函数使用：‘2018-07-05’是无法被各个浏览器中，使用new Date(str) 来正确生成日期对象的。 \n正确的用法是’2018&#x2F;07&#x2F;05’.\n2.3 获取 scrollTopconst scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n\n\n\n3、Android — ios 兼容性3.1 input输入框聚焦input输入框在聚焦的时候，ios有时候会出现outline或者阴影，安卓则是显示正常的。\ninput:focus&#123;outline:none&#125;input:&#123;-webkit-appearance: none;&#125;\n\n\n\n3.2 fixed定位缺陷ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位。\nandroid下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位。\nios4下不支持position:fixed\n3.3 svg 在ios不显示3.4 h5底部输入框被键盘遮挡在h5的静态页面会出现一个非常难受的问题，就是当页面出现多个input输入框的时候，导致最下面一个输入框，点击的时候弹出的键盘会遮挡输入框。用户根本不知道自己输入的是什么，对用户的体验非常不友好。解决方案：\n1.就是选中当前的DOM元素，让他出现在可视区域的顶部或者底部。代码如下：\ndocument.querySelector(&#x27;#inputId&#x27;).scrollIntoView();\n\n\n\n","categories":["CSS"],"tags":["浏览器"]},{"title":"CSS盒模型","url":"/2020/05/16/%E7%9B%92%E6%A8%A1%E5%9E%8B/","content":"\n\n盒模型标准盒模型：外边距margin + 边框border + 内边距padding + 内容content\nIE盒模型：外边距margin + 内容content (包括border + padding)\n控制盒模型的属性：box-sizing\ncontent-box 默认值，标准盒模型\nborder-box IE盒模型\nmargin负值margin-top:\t元素自身向上移动\nmargin-left:\t元素自身向左移动\n两个元素水平排列时：margin-right:\t元素本身不变，右边元素左移\n两个元素垂直排列时：margin-bottom: 元素本身不变，下边元素上移\n负值的应用：\n增加盒子宽度\n圣杯布局\n双飞翼布局\n\nBFCBFC 全称：Block Formatting Context， 名为 “块级格式化上下文”。\nBFC是一个完全独立的空间（布局环境），让空间里的元素在按照一定的规则进行布局，并且不会影响到外面的布局。\nBFC的规则\nBFC就是一个块级元素，块级元素会在垂直方向一个接一个的排列\nBFC就是页面中的一个隔离的独立容器，容器内部元素不会影响到外部元素\n垂直方向的距离由margin决定， 属于同一个BFC的两个相邻的元素外边距会发生重叠\n计算BFC的高度时，浮动元素也参与计算\n\n触发BFC\noverflow: hidden;\nposition: absolute、fixed;\ndisplay: table-cell、flex、inline-blcok;\n\nBFC解决了什么问题\n父元素浮动塌陷\n问题：子元素浮动会引发父元素高度塌陷\n解决：触发父元素BFC即可\n\nmargin 边距重叠\n问题：上下盒子边距，只会取margin较大值\n解决：给其中一个盒子套一个div，并设置触发BFC的属性即可\n\n普通元素和浮动元素相互重叠的机制\n问题：左盒子浮动，右盒子的文本会围绕浮动元素（重叠）\n解决：右盒子触发BFC即可\n\n\n行内元素：垂直margin无效，不能设置width&#x2F;height\nabsolute：\n给元素加上absolute或float就相当于给元素加上了display:block\n\n脱离文档流，是父元素高度塌陷\n\n减少重绘和回流的开销。\n\nabsolute控制隐藏和显示（absolute+ top:-9999em、absolute + visibility:hidden）\n\nabsolute由于层级的关系，隐藏和显示只会重绘，但不会回流\ndisplay:none会导致render tree重绘和回流。\n\n\n必须指定left,top,right,bottom中的至少一个，否则导致对象遵从标准文档流（简单讲就是都变成relative）。\n\nabsolute实质上是相对于static定位以外的第一个父元素的border进行定位。\n\n\n​\t\n","categories":["CSS"],"tags":["CSS"]},{"title":"深入浅出正则表达式","url":"/2021/04/09/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"\n\n正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具，合理的使用正则表达式能极大的提升项目开发效率。  \n注：本文针对熟悉或者有一些正则表达式使用经验但是不深入的人群，如果无毫基础请移步JavaScript RegExp 对象\n语法创建一个正则表达式有两种方式，一种是使用构造函数，一种是使用对象字面量：\n// 使用构造函数var reg = new RegExp(pattern,modifiers);// 对象字面量var reg = /pattern/modifiers;\npattern（模式）： 描述了表达式的模式modifiers(修饰符)： 用于指定全局匹配、区分大小写的匹配和多行匹配  \n1、i 执行对大小写不敏感的匹配。2、g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。3、m 执行多行匹配。\n废话不多说，本文不注重理论，实践才是检验真理的唯一标准。\n贪婪(非贪婪)模式正则表达式(绝大部分语言)默认是贪婪模式，即尽可能匹配多的字符。  \n示例一：\nvar str = &#x27;abcd&#123;&#123;efg&#125;&#125;abcd&#123;&#123;xyz&#125;&#125;&#x27;var reg = /&#123;&#123;.*&#125;&#125;/g;str.match(reg) //  &#123;&#123;efg&#125;&#125;abcd&#123;&#123;xyz&#125;&#125;\n解读：匹配所有双花括号中出现0次或多次的字符，那为什么结果是’abcd‘，而不是[‘‘, ‘‘]，这就是正则的贪婪模式，中间的‘efg}}abcd\n","categories":["JS"],"tags":["正则表达式"]},{"title":"JS类型","url":"/2021/02/17/%E7%B1%BB%E5%9E%8B/","content":"\n\n数据类型：7string, number, boolean, undefined, null, object, symbol\ntypeof：7string, number, boolean, undefined, object, function, symbol\ninstanceof:于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。\n// 定义构造函数function C () &#123;&#125;function D () &#123;&#125;// 实例化一个 o 对象var o = new C()// true，true --&gt; C.prototype 在 o 的原型链上console.log(o instanceof C, o.__proto__ === C.prototype, &#x27;此时 o 的 __proto__：&#x27;, o.__proto__, &#x27;此时 C 的 prototype：&#x27;, C.prototype)// false，false --&gt; D.prototype 不在 o 的原型链上console.log(o instanceof D, o.__proto__ === D.prototype)// true true --&gt; Object.prototype 在 o 的原型链上console.log(o instanceof Object, o.__proto__.__proto__ === Object.prototype)// 这时我们修改构造函数 C 的原型为一个空对象C.prototype = &#123;&#125;// 实例化一个 o2 对象var o2 = new C()// true --&gt; C.prototype 在 o2 的原型链上console.log(o2 instanceof C)// false，C.prototype 指向了一个空对象,这个空对象不在 o 的原型链上.console.log(o instanceof C, &#x27;此时 o 的 __proto__：&#x27;, o.__proto__, &#x27;此时 C 的 prototype：&#x27;, C.prototype)console.log(&#x27;此时 D 的 prototype：&#x27;, D.prototype);// 继承D.prototype = new C()console.log(&#x27;此时 D 的 prototype：&#x27;, D.prototype);var o3 = new D()// true, true --&gt; 因为 o3 是 构造函数 D new 出来的实例对象，所以 D.prototype 一定在 o3 的原型链上console.log(o3 instanceof D, o3.__proto__ === D.prototype)// true --&gt; 因为 C.prototype 现在在 o3 的原型链上console.log(o3 instanceof C)// true,true --&gt; 上面的结果为什么为 true 呢，看如下代码，D.prototype 是 构造函数 C new 出来的实例对象，所以 C.prototype 一定在 D.prototype 的原型链上console.log(o3.__proto__ === D.prototype, D.prototype.__proto__ === C.prototype);// true 相当于如下代码console.log(o3.__proto__.__proto__ === C.prototype);\n\n\n","categories":["JS"],"tags":["JS"]},{"title":"理解闭包","url":"/2021/03/03/%E9%97%AD%E5%8C%85/","content":"\n\n前言要理解闭包，我们需要了解js上下文环境和作用域链的知识，有兴趣的同学可以看看下面这两篇，或许对你有些许帮助：\njavascript中神奇的预编译javascript的作用域与作用域链\n概念闭包就是能够读取其他函数内部变量的函数。\n首先我们来了解什么是闭包，总结为一句话就是：函数作为返回值、函数作为参数传递。\n第一种：函数为返回值\nfunction test1() &#123;  function test2()&#123;    var b = 2    console.log(a)  &#125;  var a = 1  return test2&#125;var c = 3var test3 = test1()test3()\n\n第二种：函数为参数\nvar max = 10var fn = function(x) &#123;  if (x &gt; max) &#123;    console.log(x)  &#125;&#125;(function(f)&#123;  var max = 100  f(15)&#125;)(fn)\n\n原理我们来使用上面第一个例子来解读  \n1、当test1函数被定义时，系统生成[[scope]]属性，[[scope]]保存该函数当作用域链，该作用域链的第0位存储当前环境下的全局执行上下文GO，GO里存储的全局下的所有对象，其中包含函数test1和全局变量c\n2、当test1被执行时，生成test1函数的AO储存在作用域链的顶端，同时GO被排在第1位，而此时test2被定义，此时test2的作用域链和test1相同\n3、当函数test1执行结束时，因为test2被返回到外部，且被全局变量test3接收。这时test1的AO并没有被销毁，只是把线剪断了，因为test2没有执行，只是被返回到外部，并把test1(也是test2)的AO携带出去了，test2的作用域链还连着的。\n4、test3执行，即test2开始执行，此时test2拥有自己的作用域链，并且在该作用域链的顶端增加了test2的AO。根据作用域链原理，当执行到console.log(a)时，现在test2的AO里寻找a，此时没有找到，让后去test1的AO里查找，找到了则此时操作的AO为test1的AO。当再次执行test3时，实际操作的仍然是原来test1的AO。\n5、当test3执行结束后，test2的AO被销毁，但是原来test1的AO被test2携带到了外部导致无法被销毁，test2的AO依然存在。所以，我们知道为什么说闭包会导致内存泄漏了吧！\n注意： 当内部函数被返回到外部并保存时，一定会产生闭包，闭包会产生原来的作用域链不释放，过度的闭包可能会导致内存泄漏，或加载过慢。\n夯实基础例一：\nfunction test1() &#123;  var n = 100  function add() &#123;    n++    console.log(n)  &#125;  function reduce () &#123;    n--    console.log(n)  &#125;  return [add, reduce]&#125;var arr = test1()arr[0]() // 99arr[1]() // 100arr[0]() // 101arr[0]() // 102\n例二：\nfunction breadMgr(num) &#123;  var breadNum = num || 10  function supply() &#123;    breadNum += 10    console.log(breadNum)  &#125;  function sale()&#123;    breadNum--    console.log(breadNum)  &#125;  return [supply, sale]&#125;var breadMgr = breadMgr(50)breadMgr[0]()breadMgr[1]()breadMgr[1]()breadMgr[1]()\n\n例三：经典面试题\nfunction test() &#123;  var arr = [];  for (var i = 0; i &lt; 10; i++) &#123;      arr[i] = function () &#123;        console.log(i + &#x27; &#x27;)      &#125;  &#125;  return arr;&#125;var myArr = test();myArr[0]() // 10myArr[1]() // 10myArr[1]() // 10\n实例解读：1、for循环中添加了10个方法，被储存在数组arr中。2、这些方法并未被执行，而是被返回到了外部并赋值给了变量myArr，因为未被执行，所以此时匿名函数的AO为函数test()的AO。3、当执行myArr中当方法时，此时匿名函数生成自己的AO。4、当程序执行到console.log(i)时，js会自动先去匿名函数的AO中寻找变量i，此时没有找到，然后去test函数中寻找，找到了，而此时i的值在test函数执行完之后变成了10，所以，不论怎么执行myArr的方法，i的值始终为10。\n解决办法：方法一：通过外部力量强行改变\nfunction test() &#123;  var arr = [];  for (var i = 0; i &lt; 10; i++) &#123;      arr[i] = function (j) &#123;        console.log(j + &#x27; &#x27;)      &#125;  &#125;  return arr;&#125;var myArr = test();myArr[1](j)\n方法二：函数自执行， 通过立即执行函数使i随for循环时改变\nfunction test() &#123;  var arr = [];  for (var i = 0; i &lt; 10; i++) &#123;    (function(j)&#123;      arr[i] = function (j) &#123;        console.log(j + &#x27; &#x27;)      &#125;    &#125;(i))  &#125;  return arr;&#125;var myArr = test();myArr[1]()","categories":["JS"],"tags":["JS"]},{"title":"JS预编译","url":"/2021/01/09/%E9%A2%84%E7%BC%96%E8%AF%91/","content":"\n\n前言在说预编译原理之前，我们先来了解两个名词。GO(global object)：全局执行上下文；AO(activation object)： 活跃对象，函数执行上下文。预编译的过程跟这两个东西密切相关，其过程可归纳为两步：1.检查通篇的语法错误；2.解释一行，执行一行。\nAO我们先看下面这个例子，看你认为的结果和实际结果相差多少：  \nfunction test(a)&#123;  console.log(a)  var a = 1  console.log(a)  function a() &#123;&#125;  console.log(a)  var b = function () &#123;&#125;  console.log(b)  function d()&#123;&#125;&#125;test(2)  // 打印结果： ƒ a() &#123;&#125;，1， 1，ƒ a() &#123;&#125;\n看到结果之后是不是很震惊，跟你想想的完全不一样。这是为什么呢？当然跟我们前面提到的AO对象有关啦。在函数内部程序是按照AO的流程进行编译和执行的，且看AO执行流程：\n1.寻找形参和变量声明；2.实参值赋值给形参；3.找函数声明；4.执行，赋值。   \n我们现在依照这个流程来走一下上面这段程序。1、首先我们寻找函数内部的形参和声明的变量，有变量a：undefined， 变量b: undefind2、第二步将实参值赋值给形参。a变成了23、然后寻找函数声明，a: function a() {}, d: function d(){}4、最后执行函数并赋值。a &#x3D; 1, b &#x3D; function () {} ，此时你是不是在想a现在不是等于1了吗，应该前三个都打印1呀，但是你忽略了第四步的要点，执行并赋值，因为第一行的console.log(a) 在未赋值之前，此时a的值在第三步中已经变成了函数**function a() {}，所以此时打印function a() {}**。上面的四条你如果觉得可以用以有点难理解，请结合以下结构阅读：\nAO = &#123;  a: undefined -&gt;      2 -&gt;      function a()&#123;&#125; -&gt;      1,  b: undefined -&gt; function ()&#123;&#125;,  d: function d() &#123;&#125;&#125;\n注意： 函数执行完成以后，AO是要销毁的，AO是一个即时的存储容器  \n趁热打铁，在来一道题：\nfunction test(a,b) &#123;  console.log(a);  c = 0;  var c;  a = 5;  b = 6;  console.log(b)  function b()&#123;&#125;  function d()&#123;&#125;  console.log(b)&#125;test(1) // 打印：1， 6， 6\n使用AO图解\nAO = &#123;  a: undefined -&gt;     1 -&gt;     5,  b: undefined -&gt;     function b()&#123;&#125; -&gt;     6,  c: undefined -&gt;     0,  d: function d()&#123;&#125;&#125;\n到这里是不是对预编译过程是不是有了清晰的理解了。\nGO同样先上一道例子：\nvar a = 1;function a()&#123;  console.log(2)&#125;console.log(a)\n很多人可能知道这里会打印1，但是他无法说服自己为什么会打印1，而不是打印function a(){}，甚至是2。我们先看看全局上下文js的预编译过程：\n1.找变量声明；2.找函数声明；3.执行，赋值。    \n现在用这三步流程来解析以下上面的代码块1、找到变量声明a，此时值为undefined；2、然后找到函数声明a，此时值为function a(){}；3、最后执行代码块，并赋值，此时a &#x3D; 1。\n下面用GO结构表示\nGO = &#123;  a: undefined -&gt;     function a()&#123;&#125; -&gt;     1&#125;\n很多代码块我们可能只知道结果，但是不知道为什么是这样的结果，当我们弄清楚了预编译的过程，就很容易知道js代码块执行过程到底发生了什么。\n基础夯实看了上面的解释，你可能以为你掌握了预编译过程，那么请你做做下面的几道题，看看有几道题能答对呢（先别着急看后面答案和在浏览器中运行哟）。\n例一：\nvar b = 3;console.log(a)function a(a) &#123;  console.log(a)  var a = 2  console.log(a)  function a() &#123;&#125;  var b = 5;  console.log(b)&#125;a(1)\nGO = &#123;  b: undefined -&gt; 3  a: function a(a) &#123;&#125;&#125;AO-a = &#123;  a: undefined -&gt;      1 -&gt;      function a() &#123;&#125; -&gt;      2  b: undefined -&gt; 5&#125;\n\n例二：\na = 1;function test() &#123;  console.log(a);  a = 2;  console.log(a);  var a = 3;  console.log(a)&#125;test()var a;\nGO = &#123;  a: undefined -&gt; 1,  test: function test() &#123;&#125;&#125;AO = &#123;  a: undefined -&gt; undefined -&gt; 2 -&gt; 3&#125;\n\n例三：\nfunction test()&#123;  console.log(b);  if(a)&#123;    var b = 2;  &#125;  c = 3;  console.log(c)&#125;var a;test();a = 1;console.log(a)\nGO = &#123;  a: undefined -&gt; 1  test: function test()&#123;&#125;,  c: 3&#125;AO = &#123;  b: undefined&#125;\n\n例四：\nfunction test()&#123;  return a;  a = 1;  function a()&#123;&#125;  var a = 2;&#125;console.log(test())\nAO = &#123;  a: undefined -&gt; function a()&#123;&#125;&#125;\n\n例五：\nfunction test() &#123;  a = 1;  function a()&#123;&#125;  var a =2;  return a&#125;console.log(test())\nAO = &#123;  a: undefined -&gt; function a()&#123;&#125; -&gt; 2&#125;\n\n例六：\na = 1;function test(e)&#123;  function e()&#123;&#125;  arguments[0] = 2;  console.log(e);  if(a)&#123;    var b = 3  &#125;  var c;  a = 4;  var a;  console.log(b);   f = 5;  console.log(c);   console.log(a); &#125;var a;test(1)\nGO = &#123;  a: undefined,  test: function test(e)&#123;...&#125;  f: 5&#125;AO = &#123;  a: undefined -&gt; 4,  b: undefined,  c: undefined,  e: 1 -&gt; function e()&#123;&#125; -&gt; 2&#125;","categories":["JS"],"tags":["JS"]},{"title":"数组方法重写","url":"/2021/09/21/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/","content":"\n\n\nforEachArray.prototype.myEach = function (fn) &#123;  var arr = this;  var obj = arguments[1] || window;  for (let i = 0; i &lt; arr.length; i++) &#123;    const item = arr[i];    fn.apply(obj, [item, i, arr])  &#125;&#125;\n\n\n\nmapArray.prototype.myMap = function (fn) &#123;  var arr = this;  var obj = arguments[1] || window;  var newArr = [];  for (let i = 0; i &lt; arr.length; i++) &#123;    const item = deepClone(arr[i]);    newArr.push(      fn.apply(obj, [item, i, arr])    )   &#125;  return newArr;&#125;\n\n\n\nreduceArray.prototype.myReduce = function (fn, initialValue) &#123;  let arr = this;  let prev;  if (initialValue) &#123;    prev = initialValue;    for (let i = 0; i &lt; arr.length; i++) &#123;      const item = arr[i];      prev = fn(prev, item, i, arr);    &#125;  &#125; else &#123;    prev = arr[0];    for (let i = 1; i &lt; arr.length; i++) &#123;      const item = arr[i];      prev = fn(prev, item, i - 1, arr);    &#125;  &#125;  return prev;&#125;\n\n\n\n数组扁平化：const arr = [1, [2, [3, 4]]];function flatten (arr) &#123;  let res = [];  for (const v of arr) &#123;    if(Array.isArray(v)) &#123;      res.push(...flatten(v));    &#125; else &#123;      res.push(v);    &#125;  &#125;  return res;&#125;\n\n","categories":["源码"],"tags":["原理"]},{"title":"路由原理","url":"/2021/08/11/%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/","content":"\n\n路由原理hash路由（核心api：hashchange事件）利用a标签，并阻止默认事件。通过hashchange事件监听hash值的变化，替换掉目标区域的html内容\n&lt;h1&gt;hash 路由&lt;/h1&gt;&lt;a href=&quot;#user&quot;&gt;用户&lt;/a&gt;&lt;a href=&quot;#about&quot;&gt;关于&lt;/a&gt;&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;!-- 下面一开始就被隐藏了 --&gt;&lt;div id=&quot;user&quot;&gt;这里是用户模块&lt;/div&gt;&lt;div id=&quot;about&quot;&gt;这里是关于模块&lt;/div&gt;\n\nconst $user = document.querySelector(&#x27;#user&#x27;)const $about = document.querySelector(&#x27;#about&#x27;)const $content = document.querySelector(&#x27;#content&#x27;)hashRender()window.addEventListener(&#x27;hashchange&#x27;, function(e) &#123;  hashRender()&#125;)function hashRender () &#123;  if (location.hash === &#x27;#user&#x27;) &#123;    $content.innerHTML = $user.innerHTML  &#125; else &#123;    $content.innerHTML = $about.innerHTML  &#125;&#125; \n\n\n\nhistory路由（核心api：pushState&#x2F;replaceState、popstate）\n使用点击事件，将对应的名称通过pushState &#x2F; replaceState方法添加到浏览器history对象中，并在此时根据模块名称替换掉目标区域的html内容。随后，当浏览器发生后退、前进的行为时，可以通过popstate事件监听到location.pathname，最后再做更新。\n![image-20230312155110164](data:image&#x2F;svg+xml,)\n&lt;h1&gt;history 路由&lt;/h1&gt;&lt;span class=&quot;route user&quot;&gt;用户&lt;/span&gt;&lt;span class=&quot;route about&quot;&gt;关于&lt;/span&gt;&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;!-- 下面一开始就被隐藏了 --&gt;&lt;div id=&quot;user&quot;&gt;这里是用户模块&lt;/div&gt;&lt;div id=&quot;about&quot;&gt;这里是关于模块&lt;/div&gt;\n\nconst $user = document.querySelector(&#x27;#user&#x27;)const $about = document.querySelector(&#x27;#about&#x27;)const $content = document.querySelector(&#x27;#content&#x27;)const $route = document.querySelectorAll(&#x27;.route&#x27;)let url = location.pathname;function historyRender (name) &#123;  if (name === &#x27;user&#x27;) &#123;    $content.innerHTML = $user.innerHTML  &#125; else &#123;    $content.innerHTML = $about.innerHTML  &#125;&#125;for (let i = 0; i &lt; $route.length; i++) &#123;  const route = $route[i];  route.addEventListener(&#x27;click&#x27;, function(e) &#123;    const name = e.target.classList[1]    historyRender(name)    window.history.pushState(null, null, name)  &#125;)&#125;window.addEventListener(&#x27;popstate&#x27;, function(e) &#123;  historyRender(location.pathname.slice(1))&#125;)\n\n\n\nonpopstate 事件只能监听到由浏览器触发的历史记录变化，例如点击浏览器的&#x3D;&#x3D;前进&#x3D;&#x3D;或&#x3D;&#x3D;后退&#x3D;&#x3D;按钮，或者调用 history.back() 或 history.forward() 方法。\n如果你在 JavaScript 中调用 history.pushState() 或 history.replaceState() 方法来修改浏览器的历史记录，那么不会触发 onpopstate 事件。\n因此，如果你想要在调用 pushState() 或 replaceState() 方法后立即获取路由变化，可以在调用这两个方法后手动触发 popstate 事件，例如\nhistory.pushState(&#123;&#125;, &#x27;&#x27;, &#x27;/new-path&#x27;);window.dispatchEvent(new PopStateEvent(&#x27;popstate&#x27;));\n\n在上面的代码中，我们先调用 pushState() 方法来修改浏览器的历史记录，并修改当前页面的 URL 为 /new-path。然后，手动触发 popstate 事件，这会立即触发绑定在 window.onpopstate 上的事件处理函数，并获取到新的路由信息\n","categories":["源码"],"tags":["原理"]},{"title":"对象拷贝","url":"/2021/05/30/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/","content":"\n\n浅拷贝1.es3写法let originObj = &#123;&#125;;let cloneObj = &#123;&#125;;for(const key in originObj) &#123;  cloneObj[key] = originObj[key];&#125;\n\n\n\n2.es5写法// 写法一Object.getOwnPropertyNames(originObj).forEach(function(key) &#123;  cloneObj[key] = originObj[key]&#125;)// 写法二Object.getOwnPropertyNames(originObj).forEach(function (key) &#123;  const des = Object.getOwnPropertyDescriptor(originObj, key);  Object.defineProperty(cloneObj, key, des);&#125;)\n\n\n\n3.es6的写法// 写法一for(const key of Object.keys(originObj)) &#123;  cloneObj[key] = originObj[key];&#125;// 写法二for (const [key, value] of Object.entries(originObj)) &#123;  cloneObj[key] = value;&#125;// 写法三Object.assign(cloneObj, originObj);\n\n\n\n深拷贝function deepClone(obj) &#123;  if (typeof obj !== &#x27;object&#x27; || obj == null) &#123;    return obj;  &#125;    if(obj instanceof Date) return new Date(obj);  if(obj instanceof RegExp) return new RegExp(obj);  // let newObj = obj instanceof Array ? [] : &#123;&#125;; // 方法一  // let newObj = Array.isArray(obj) ? [] : &#123;&#125;; // 方法二  let newObj = (&#123;&#125;).toString.call(obj) === &#x27;[object Array]&#x27; ? [] : &#123;&#125;; // 方法三  for (const key in obj) &#123;    if (Object.hasOwnProperty.call(obj, key)) &#123;      newObj[key] = deepClone(obj[key])    &#125;  &#125;  return newObj;&#125;\n\n\n\nWeakMap解决拷贝死循环上述深拷贝方法有个缺陷，如下：\nlet obj1 = &#123;&#125;;let obj2 = &#123;&#125;;obj1.obj2 = obj2;obj2.obj1 = obj1;deepClone(obj2);\n\n会循环引用，最后导致栈溢出。\n![image-20230317102743971](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230317102743971.png)\nWeakMap的key是弱引用类型，如果键名在外部没有被引用了，那么键名和键值会自动被内存回收掉。\nWeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。\n\nfunction deepClone(obj, hashMap = new WeakMap()) &#123;  if (typeof obj !== &#x27;object&#x27; || obj == null) &#123;    return obj;  &#125;    const hashKey = hashMap.get(obj);  if (hashKey) return hashKey;  let newObj = new obj.constructor();  hashMap.set(obj, newObj)  for (const key in obj) &#123;    if (Object.hasOwnProperty.call(obj, key)) &#123;      newObj[key] = deepClone(obj[key])    &#125;  &#125;  return newObj;&#125;\n\nlet obj1 = &#123;&#125;;let obj2 = &#123;&#125;;obj1.obj2 = obj2;obj2.obj1 = obj1;deepClone(obj2);\n\n![image-20230317102904579](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230317102904579.png)\n","categories":["源码"],"tags":["原理"]},{"title":"函数柯里化","url":"/2021/07/18/%E6%9F%AF%E9%87%8C%E5%8C%96/","content":"\n\n实现add(1)(2)(3) &#x3D;&#x3D;6 &amp;&amp; add(1, 2, 3) &#x3D;&#x3D; 6利用 toString()  或  valueOf()\nfunction add() &#123;  let args = Array.prototype.slice.call(arguments);  let adder = function() &#123;    args.push(...arguments)    return adder;  &#125;  adder.toString = function() &#123;    return args.reduce((a, b) =&gt; &#123;      return a + b    &#125;, 0)  &#125;  return adder;&#125;console.log(add(1)(2)(3) == 6);console.log(add(1, 2, 3) == 6);\n\n\n\n实现add(1)(2)(3)() &#x3D;&#x3D; add(1, 2)(3)() &#x3D;&#x3D; add(1, 2, 3)() &#x3D;&#x3D; 6function add() &#123;  let args = Array.prototype.slice.call(arguments);  const adder = function () &#123;    if (arguments.length === 0) &#123; // 最后一次调用，直接计算结果      return args.reduce(function (a, b) &#123;        return a + b;      &#125;, 0);    &#125; else &#123; // 不是最后一次调用，将参数都保存下来      [].push.apply(args, arguments);      return adder;    &#125;  &#125;  return adder;&#125;console.log(add(1, 2, 3)()) // 6console.log(add(1, 2)(3)()) // 6console.log(add(1)(2)(3)()) // 6\n\n\n\n函数柯里化使用柯里化对上面代码进行改进。\n最终代码：\nfunction currying(fn) &#123;  let args = [];  const adder = function () &#123;    if (arguments.length === 0) &#123; // 最后一次调用，直接计算结果      return fn.apply(this, args)    &#125; else &#123; // 不是最后一次调用，将参数都保存下来      [].push.apply(args, arguments);      return adder;    &#125;  &#125;  return adder;&#125;// 使用柯里化函数求和function add() &#123;  let args = Array.prototype.slice.call(arguments);  return args.reduce(function (a, b) &#123;    return a + b;  &#125;, 0);&#125;const sum = currying(add);console.log(sum(1, 2, 3)()) // 6console.log(sum(1, 2)(3)()) // 6 覆盖上一个console.log(sum(1)(2)(3)()) // 6 覆盖前两个// 使用柯里化函数排序function sort() &#123;  let args = Array.prototype.slice.call(arguments);  args.sort((a, b) =&gt; a - b);  return args;&#125;const sortNumber = currying(sort);console.log(sortNumber(3, 2, - 1, 0, 5, 4)())\n\n\n\n如果想让每次执行 add()  都能返回结果。则进行如下改进：\nfunction add() &#123;  let args = Array.prototype.slice.call(arguments);  return args.reduce(function (a, b) &#123;    return a + b;  &#125;, 0);&#125;function currying(fn) &#123;  let args = [];  const adder = function () &#123;    [].push.apply(args, arguments);    return fn.apply(this, args)  &#125;  return adder;&#125;add = currying(add);console.log(add(1)) // 1console.log(add(2)) // 3console.log(add(3)) // 6console.log(add()) \t// 6\n\n\n\n","categories":["源码"],"tags":["原理"]},{"title":"重写与this有关的方法和关键字","url":"/2021/10/08/%E4%B8%8Ethis%E6%9C%89%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97/","content":"\n\n\ncall&#x2F;apply&#x2F;bind&#x2F;typeof&#x2F;new&#x2F;instanceof 的实现1.call&#x2F;apply&#x2F;bind方法的调用：// callfn.call(obj, param1, param2, ...param3)// applyfn.apply(obj, [param1, param2, ...param3])// bindfn.bind(obj, param1, param2)(...param3);\n\n\n\ncall方法的实现先看看call方法的具体调用案例\n第一个参数为null/undefined时， this 指向 window\n\nfunction test() &#123;  console.log(this) // window&#125;test.call();\n\n\n第一个参数为bool/number/string 类型时，this 指向 对应的包装类\n\nfunction test() &#123;  console.log(this) // Number &#123;1&#125; &#125;test.call(1);function test() &#123;  console.log(this) // String &#123;&#x27;1&#x27;&#125;&#125;test.call(&#x27;1&#x27;);function test() &#123;  console.log(this) // Boolean &#123;false&#125;&#125;test.call(false);\n\n\n被调用的函数，会有一个返回值。并且内部的 this 指向第一个参数\n\nfunction test(a) &#123;  return a + this.name&#125;const obj = &#123;  name: &#x27;JS&#x27;&#125;const res = test.call(obj, &#x27;Hello &#x27;);console.log(res) // &#x27;Hello JS&#x27;\n\n\n\n实现思路：\n判断是否有第一个参数，有则使用对象进行包装，否则为window。\n原方法内部的 this 要指向 当前传入的 第一个参数。\n特性：谁调用方法，方法内部的 this 就指向谁；this &#x3D;&gt; 原方法\n使用一个变量，保存this，以便后面调用它\n\n\n将重写 call 方法的 arguments 参数 传入到 原方法中，并执行该方法。\n利用evel方法执行；\n\n\n最后将执行结果返回。\n\n最终代码：Function.prototype.myCall = function(ctx) &#123;  // 如果第一个参数为空，this指向window，否则指向该参数对象  ctx = ctx ? Object(ctx) : window;  // 依据：谁调用方法，方法内部的 this 就指向谁；  // this 就是call 方法的调用者，赋值给一个变量，以便后面调用它  ctx[&#x27;originFn&#x27;] = this;    const args = [] // =&gt; [&#x27;arguments[1]&#x27;, &#x27;arguments[2]&#x27;]  for (let i = 1; i &lt; arguments.length; i++) &#123;    args.push(&#x27;arguments[&#x27; + i + &#x27;]&#x27;)  &#125;  // 执行 ctx.fn，传入参数，并接收函数返回值  // =&gt; ctx[&#x27;originFn&#x27;](&#x27;arguments[1]&#x27;, &#x27;arguments[2]&#x27;)  let res = eval(&quot;ctx.originFn(&quot; + args + &quot;)&quot;)   delete ctx.originFn;  return res;&#125;\n\n\n\napply 方法的实现与call方法高度相似，但有一下几点区别：\n如果第二个参数为object/function/null/undefined，则arguments.length = 0\n第二个参数为string/number/boolean类型，会报错: Uncaught TypeError: CreateListFromArrayLike called on non-object\n只取第二个参数，且必须为数组\n\n实现思路：\n判断是否有第一个参数，有则使用对象进行包装，否则为window。\n\n原方法内部的 this 要指向 当前传入的 第一个参数。\n\n特性：谁调用方法，方法内部的 this 就指向谁；this &#x3D;&gt; 原方法\n使用一个变量，保存this，以便后面调用它\n\n\n判断第二个参数的类型，如果不是数组则做一下处理：\n\nstring/number/boolean，则抛出异常。\nobject/function/null/undefined， 执行原始方法并返回结果，结束执行。\n\n\n将重写 apply 方法的 arguments 参数 传入到 原方法中，并执行该方法。\n\n利用evel方法执行；\n\n\n利用evel方法执行；\n\n\n最终代码：function typeOf (value) &#123;  if(value) &#123;    const key = (&#123;&#125;).toString.call(value);    const res = &#123;      &#x27;[object String]&#x27;: &#x27;String&#x27;,      &#x27;[object Number]&#x27;: &#x27;Number&#x27;,      &#x27;[object Boolean]&#x27;: &#x27;Boolean&#x27;,      &#x27;[object Object]&#x27;: &#x27;Object&#x27;,      &#x27;[object Array]&#x27;: &#x27;Array&#x27;,      &#x27;[object Function]&#x27;: &#x27;Function&#x27;,    &#125;    return res[key];  &#125; else &#123;    return typeof value;  &#125;&#125;Function.prototype.myApply = function (ctx, args) &#123;  // 如果第一个参数为空，this指向window，否则指向该参数对象  ctx = ctx ? Object(ctx) : window;    // 依据：谁调用方法，方法内部的 this 就指向谁；  // this 就是apply 方法的调用者，赋值给一个变量，以便后面调用它  ctx.originFn = this;\t  // 参数为字符串、数字、bool类型时报错  if (    \t(typeof args === &#x27;string&#x27;) ||       (typeof args === &#x27;number&#x27;) ||       (typeof args === &#x27;boolean&#x27;)     ) &#123;    throw TypeError(&#x27;CreateListFromArrayLike called on non-object&#x27;)  &#125;    // 参数为空、或者不为Array类型时，直接执行方法并返回结果  if (!args || typeOf(args) !== &#x27;Array&#x27;) &#123;    const res = ctx.originFn();    delete ctx.originFn    return res;  &#125;  const tempArgs = []; // [&#x27;args1&#x27;, &#x27;args2&#x27;]  for (let i = 0; i &lt; args.length; i++) &#123;    tempArgs.push(&#x27;args[&#x27; + i + &#x27;]&#x27;);  &#125;  const res = eval(&#x27;ctx.originFn(&#x27; + tempArgs + &#x27;)&#x27;);  delete ctx.originFn;  return res;&#125;\n\n\n\nbind 方法的实现特点：\nfn.bind()方法返回一个新函数，且fn方法不执行；\nbind方法接收一部分参数，返回的新函数接收一部分参数；\n返回的新函数 newFn 的 this 指向 bind(obj) 传递的对象\n实例化返回的新函数，this 指向原函数fn构造出来的新实例\n实例应该继承fn构造函数函数上的原型\n\n最终代码：Function.prototype.myBind = function(thisObj) &#123;  let firstFn = this; // 保存test方法的实例  let args = [].slice.call(arguments, 1); // 获取第一个方法的参数，去掉第0个位置的参数  // 返回一个新的函数  let newFn = function () &#123;    // 获取第二个方法的参数，并与第一个方法的参数合并    let newArgs = [].slice.call(arguments);    // 运行第一个函数。如果新函数经过实例化，this指向新函数的实例对象；否则this指向第一个方法传递的对象（thisObj）    return firstFn.apply(this instanceof newFn ? this : thisObj, args.concat(newArgs));  &#125;  // 将第一个方法的原型 复制 给实例化对象，_tmpFn相当原型的中介  let _tmpFn = function () &#123;&#125;  _tmpFn.prototype = this.prototype;  newFn.prototype = new _tmpFn();  return newFn;&#125;function test(user, car) &#123;  console.log(user + &#x27;买了一辆&#x27; + car);  console.log(this, arguments);&#125;test.prototype.color = &#x27;红色&#x27;console.log(&#x27;=== myBind ===&#x27;);let T = test.myBind(obj2, &#x27;张三&#x27;);let newTest = new T(&#x27;玛莎拉蒂&#x27;);console.log(newTest.color);\n\n\n\n2.typeof 关键字typeof的限制总共只有6中，ES6之后有symbol\ntypeof &#x27;a&#x27; \t\t\t\t\t// &#x27;string&#x27;typeof 1\t\t\t\t\t\t// &#x27;number&#x27;typeof true\t\t\t\t\t// &#x27;boolean&#x27;typeof undefined\t\t// &#x27;undefined&#x27;typeof &#123;&#125;\t\t\t\t\t\t// &#x27;object&#x27;typeof null\t\t\t\t\t// &#x27;object&#x27;typeof new RegExp()\t// &#x27;object&#x27;typeof []\t\t\t\t\t\t// &#x27;object&#x27;typeof function()&#123;&#125; // &#x27;function&#x27;\n\n\n\n最终代码function typeOf (value) &#123;  if(value) &#123;    const key = (&#123;&#125;).toString.call(value);    const res = &#123;      &#x27;[object String]&#x27;: &#x27;String&#x27;,      &#x27;[object Number]&#x27;: &#x27;Number&#x27;,      &#x27;[object Boolean]&#x27;: &#x27;Boolean&#x27;,      &#x27;[object Object]&#x27;: &#x27;Object&#x27;,      &#x27;[object Array]&#x27;: &#x27;Array&#x27;,      &#x27;[object Function]&#x27;: &#x27;Function&#x27;,      &#x27;[object Null]&#x27;: &#x27;Null&#x27;,      &#x27;[object Undefined]&#x27;: &#x27;Undefined&#x27;,      &#x27;[object RegExp]&#x27;: &#x27;RegExp&#x27;,      &#x27;[object Date]&#x27;: &#x27;Date&#x27;,    &#125;    return res[key];  &#125; else &#123;    return typeof value;  &#125;&#125;\n\n\n\n\n\n3.new 关键字构造函数的特点：\n未实例化时，构造方法内部的this为 undefined（非严格模式为window）；\n实例化之后，构造方法内部的this 是一个空对象；\n实例化之后，构造方法内部的this的prototy 指向 构造函数的 prototype；\n实例化之后，会接收构造方法的返回值。\n\n// 1.未实例化时，构造方法内部的this为 undefined(非严格模式为window)function Test() &#123;  console.log(this)&#125;Test() // undefined// 2.实例化之后，构造方法内部的this 是一个空对象 new Test() // Test &#123;&#125;\n\n// 3.实例化之后，构造方法内部的this的proto 指向 构造函数的 prototypeTest.prototype.add = function () &#123;  return this.a + this.b;&#125;function Test() &#123;  console.log(this)&#125;new Test()\n\n下图为上述的输出结果：\n\n\n\n\n最终代码：function myNew () &#123;  // 第一个参数为构造函数  const constructor = [].shift.call(arguments);  // 实例化之后，构造方法内部的this 是一个空对象；  const _this = &#123;&#125;;  // 构造方法内部的 this 的 proto 指向 构造函数的 prototype  Object.setPrototypeOf(_this, constructor.prototype);\t  //执行构造函数，并传入参数  const res = constructor.apply(_this, arguments);  return typeOf(res) === &#x27;Object&#x27; ? res : _this;&#125;const test = myNew(Test, 1, 2);test.add();\n\n\n\n4.instanceoftarget instanceof Type\n\n特点:\n判定 target 是否是 Type的实例\ntarget 的原型 是否继承自 Type\n\n最终代码：function instanceOf(target, type) &#123;  type = type.prototype;  // target = target.__proto__  target = Object.getPrototypeOf(target)  while (true) &#123;    if (target === null) return false;    if (target === type) return true;    target = Object.getPrototypeOf(target)  &#125;&#125;[] instanceof Array \t\t// trueinstanceOf([], Array)\t\t// true[] instanceof Object\t\t// trueinstanceOf([], Object)\t// true\n\n\n\n\n\n\n\n\n\n\n\n","categories":["源码"],"tags":["原理"]},{"title":"函数防抖和节流","url":"/2021/06/13/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/","content":"\n\n函数防抖\n节流或是防抖：限制函数的执行次数\n\n概念节流（throttle）：减少一段时间的触发频率\n防抖（debounce）：通过setTimeout 的方式，在一定的时间间隔内，将多次触发变成一次触发\n应用场景节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……\n防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。\n区别节流：事件被触发、n秒内只执行一次事件处理函数\n防抖：n秒内触发事件，就重新计时，事件处理函数的程序将永远不被执行\n场景按钮的点击事件\n节流：设置1s的时间，每1s内，只会执行一次。\n防抖：设置1s的时间，操作间隔大于1s才会执行，否则不会。\n节流代码：function throttle(fn, delay) &#123;  let begin = 0;  return function () &#123;    let cur = new Date().getTime();    if (cur - begin &gt; delay) &#123; // 连续点击在节流时间内，则不执行      fn.apply(this, arguments);      begin = cur;    &#125;  &#125;&#125;\n\n\n\n防抖代码：第一次不执行:function debounce(fn, delay) &#123;  let t = null;  return function () &#123;    if (t) &#123;      clearTimeout(t);    &#125;    t = setTimeout(() =&gt; &#123;      fn.apply(this, arguments);    &#125;, delay)  &#125;&#125;\n\n\n\n第一次执行:function debounce(fn, delay) &#123;  let t;  return function () &#123;    if (t) &#123;      clearTimeout(t);    &#125;    if (!t) &#123; // 第一次t肯定为空      fn.apply(this, arguments);    &#125;    t = setTimeout(() =&gt; &#123;      t = null;  // delay 间隔后重置，再次点击时又是第一次    &#125;, delay)  &#125;&#125;\n\n\n\n通过开关控制第一次是否执行：function debounce(fn, delay, triggleNow) &#123;  let t;  return function () &#123;    if (t) &#123;      clearTimeout(t);    &#125;    if (triggleNow) &#123;      if (!t) &#123; // 第一次点击        fn.apply(this, arguments);      &#125;      t = setTimeout(() =&gt; &#123;        t = null;  // delay 间隔后重置，再次点击时又是第一次      &#125;, delay)    &#125; else &#123;      t = setTimeout(() =&gt; &#123;        fn.apply(this, arguments);      &#125;, delay)    &#125;  &#125;&#125;\n\n","categories":["源码"],"tags":["原理"]},{"title":"TypeScript基础","url":"/2021/11/13/TypeScript%E5%9F%BA%E7%A1%80/","content":"\n\n一、原始类型：avaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。\n原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。\n基础类型原始数据类型在 TypeScript 中的应用。\n使用构造函数 Boolean 创造的对象不是布尔值：\nlet createdByNewBoolean: boolean = new Boolean(1);// Type &#x27;Boolean&#x27; is not assignable to type &#x27;boolean&#x27;.// &#x27;boolean&#x27; is a primitive, but &#x27;Boolean&#x27; is a wrapper object. Prefer using &#x27;boolean&#x27; when possible.\n\n事实上 new Boolean() 返回的是一个 Boolean 对象：\nlet createdByNewBoolean: Boolean = new Boolean(1);\n\n直接调用 Boolean 也可以返回一个 boolean 类型：\nlet createdByBoolean: boolean = Boolean(1);\n\n\n\n空值JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：\nfunction alertName(): void &#123;    alert(&#x27;My name is Tom&#x27;);&#125;\n\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null\nlet unusable: void = undefined;\n\n\n\nNull 和 Undefined在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\nlet u: undefined = undefined;let n: null = null;\n\n与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n// 这样不会报错let num: number = undefined;\n\n// 这样也不会报错let u: undefined;let num: number = u;\n\n而 void 类型的变量不能赋值给 number 类型的变量：\nlet u: void;let num: number = u;// Type &#x27;void&#x27; is not assignable to type &#x27;number&#x27;.\n\n\n\n联合类型联合类型（Union Types）表示取值可以为多种类型中的一种。\nlet myFavoriteNumber: string | number;myFavoriteNumber = &#x27;seven&#x27;;myFavoriteNumber = 7;\n\n访问联合类型的属性或方法当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：\nfunction getLength(something: string | number): number &#123;    return something.length;&#125;// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.// Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.\n\n上例中，length 不是 string 和 number 的共有属性，所以会报错。\n访问 string 和 number 的共有属性是没问题的：\nfunction getString(something: string | number): string &#123;    return something.toString();&#125;\n\n联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：\nlet myFavoriteNumber: string | number;myFavoriteNumber = &#x27;seven&#x27;;console.log(myFavoriteNumber.length); // 5myFavoriteNumber = 7;console.log(myFavoriteNumber.length); // 编译时报错// index.ts(5,30): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.\n\n上例中，第二行的 myFavoriteNumber 被推断成了 string，访问它的 length 属性不会报错。\n而第四行的 myFavoriteNumber 被推断成了 number，访问它的 length 属性时就报错了。\n二、对象的类型——接口在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。\n简单的列子：\ninterface Person &#123;    name: string;    age: number;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;,    age: 25&#125;;\n\n定义的变量比接口少了一些属性是不允许的：\ninterface Person &#123;    name: string;    age: number;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;&#125;;// index.ts(6,5): error TS2322: Type &#x27;&#123; name: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.//   Property &#x27;age&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27;.\n\n多一些属性也是不允许的：\ninterface Person &#123;    name: string;    age: number;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;,    age: 25,    gender: &#x27;male&#x27;&#125;;// index.ts(9,5): error TS2322: Type &#x27;&#123; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.//   Object literal may only specify known properties, and &#x27;gender&#x27; does not exist in type &#x27;Person&#x27;.\n\n可见，赋值的时候，变量的形状必须和接口的形状保持一致。\n可选属性有时我们希望不要完全匹配一个形状，那么可以用可选属性：\n// 可选属性的含义是该属性可以不存在。interface Person &#123;    name: string;    age?: number;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;&#125;;// orlet tom: Person = &#123;    name: &#x27;Tom&#x27;,    age: 25&#125;;\n\n\n\n任意属性interface Person &#123;    name: string;    age?: number;    [propName: string]: any;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;,    gender: &#x27;male&#x27;&#125;;\n\n使用 [propName: string] 定义了任意属性取 string 类型的值。\n需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：\ninterface Person &#123;    name: string;    age?: number;    [propName: string]: string;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;,    age: 25,    gender: &#x27;male&#x27;&#125;;// index.ts(3,5): error TS2411: Property &#x27;age&#x27; of type &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.// index.ts(7,5): error TS2322: Type &#x27;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.//   Index signatures are incompatible.//     Type &#x27;string | number&#x27; is not assignable to type &#x27;string&#x27;.//       Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.\n\n上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。\n一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\ninterface Person &#123;    name: string;    age?: number;    [propName: string]: string | number;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;,    age: 25,    gender: &#x27;male&#x27;&#125;;\n\n\n\n只读属性interface Person &#123;    readonly id: number;    name: string;    age?: number;    [propName: string]: any;&#125;let tom: Person = &#123;    id: 89757,    name: &#x27;Tom&#x27;,    gender: &#x27;male&#x27;&#125;;tom.id = 9527;// index.ts(14,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.\n\n只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：\ninterface Person &#123;    readonly id: number;    name: string;    age?: number;    [propName: string]: any;&#125;let tom: Person = &#123;    name: &#x27;Tom&#x27;,    gender: &#x27;male&#x27;&#125;;tom.id = 89757;// index.ts(8,5): error TS2322: Type &#x27;&#123; name: string; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.//   Property &#x27;id&#x27; is missing in type &#x27;&#123; name: string; gender: string; &#125;&#x27;.// index.ts(13,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.\n\n上例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。\n第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了。\n三、数组的类型表示法「类型 + 方括号」数组的项中不允许出现其他的类型：\nlet fibonacci: number[] = [1, &#x27;1&#x27;, 2, 3, 5];// Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.\n\n数组泛型let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];\n\n用接口表示数组interface NumberArray &#123;    [index: number]: number;&#125;let fibonacci: NumberArray = [1, 1, 2, 3, 5];\n\n虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。\n类数组function sum() &#123;    let args: number[] = arguments;&#125;// Type &#x27;IArguments&#x27; is missing the following properties from type &#x27;number[]&#x27;: pop, push, concat, join, and 24 more.\n\narguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：\nfunction sum() &#123;    let args: &#123;        [index: number]: number;        length: number;        callee: Function;    &#125; = arguments;&#125;\n\n事实上常用的类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection 等：\nfunction sum() &#123;    let args: IArguments = arguments;&#125;\n\n\n\n四、函数类型一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：\nfunction sum(x: number, y: number): number &#123;    return x + y;&#125;\n\n输入多余的（或者少于要求的）参数，是不被允许的：\nfunction sum(x: number, y: number): number &#123;    return x + y;&#125;sum(1, 2, 3);// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.sum(1);// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.\n\n\n\n函数表达式如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样：\nlet mySum = function (x: number, y: number): number &#123;    return x + y;&#125;;\n\n这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样：\nlet mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123;    return x + y;&#125;;\n\n注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。\n在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。\n用接口定义函数的形状interface SearchFunc &#123;    (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123;    return source.search(subString) !== -1;&#125;\n\n采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。\n参数可选参数：可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了：\nfunction buildName(firstName?: string, lastName: string) &#123;    if (firstName) &#123;        return firstName + &#x27; &#x27; + lastName;    &#125; else &#123;        return lastName;    &#125;&#125;let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);let tom = buildName(undefined, &#x27;Tom&#x27;);// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.\n\n\n\n参数默认值：TypeScript 会将添加了默认值的参数识别为可选参数：\nfunction buildName(firstName: string, lastName: string = &#x27;Cat&#x27;) &#123;    return firstName + &#x27; &#x27; + lastName;&#125;let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);let tom = buildName(&#x27;Tom&#x27;);\n\n此时就不受「可选参数必须接在必需参数后面」的限制了：\nfunction buildName(firstName: string = &#x27;Tom&#x27;, lastName: string) &#123;    return firstName + &#x27; &#x27; + lastName;&#125;let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);let cat = buildName(undefined, &#x27;Cat&#x27;);\n\n\n\n剩余参数：function push(array: any[], ...items: any[]) &#123;    items.forEach(function(item) &#123;        array.push(item);    &#125;);&#125;let a = [];push(a, 1, 2, 3);\n\n注意，rest 参数只能是最后一个参数。\n重载重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\nfunction reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string | void &#123;    if (typeof x === &#x27;number&#x27;) &#123;        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));    &#125; else if (typeof x === &#x27;string&#x27;) &#123;        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);    &#125;&#125;\n\n上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。\n五、类型断言类型断言（Type Assertion）可以用来手动指定一个值的类型。\n语法值 as 类型\n\n或\n&lt;类型&gt;值\n\n在 tsx 语法（React 的 jsx 语法的 ts 版）中必须使用前者，即 值 as 类型。\n建议大家在使用类型断言时，统一使用 值 as 类型 这样的语法\n用途1.将一个联合类型断言为其中一个类型当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的属性或方法：\ninterface Cat &#123;    name: string;    run(): void;&#125;interface Fish &#123;    name: string;    swim(): void;&#125;function getName(animal: Cat | Fish) &#123;    return animal.name;&#125;\n\n而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如：\ninterface Cat &#123;    name: string;    run(): void;&#125;interface Fish &#123;    name: string;    swim(): void;&#125;function isFish(animal: Cat | Fish) &#123;    if (typeof animal.swim === &#x27;function&#x27;) &#123;        return true;    &#125;    return false;&#125;// index.ts:11:23 - error TS2339: Property &#x27;swim&#x27; does not exist on type &#x27;Cat | Fish&#x27;.//   Property &#x27;swim&#x27; does not exist on type &#x27;Cat&#x27;.\n\n此时可以使用类型断言，将 animal 断言成 Fish：\ninterface Cat &#123;    name: string;    run(): void;&#125;interface Fish &#123;    name: string;    swim(): void;&#125;function isFish(animal: Cat | Fish) &#123;    if (typeof (animal as Fish).swim === &#x27;function&#x27;) &#123;        return true;    &#125;    return false;&#125;\n\n需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：\ninterface Cat &#123;    name: string;    run(): void;&#125;interface Fish &#123;    name: string;    swim(): void;&#125;function swim(animal: Cat | Fish) &#123;    (animal as Fish).swim();&#125;const tom: Cat = &#123;    name: &#x27;Tom&#x27;,    run() &#123; console.log(&#x27;run&#x27;) &#125;&#125;;swim(tom);// Uncaught TypeError: animal.swim is not a function`\n\n上面的例子编译时不会报错，但在运行时会报错：\nUncaught TypeError: animal.swim is not a function`\n\n原因是 (animal as Fish).swim() 这段代码隐藏了 animal 可能为 Cat 的情况，将 animal 直接断言为 Fish 了，而 TypeScript 编译器信任了我们的断言，故在调用 swim() 时没有编译错误。\n可是 swim 函数接受的参数是 Cat | Fish，一旦传入的参数是 Cat 类型的变量，由于 Cat 上没有 swim 方法，就会导致运行时错误了。\n2.将一个父类断言为更加具体的子类当类之间有继承关系时，类型断言也是很常见的：\nclass ApiError extends Error &#123;    code: number = 0;&#125;class HttpError extends Error &#123;    statusCode: number = 200;&#125;function isApiError(error: Error) &#123;    if (typeof (error as ApiError).code === &#x27;number&#x27;) &#123;        return true;    &#125;    return false;&#125;\n\n大家可能会注意到，在这个例子中有一个更合适的方式来判断是不是 ApiError，那就是使用 instanceof：\nclass ApiError extends Error &#123;    code: number = 0;&#125;class HttpError extends Error &#123;    statusCode: number = 200;&#125;function isApiError(error: Error) &#123;    if (error instanceof ApiError) &#123;        return true;    &#125;    return false;&#125;\n\n上面的例子中，确实使用 instanceof 更加合适，因为 ApiError 是一个 JavaScript 的类，能够通过 instanceof 来判断 error 是否是它的实例。\n但是有的情况下 ApiError 和 HttpError 不是一个真正的类，而只是一个 TypeScript 的接口（interface），接口是一个类型，不是一个真正的值，它在编译结果中会被删除，当然就无法使用 instanceof 来做运行时判断了：\ninterface ApiError extends Error &#123;    code: number;&#125;interface HttpError extends Error &#123;    statusCode: number;&#125;function isApiError(error: Error) &#123;    if (error instanceof ApiError) &#123;        return true;    &#125;    return false;&#125;// index.ts:9:26 - error TS2693: &#x27;ApiError&#x27; only refers to a type, but is being used as a value here.\n\n此时就只能用类型断言，通过判断是否存在 code 属性，来判断传入的参数是不是 ApiError 了：\ninterface ApiError extends Error &#123;    code: number;&#125;interface HttpError extends Error &#123;    statusCode: number;&#125;function isApiError(error: Error) &#123;    if (typeof (error as ApiError).code === &#x27;number&#x27;) &#123;        return true;    &#125;    return false;&#125;\n\n\n\n3.将任何一个类型断言为 anywindow.foo = 1;// index.ts:1:8 - error TS2339: Property &#x27;foo&#x27; does not exist on type &#x27;Window &amp; typeof globalThis&#x27;.\n\n上面的例子中，我们需要将 window 上添加一个属性 foo，但 TypeScript 编译时会报错，提示我们 window 上不存在 foo 属性。\n此时我们可以使用 as any 临时将 window 断言为 any 类型：\n(window as any).foo = 1;\n\n在 any 类型的变量上，访问任何属性都是允许的。\n需要注意的是，将一个变量断言为 any 可以说是解决 TypeScript 中类型问题的最后一个手段。\n它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 as any。\n4.将 any 断言为一个具体的类型遇到 any 类型的变量时，我们可以选择无视它，任由它滋生更多的 any。\n我们也可以选择改进它，通过类型断言及时的把 any 断言为精确的类型，亡羊补牢，使我们的代码向着高可维护性的目标发展。\n举例来说，历史遗留的代码中有个 getCacheData，它的返回值是 any：\nfunction getCacheData(key: string): any &#123;    return (window as any).cache[key];&#125;\n\n那么我们在使用它时，最好能够将调用了它之后的返回值断言成一个精确的类型，这样就方便了后续的操作：\nfunction getCacheData(key: string): any &#123;    return (window as any).cache[key];&#125;interface Cat &#123;    name: string;    run(): void;&#125;const tom = getCacheData(&#x27;tom&#x27;) as Cat;tom.run();\n\n上面的例子中，我们调用完 getCacheData 之后，立即将它断言为 Cat 类型。这样的话明确了 tom 的类型，后续对 tom 的访问时就有了代码补全，提高了代码的可维护性。\n限制那么类型断言有没有什么限制呢？是不是任何一个类型都可以被断言为任何另一个类型呢？\n答案是否定的——并不是任何一个类型都可以被断言为任何另一个类型。\n具体来说，若 A 兼容 B，那么 A 能够被断言为 B，B 也能被断言为 A。\n下面我们通过一个简化的例子，来理解类型断言的限制：\ninterface Animal &#123;    name: string;&#125;interface Cat &#123;    name: string;    run(): void;&#125;let tom: Cat = &#123;    name: &#x27;Tom&#x27;,    run: () =&gt; &#123; console.log(&#x27;run&#x27;) &#125;&#125;;let animal: Animal = tom;\n\n在上面的例子中，Cat 包含了 Animal 中的所有属性，除此之外，它还有一个额外的方法 run。\nTypeScript 并不关心 Cat 和 Animal 之间定义时是什么关系，而只会看它们最终的结构有什么关系——所以它与 Cat extends Animal 是等价的：\ninterface Animal &#123;    name: string;&#125;interface Cat extends Animal &#123;    run(): void;&#125;\n\n那么也不难理解为什么 Cat 类型的 tom 可以赋值给 Animal 类型的 animal 了——就像面向对象编程中我们可以将子类的实例赋值给类型为父类的变量。\n我们把它换成 TypeScript 中更专业的说法，即：Animal 兼容 Cat。\n当 Animal 兼容 Cat 时，它们就可以互相进行类型断言了：\ninterface Animal &#123;    name: string;&#125;interface Cat &#123;    name: string;    run(): void;&#125;function testAnimal(animal: Animal) &#123;    return (animal as Cat);&#125;function testCat(cat: Cat) &#123;    return (cat as Animal);&#125;\n\n这样的设计其实也很容易就能理解：\n\n允许 animal as Cat 是因为「父类可以被断言为子类」，这个前面已经学习过了\n允许 cat as Animal 是因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性、调用父类的方法，就不会有任何问题，故「子类可以被断言为父类」\n\n总之，若 A 兼容 B，那么 A 能够被断言为 B，B 也能被断言为 A。\n同理，若 B 兼容 A，那么 A 能够被断言为 B，B 也能被断言为 A。\n综上所述：\n\n联合类型可以被断言为其中一个类型\n父类可以被断言为子类\n任何类型都可以被断言为 any\nany 可以被断言为任何类型\n要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可\n\n其实前四种情况都是最后一个的特例。\n双重断言既然：\n\n任何类型都可以被断言为 any\nany 可以被断言为任何类型\n\n那么我们是不是可以使用双重断言 as any as Foo 来将任何一个类型断言为任何另一个类型呢？\ninterface Cat &#123;    run(): void;&#125;interface Fish &#123;    swim(): void;&#125;function testCat(cat: Cat) &#123;    return (cat as any as Fish);&#125;\n\n在上面的例子中，若直接使用 cat as Fish 肯定会报错，因为 Cat 和 Fish 互相都不兼容。\n但是若使用双重断言，则可以打破「要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可」的限制，将任何一个类型断言为任何另一个类型。\n若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。\n除非迫不得已，千万别用双重断言。\n类型断言 vs 类型转换类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除：\nfunction toBoolean(something: any): boolean &#123;    return something as boolean;&#125;toBoolean(1);// 返回值为 1\n\n在上面的例子中，将 something 断言为 boolean 虽然可以通过编译，但是并没有什么用，代码在编译后会变成：\nfunction toBoolean(something) &#123;    return something;&#125;toBoolean(1);// 返回值为 1\n\n所以类型断言不是类型转换，它不会真的影响到变量的类型。\n若要进行类型转换，需要直接调用类型转换的方法：\nfunction toBoolean(something: any): boolean &#123;    return Boolean(something);&#125;toBoolean(1);// 返回值为 true\n\n\n\nkeyof 类型操作符对一个对象类型使用 keyof 操作符，会返回该&#x3D;&#x3D;对象属性名组成的一个字符串或者数字字面量的联合&#x3D;&#x3D;。\n这个例子中的类型 P 就等同于 “x” | “y”：\ntype Point = &#123; x: number; y: number &#125;;type P = keyof Point;// type P =  &quot;x&quot; | &quot;y&quot;\n\n但如果这个类型有一个 string 或者 number 类型的索引签名，keyof 则会直接返回这些类型：\ntype Arrayish = &#123; [n: number]: unknown &#125;;type A = keyof Arrayish;// type A = numbertype Mapish = &#123; [k: string]: boolean &#125;;type M = keyof Mapish;// type M = string | number\n\n注意在这个例子中，M 是 string | number，这是因为 JavaScript 对象的属性名会被强制转为一个字符串，所以 obj[0] 和 obj[&quot;0&quot;] 是一样的。\ntypeof类型操作符 TypeScript 添加的 typeof 方法可以在类型上下文（type context）中使用，用于&#x3D;&#x3D;获取一个变量或者属性的类型&#x3D;&#x3D;。\nlet s = &quot;hello&quot;;let n: typeof s;// let n: string\n\n对对象使用 typeof：\nconst person = &#123; name: &quot;kevin&quot;, age: &quot;18&quot; &#125;type Kevin = typeof person;// type Kevin = &#123;// \t\tname: string;// \t\tage: string;// &#125;\n\n对函数使用 typeof：\nfunction identity&lt;Type&gt;(arg: Type): Type &#123;  return arg;&#125;type result = typeof identity;// type result = &lt;Type&gt;(arg: Type) =&gt; Type\n\n对 enum 使用 typeof：\nenum UserResponse &#123;  No = 0,  Yes = 1,&#125;type result = typeof UserResponse;// okconst a: result = &#123;      &quot;No&quot;: 2,      &quot;Yes&quot;: 3&#125;result 类型类似于：// &#123;//\t&quot;No&quot;: number,//  &quot;YES&quot;: number// &#125;\n\n不过对一个 enum 类型只使用 typeof 一般没什么用，通常还会搭配 keyof 操作符用于获取属性名的联合字符串：\ntype result = keyof typeof UserResponse;// type result = &quot;No&quot; | &quot;Yes&quot;\n\n","categories":["TS"],"tags":["JS"]},{"title":"TypeScript进阶","url":"/2021/11/29/TypeScript%E8%BF%9B%E9%98%B6/","content":"\n\n类型别名类型别名用来给一个类型起个新名字。\ntype Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123;    if (typeof n === &#x27;string&#x27;) &#123;        return n;    &#125; else &#123;        return n();    &#125;&#125;\n\n\n\n字符串字面量类型字符串字面量类型用来约束取值只能是某几个字符串中的一个。\ntype EventNames = &#x27;click&#x27; | &#x27;scroll&#x27; | &#x27;mousemove&#x27;;function handleEvent(ele: Element, event: EventNames) &#123;    // do something&#125;handleEvent(document.getElementById(&#x27;hello&#x27;), &#x27;scroll&#x27;);  // 没问题handleEvent(document.getElementById(&#x27;world&#x27;), &#x27;dblclick&#x27;); // 报错，event 不能为 &#x27;dblclick&#x27;// index.ts(7,47): error TS2345: Argument of type &#x27;&quot;dblclick&quot;&#x27; is not assignable to parameter of type &#x27;EventNames&#x27;.\n\n上例中，我们使用 type 定了一个字符串字面量类型 EventNames，它只能取三种字符串中的一种。\n注意，类型别名与字符串字面量类型都是使用 type 进行定义。\n元组数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。\nlet tom: [string, number] = [&#x27;Tom&#x27;, 25];\n\n可以只赋值其中一项：\nlet tom: [string, number];tom[0] = &#x27;Tom&#x27;;\n\n但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。\nlet tom: [string, number];tom = [&#x27;Tom&#x27;, 25];\n\nlet tom: [string, number];tom = [&#x27;Tom&#x27;];// Property &#x27;1&#x27; is missing in type &#x27;[string]&#x27; but required in type &#x27;[string, number]&#x27;.\n\n\n\n枚举枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等\n枚举使用 enum 关键字来定义：\nenum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;\n\n枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：\nenum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days[&quot;Sun&quot;] === 0); // trueconsole.log(Days[&quot;Mon&quot;] === 1); // trueconsole.log(Days[&quot;Tue&quot;] === 2); // trueconsole.log(Days[&quot;Sat&quot;] === 6); // trueconsole.log(Days[0] === &quot;Sun&quot;); // trueconsole.log(Days[1] === &quot;Mon&quot;); // trueconsole.log(Days[2] === &quot;Tue&quot;); // trueconsole.log(Days[6] === &quot;Sat&quot;); // true\n\n我们也可以给枚举项手动赋值：\nenum Days &#123;Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days[&quot;Sun&quot;] === 7); // trueconsole.log(Days[&quot;Mon&quot;] === 1); // trueconsole.log(Days[&quot;Tue&quot;] === 2); // trueconsole.log(Days[&quot;Sat&quot;] === 6); // true\n\n上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增。\n如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的：\nenum Days &#123;Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days[&quot;Sun&quot;] === 3); // trueconsole.log(Days[&quot;Wed&quot;] === 3); // trueconsole.log(Days[3] === &quot;Sun&quot;); // falseconsole.log(Days[3] === &quot;Wed&quot;); // true\n\n上面的例子中，递增到 3 的时候与前面的 Sun 的取值重复了，但是 TypeScript 并没有报错，导致 Days[3] 的值先是 &quot;Sun&quot;，而后又被 &quot;Wed&quot; 覆盖了。编译的结果是：\n类类的概念\n类（Class）：定义了一件事物的抽象特点，包含它的属性和方法\n对象（Object）：类的实例，通过 new 生成\n面向对象（OOP）的三大特性：封装、继承、多态\n封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据\n继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性\n多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat\n存取器（getter &amp; setter）：用以改变属性的读取和赋值行为\n修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法\n抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现\n接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口\n\nES6 中类的用法属性和方法使用 class 定义类，使用 constructor 定义构造函数。\n通过 new 生成新实例的时候，会自动调用构造函数。\nclass Animal &#123;    public name;    constructor(name) &#123;        this.name = name;    &#125;    sayHi() &#123;        return `My name is $&#123;this.name&#125;`;    &#125;&#125;let a = new Animal(&#x27;Jack&#x27;);console.log(a.sayHi()); // My name is Jack\n\n类的继承使用 extends 关键字实现继承，子类中使用 super 关键字来调用父类的构造函数和方法。\nclass Cat extends Animal &#123;  constructor(name) &#123;    super(name); // 调用父类的 constructor(name)    console.log(this.name);  &#125;  sayHi() &#123;    return &#x27;Meow, &#x27; + super.sayHi(); // 调用父类的 sayHi()  &#125;&#125;let c = new Cat(&#x27;Tom&#x27;); // Tomconsole.log(c.sayHi()); // Meow, My name is Tom\n\n\n\n存取器使用 getter 和 setter 可以改变属性的赋值和读取行为：\nclass Animal &#123;  constructor(name) &#123;    this.name = name;  &#125;  get name() &#123;    return &#x27;Jack&#x27;;  &#125;  set name(value) &#123;    console.log(&#x27;setter: &#x27; + value);  &#125;&#125;let a = new Animal(&#x27;Kitty&#x27;); // setter: Kittya.name = &#x27;Tom&#x27;; // setter: Tomconsole.log(a.name); // Jack\n\n\n\n静态方法使用 static 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用：\nclass Animal &#123;  static isAnimal(a) &#123;    return a instanceof Animal;  &#125;&#125;let a = new Animal(&#x27;Jack&#x27;);Animal.isAnimal(a); // truea.isAnimal(a); // TypeError: a.isAnimal is not a function\n\n\n\nES7 中类的用法ES7 中有一些关于类的提案，TypeScript 也实现了它们，这里做一个简单的介绍。\n实例属性ES6 中实例的属性只能通过构造函数中的 this.xxx 来定义，ES7 提案中可以直接在类里面定义：\nclass Animal &#123;  name = &#x27;Jack&#x27;;  constructor() &#123;    // ...  &#125;&#125;let a = new Animal();console.log(a.name); // Jack\n\n静态属性ES7 提案中，可以使用 static 定义一个静态属性：\nclass Animal &#123;  static num = 42;  constructor() &#123;    // ...  &#125;&#125;console.log(Animal.num); // 42\n\n\n\nTypeScript 中类的用法public private 和 protected\npublic 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的\nprivate 修饰的属性或方法是私有的，不能在声明它的类的外部访问\nprotected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的\n\n很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 private 了：\nclass Animal &#123;  private name;  public constructor(name) &#123;    this.name = name;  &#125;&#125;let a = new Animal(&#x27;Jack&#x27;);console.log(a.name);a.name = &#x27;Tom&#x27;;// index.ts(9,13): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.// index.ts(10,1): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.\n\n使用 private 修饰的属性或方法，在子类中也是不允许访问的：\nclass Animal &#123;  private name;  public constructor(name) &#123;    this.name = name;  &#125;&#125;class Cat extends Animal &#123;  constructor(name) &#123;    super(name);    console.log(this.name);  &#125;&#125;// index.ts(11,17): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.\n\n而如果是用 protected 修饰，则允许在子类中访问：\nclass Animal &#123;  protected name;  public constructor(name) &#123;    this.name = name;  &#125;&#125;class Cat extends Animal &#123;  constructor(name) &#123;    super(name);    console.log(this.name);  &#125;&#125;\n\n当构造函数修饰为 private 时，该类不允许被继承或者实例化：\nclass Animal &#123;  public name;  private constructor(name) &#123;    this.name = name;  &#125;&#125;class Cat extends Animal &#123;  constructor(name) &#123;    super(name);  &#125;&#125;let a = new Animal(&#x27;Jack&#x27;);// index.ts(7,19): TS2675: Cannot extend a class &#x27;Animal&#x27;. Class constructor is marked as private.// index.ts(13,9): TS2673: Constructor of class &#x27;Animal&#x27; is private and only accessible within the class declaration.\n\n当构造函数修饰为 protected 时，该类只允许被继承：\nclass Animal &#123;  public name;  protected constructor(name) &#123;    this.name = name;  &#125;&#125;class Cat extends Animal &#123;  constructor(name) &#123;    super(name);  &#125;&#125;let a = new Animal(&#x27;Jack&#x27;);// index.ts(13,9): TS2674: Constructor of class &#x27;Animal&#x27; is protected and only accessible within the class declaration.\n\n\n\n参数属性修饰符和readonly还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。\nclass Animal &#123;  // public name: string;  public constructor(public name) &#123;    // this.name = name;  &#125;&#125;\n\n\n\nreadonly只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。\nclass Animal &#123;  readonly name;  public constructor(name) &#123;    this.name = name;  &#125;&#125;let a = new Animal(&#x27;Jack&#x27;);console.log(a.name); // Jacka.name = &#x27;Tom&#x27;;// index.ts(10,3): TS2540: Cannot assign to &#x27;name&#x27; because it is a read-only property.\n\n注意如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面。\nclass Animal &#123;  // public readonly name;  public constructor(public readonly name) &#123;    // this.name = name;  &#125;&#125;\n\n\n\n抽象类abstract 用于定义抽象类和其中的抽象方法。\n首先，抽象类是不允许被实例化的：\nabstract class Animal &#123;  public name;  public constructor(name) &#123;    this.name = name;  &#125;  public abstract sayHi();&#125;let a = new Animal(&#x27;Jack&#x27;);// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class &#x27;Animal&#x27;.\n\n抽象类中的抽象方法必须被子类实现：\nabstract class Animal &#123;  public name;  public constructor(name) &#123;    this.name = name;  &#125;  public abstract sayHi();&#125;class Cat extends Animal &#123;  public eat() &#123;    console.log(`$&#123;this.name&#125; is eating.`);  &#125;&#125;let cat = new Cat(&#x27;Tom&#x27;);// index.ts(9,7): error TS2515: Non-abstract class &#x27;Cat&#x27; does not implement inherited abstract member &#x27;sayHi&#x27; from class &#x27;Animal&#x27;.\n\n上面的例子中，我们定义了一个类 Cat 继承了抽象类 Animal，但是没有实现抽象方法 sayHi，所以编译报错了。\n下面是一个正确使用抽象类的例子：\nabstract class Animal &#123;  public name;  public constructor(name) &#123;    this.name = name;  &#125;  public abstract sayHi();&#125;class Cat extends Animal &#123;  public sayHi() &#123;    console.log(`Meow, My name is $&#123;this.name&#125;`);  &#125;&#125;let cat = new Cat(&#x27;Tom&#x27;);\n\n\n\n类的类型给类加上 TypeScript 的类型很简单，与接口类似：\nclass Animal &#123;  name: string;  constructor(name: string) &#123;    this.name = name;  &#125;  sayHi(): string &#123;    return `My name is $&#123;this.name&#125;`;  &#125;&#125;let a: Animal = new Animal(&#x27;Jack&#x27;);console.log(a.sayHi()); // My name is Jack\n\n\n\n类与接口接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。\n另一个用途，是对类的一部分行为进行抽象\n类实现接口实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。\n举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：\ninterface Alarm &#123;    alert(): void;&#125;class Door &#123;&#125;class SecurityDoor extends Door implements Alarm &#123;    alert() &#123;        console.log(&#x27;SecurityDoor alert&#x27;);    &#125;&#125;class Car implements Alarm &#123;    alert() &#123;        console.log(&#x27;Car alert&#x27;);    &#125;&#125;\n\n一个类可以实现多个接口：\ninterface Alarm &#123;    alert(): void;&#125;interface Light &#123;    lightOn(): void;    lightOff(): void;&#125;class Car implements Alarm, Light &#123;    alert() &#123;        console.log(&#x27;Car alert&#x27;);    &#125;    lightOn() &#123;        console.log(&#x27;Car light on&#x27;);    &#125;    lightOff() &#123;        console.log(&#x27;Car light off&#x27;);    &#125;&#125;\n\n上例中，Car 实现了 Alarm 和 Light 接口，既能报警，也能开关车灯。\n接口继承接口接口与接口之间可以是继承关系：\ninterface Alarm &#123;    alert(): void;&#125;interface LightableAlarm extends Alarm &#123;    lightOn(): void;    lightOff(): void;&#125;\n\n这很好理解，LightableAlarm 继承了 Alarm，除了拥有 alert 方法之外，还拥有两个新方法 lightOn 和 lightOff。\n接口继承类常见的面向对象语言中，接口是不能继承类的，但是在 TypeScript 中却是可以的：\nclass Point &#123;    x: number;    y: number;    constructor(x: number, y: number) &#123;        this.x = x;        this.y = y;    &#125;&#125;interface Point3d extends Point &#123;    z: number;&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;;\n\n为什么 TypeScript 会支持接口继承类呢？\n实际上，当我们在声明 class Point 时，除了会创建一个名为 Point 的类之外，同时也创建了一个名为 Point 的类型（实例的类型）。\n所以我们既可以将 Point 当做一个类来用（使用 new Point 创建它的实例）：\nclass Point &#123;    x: number;    y: number;    constructor(x: number, y: number) &#123;        this.x = x;        this.y = y;    &#125;&#125;const p = new Point(1, 2);\n\n也可以将 Point 当做一个类型来用（使用 : Point 表示参数的类型）：\nclass Point &#123;    x: number;    y: number;    constructor(x: number, y: number) &#123;        this.x = x;        this.y = y;    &#125;&#125;function printPoint(p: Point) &#123;    console.log(p.x, p.y);&#125;printPoint(new Point(1, 2));\n\n这个例子实际上可以等价于：\nclass Point &#123;    x: number;    y: number;    constructor(x: number, y: number) &#123;        this.x = x;        this.y = y;    &#125;&#125;interface PointInstanceType &#123;    x: number;    y: number;&#125;function printPoint(p: PointInstanceType) &#123;    console.log(p.x, p.y);&#125;printPoint(new Point(1, 2));\n\n上例中我们新声明的 PointInstanceType 类型，与声明 class Point 时创建的 Point 类型是等价的。\n所以回到 Point3d 的例子中，我们就能很容易的理解为什么 TypeScript 会支持接口继承类了：\nclass Point &#123;    x: number;    y: number;    constructor(x: number, y: number) &#123;        this.x = x;        this.y = y;    &#125;&#125;interface PointInstanceType &#123;    x: number;    y: number;&#125;// 等价于 interface Point3d extends PointInstanceTypeinterface Point3d extends Point &#123;    z: number;&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;;\n\n当我们声明 interface Point3d extends Point 时，Point3d 继承的实际上是类 Point 的实例的类型。\n换句话说，可以理解为定义了一个接口 Point3d 继承另一个接口 PointInstanceType。\n所以「接口继承类」和「接口继承接口」没有什么本质的区别。\n值得注意的是，PointInstanceType 相比于 Point，缺少了 constructor 方法，这是因为声明 Point 类时创建的 Point 类型是不包含构造函数的。另外，除了构造函数是不包含的，静态属性或静态方法也是不包含的（实例的类型当然不应该包括构造函数、静态属性或静态方法）。\n换句话说，声明 Point 类时创建的 Point 类型只包含其中的实例属性和实例方法：\nclass Point &#123;    /** 静态属性，坐标系原点 */    static origin = new Point(0, 0);    /** 静态方法，计算与原点距离 */    static distanceToOrigin(p: Point) &#123;        return Math.sqrt(p.x * p.x + p.y * p.y);    &#125;    /** 实例属性，x 轴的值 */    x: number;    /** 实例属性，y 轴的值 */    y: number;    /** 构造函数 */    constructor(x: number, y: number) &#123;        this.x = x;        this.y = y;    &#125;    /** 实例方法，打印此点 */    printPoint() &#123;        console.log(this.x, this.y);    &#125;&#125;interface PointInstanceType &#123;    x: number;    y: number;    printPoint(): void;&#125;let p1: Point;let p2: PointInstanceType;\n\n上例中最后的类型 Point 和类型 PointInstanceType 是等价的。\n同样的，在接口继承类的时候，也只会继承它的实例属性和实例方法。\n泛型简单的例子首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：\nfunction createArray(length: number, value: any): Array&lt;any&gt; &#123;    let result = [];    for (let i = 0; i &lt; length; i++) &#123;        result[i] = value;    &#125;    return result;&#125;createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]\n\n上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。\n这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：\nArray&lt;any&gt; 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 value 的类型。\n这时候，泛型就派上用场了：\nfunction createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;    let result: T[] = [];    for (let i = 0; i &lt; length; i++) &#123;        result[i] = value;    &#125;    return result;&#125;createArray&lt;string&gt;(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]\n\n上例中，我们在函数名后添加了 &lt;T&gt;，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array&lt;T&gt; 中即可使用了。\n接着在调用的时候，可以指定它具体的类型为 string。当然，也可以不手动指定，而让类型推论自动推算出来：\nfunction createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;    let result: T[] = [];    for (let i = 0; i &lt; length; i++) &#123;        result[i] = value;    &#125;    return result;&#125;createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]\n\n\n\n多个类型参数定义泛型的时候，可以一次定义多个类型参数：\nfunction swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;    return [tuple[1], tuple[0]];&#125;swap([7, &#x27;seven&#x27;]); // [&#x27;seven&#x27;, 7]\n\n上例中，我们定义了一个 swap 函数，用来交换输入的元组。\n泛型约束在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：\nfunction loggingIdentity&lt;T&gt;(arg: T): T &#123;    console.log(arg.length);    return arg;&#125;// index.ts(2,19): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;T&#x27;.\n\n上例中，泛型 T 不一定包含属性 length，所以编译的时候报错了。\n这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。这就是泛型约束：\ninterface Lengthwise &#123;    length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;    console.log(arg.length);    return arg;&#125;\n\n上例中，我们使用了 extends 约束了泛型 T 必须符合接口 Lengthwise 的形状，也就是必须包含 length 属性。\n此时如果调用 loggingIdentity 的时候，传入的 arg 不包含 length，那么在编译阶段就会报错了：\ninterface Lengthwise &#123;    length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;    console.log(arg.length);    return arg;&#125;loggingIdentity(7);// index.ts(10,17): error TS2345: Argument of type &#x27;7&#x27; is not assignable to parameter of type &#x27;Lengthwise&#x27;.\n\n\n\n泛型接口可以使用接口的方式来定义一个函数需要符合的形状：\ninterface SearchFunc &#123;  (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123;    return source.search(subString) !== -1;&#125;\n\n当然也可以使用含有泛型的接口来定义函数的形状：\ninterface CreateArrayFunc &#123;    &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;    let result: T[] = [];    for (let i = 0; i &lt; length; i++) &#123;        result[i] = value;    &#125;    return result;&#125;createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]\n\n进一步，我们可以把泛型参数提前到接口名上：\ninterface CreateArrayFunc&lt;T&gt; &#123;    (length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc&lt;any&gt;;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;    let result: T[] = [];    for (let i = 0; i &lt; length; i++) &#123;        result[i] = value;    &#125;    return result;&#125;createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]\n\n注意，此时在使用泛型接口的时候，需要定义泛型的类型。\n泛型类与泛型接口类似，泛型也可以用于类的类型定义中：\nclass GenericNumber&lt;T&gt; &#123;    zeroValue: T;    add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;;\n\n\n\n泛型参数的默认类型在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。\nfunction createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123;    let result: T[] = [];    for (let i = 0; i &lt; length; i++) &#123;        result[i] = value;    &#125;    return result;&#125;\n\n\n\n声明合并如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型：\n函数的合并我们可以使用重载定义多个函数类型：\nfunction reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string &#123;    if (typeof x === &#x27;number&#x27;) &#123;        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));    &#125; else if (typeof x === &#x27;string&#x27;) &#123;        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);    &#125;&#125;\n\n接口的合并接口中的属性在合并时会简单的合并到一个接口中：\ninterface Alarm &#123;    price: number;&#125;interface Alarm &#123;    weight: number;&#125;\n\n相当于：\ninterface Alarm &#123;    price: number;    weight: number;&#125;\n\n注意，合并的属性的类型必须是唯一的：\ninterface Alarm &#123;    price: number;&#125;interface Alarm &#123;    price: number;  // 虽然重复了，但是类型都是 `number`，所以不会报错    weight: number;&#125;\n\ninterface Alarm &#123;    price: number;&#125;interface Alarm &#123;    price: string;  // 类型不一致，会报错    weight: number;&#125;// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type.  Variable &#x27;price&#x27; must be of type &#x27;number&#x27;, but here has type &#x27;string&#x27;.\n\n接口中方法的合并，与函数的合并一样：\ninterface Alarm &#123;    price: number;    alert(s: string): string;&#125;interface Alarm &#123;    weight: number;    alert(s: string, n: number): string;&#125;\n\n相当于：\ninterface Alarm &#123;    price: number;    weight: number;    alert(s: string): string;    alert(s: string, n: number): string;&#125;\n\n类的合并类的合并与接口的合并规则一致。\n","categories":["TS"],"tags":["JS"]},{"title":"TypeScript知识点","url":"/2021/12/17/TypeScript%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"\n\n\n访问修饰符有哪些？public：公共的。类的所有成员，其子类以及该类的实例都可以访问；\nprotected： 受保护的。该类及其子类的所有成员都可以访问它们。 但是该类的&#x3D;&#x3D;实例无法访问&#x3D;&#x3D;。\nprivate：私有的。只有类的成员可以访问它们。\nDeclare关键字的作用TypeScript声明文件。我们希望在TypeScript文件中使用它们时不会出现编译错误。为此，我们使用declare关键字\n当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。\n\ndeclare var 声明全局变量\ndeclare function 声明全局方法\ndeclare class 声明全局类\ndeclare enum 声明全局枚举类型\ndeclare namespace 声明（含有子属性的）全局对象\ninterface 和 type 声明全局类型\n\n假如我们想使用第三方库 jQuery，但是在 ts 中，编译器并不知道 $ 或 jQuery 是什么东西1：\n这时，我们需要使用 declare var 来定义它的类型：\ndeclare var jQuery: (selector: string) =&gt; any;jQuery(&#x27;#foo&#x27;);\n\n\n\nTypeScript中的枚举枚举是TypeScipt数据类型，它允许我们定义一组命名常量。它是相关值的集合，可以是数字值或字符串值。\nenum Gender &#123;  Male,  Female,  Other&#125;console.log(Gender.Male); // Output: 0console.log(Gender[1]); // Output: Female\n\n\n\n装饰器装饰器是一种&#x3D;&#x3D;特殊类型的声明&#x3D;&#x3D;，它能过被附加到类声明，方法，属性或者参数上，可以修改类的行为\n通俗的来说就是一个方法，可以注入到类，方法，属性参数上来扩展类，属性，方法，参数的功能\n装饰器的分类: 类装饰器、属性装饰器、方法装饰器、参数装饰器\nnever和void的区别？\nvoid 表示没有任何类型（可以被赋值为 null 和 undefined）\nnever 表示一个不包含值的类型，即表示永远不存在的值。\n拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。\n\n类型断言是什么用来&#x3D;&#x3D;手动指定一个值具体的类型&#x3D;&#x3D;，即允许变量从一种类型更改为另一种类型。\n值 as 类型// 或&lt;类型&gt;值\n\n\n联合类型可以被断言为其中一个类型\n父类可以被断言为子类\n任何类型都可以被断言为 any\nany 可以被断言为任何类型\n要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可\n\nany和unknown的区别主要区别：\n unknown 类型会更加严格：在对 unknown 类型的值执行大多数操作之前，我们必须进行某种形式的检查。\n在对 any 类型的值执行操作之前，我们不必进行任何检查。\nlet foo: any = 123;console.log(foo.msg); // 符合TS的语法let a_value1: unknown = foo;   // OKlet a_value2: any = foo;      // OKlet a_value3: string = foo;   // OKlet bar: unknown = 222; // OK console.log(bar.msg); // Error (不能通过TS语法检测)let k_value1: unknown = bar;   // OKlet K_value2: any = bar;      // OKlet K_value3: string = bar;   // Error\n\n unknown 类型的值也不能将值赋给 any 和 unknown 之外的类型变量\n总结: any 和 unknown 都是顶级类型，但是 unknown 更加严格，不像 any 那样不做类型检查，反而 unknown 因为未知性质，不允许访问属性，不允许赋值给其他有明确类型的变量。\n判断传入参数是否是数组类型function isArray(x: unknown): boolean &#123;  if (Array.isArray(x)) &#123;    return true;  &#125;  return false;&#125;\n\n\n\n类类型接口\n如果接口用于一个类的话，那么接口会表示“行为的抽象”\n对类的约束，让类去实现接口，类可以实现多个接口\n接口只能约束类的公有成员（实例属性&#x2F;方法），无法约束私有成员、构造函数、静态属性&#x2F;方法\n\n方法重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。\n基本上，它在派生类或子类中重新定义了基类方法。\n方法覆盖规则：\n\n该方法必须与父类中的名称相同。\n它必须具有与父类相同的参数。\n必须存在IS-A关系或继承。\n\n实现继承继承是一种从另一个类获取一个类的属性和行为的机制。它是面向对象编程的一个重要方面，并且具有从现有类创建新类的能力，继承成员的类称为基类，继承这些成员的类称为派生类。\n继承可以通过使用extend关键字来实现。\nclass Shape &#123;       Area:number       constructor(area:number) &#123;          this.Area = area      &#125;     &#125;     class Circle extends Shape &#123;       display():void &#123;          console.log(&quot;圆的面积: &quot;+this.Area)       &#125;     &#125;    var obj = new Circle(320);     obj.display() \n\n\n\n泛型interface和type的区别相同点：\n\n都可以描述一个对象或者函数\n都允许拓展（extends）\n\ninterface User &#123;  name: string  age: number&#125;interface (name: string, age: number): void;type User = &#123;  name: string  age: number&#125;;type SetUser = (name: string, age: number)=&gt; void;\n\ninterface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。\n**不同点: **\n\ntype 可以而 interface 不行\n\ntype 可以声明基本类型别名，联合类型，元组等类型\n\ntype 语句中还可以使用 typeof 获取实例的类型进行赋值\n// 当你想获取一个变量的类型时，使用 typeoflet div = document.createElement(&#x27;div&#x27;);type B = typeof div\n\n\ninterface 可以而 type 不行\n\ninterface 能够声明合并\ninterface User &#123;  name: string  age: number&#125;interface User &#123;  sex: string&#125;/*User 接口为 &#123;  name: string  age: number  sex: string &#125;*/\n\n\n\n检查TS中的null和undefiendif (x === null) &#123;    console.log(name + &#x27; === null&#x27;);  &#125;  if (typeof x === &#x27;undefined&#x27;) &#123;    console.log(name + &#x27; is undefined&#x27;);  &#125;  \n\n\n\nconst和readonly的区别\nconst用于变量，readonly用于属性\nconst在运行时检查，readonly在编译时检查\n使用const变量保存的数组，可以使用push，pop等方法。但是如果使用Readonly Array声明的数组不能使用push，pop等方法\n\nclass Greeter &#123;  readonly name: string = &quot;world&quot;;&#125;\n\n\n\nOmit 类型有什么作用Omit 以一个类型为基础支持剔除某些属性，然后返回一个新类型。\ninterface Todo &#123;  title: string  description: string  completed: boolean  createdAt: number&#125;type TodoPreview = Omit&lt;Todo, &quot;description&quot;&gt;\n\n\n\n\n\n","categories":["TS"],"tags":["JS"]},{"title":"小程序入门概览","url":"/2022/01/05/%E5%B0%8F%E7%A8%8B%E5%BA%8F/","content":"\n\n\n\n一、appID&#x2F;OpenID&#x2F;UnionID的区别openID：每个用户针对每个公众号或小程序等应用会产生一个安全的OpenID。\nUnionID：同一个用户在不同的应用（小程序、公众号），unionid是相同的。\nunionid 是用户的身份证，不同应用间识别用户的唯一性只可以用unionid。\nopenid 也可以用来标记用户身份，但是仅限于在同一个应用中\nappid：微信应用的身份证（小程序、公众号等的ID）\n二、授权登录流程1.通过 wx.getSetting() 判断用户是否授权；\n2.通过 wx.login() 获取临时登录凭证code，向后端获取session/token、openid、unionId，存入Storage\n3.页面给定一个&lt;button&gt;，设置open-type=&quot;getUserInfo&quot;;\n4.点击button，通过wx.getUserInfo()获取加密签名信息（signature、encryptedData、iv、rawData）；\n5.通过签名，向后端获取用户数据\n三、分包\n底部栏对应的页面为主包；需要点点进入的页面作为子包\n子包可以访问主包的内容；主包不能访问子包的内容，子包间也不能访问；\n\n分包加载每个使用分包小程序&#x3D;&#x3D;必定含有一个主包&#x3D;&#x3D;。\n所谓的&#x3D;&#x3D;主包&#x3D;&#x3D;，即放置&#x3D;&#x3D;默认启动页面&#x2F;TabBar&#x3D;&#x3D; 页面，以及一些&#x3D;&#x3D;所有分包都需用到公共资源&#x2F;JS 脚本&#x3D;&#x3D;；而分包则是根据开发者的配置进行划分。\n在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。\n小程序分包大小有以下限制：\n\n整个小程序所有分包大小不超过 20M\n单个分包&#x2F;主包大小不能超过 2M\n\n对小程序进行分包，可以优化小程序首次启动的下载时间，以及在多团队共同开发时可以更好的解耦协作。\n配置方法假设支持分包的小程序目录结构如下：\n├── app.js├── app.json├── app.wxss├── packageA│   └── pages│       ├── cat│       └── dog├── packageB│   └── pages│       ├── apple│       └── banana├── pages│   ├── index│   └── logs└── utils\n\n开发者通过在 app.json subpackages 字段声明项目分包结构：\n&#123;  &quot;pages&quot;:[    &quot;pages/index&quot;,    &quot;pages/logs&quot;  ],  &quot;subpackages&quot;: [    &#123;      &quot;root&quot;: &quot;packageA&quot;,      &quot;pages&quot;: [        &quot;pages/cat&quot;,        &quot;pages/dog&quot;      ]    &#125;, &#123;      &quot;root&quot;: &quot;packageB&quot;,      &quot;name&quot;: &quot;pack2&quot;,      &quot;pages&quot;: [        &quot;pages/apple&quot;,        &quot;pages/banana&quot;      ]    &#125;  ]&#125;\n\n\n\n打包原则：\n声明 subpackages 后，将按 subpackages 配置路径进行打包，subpackages 配置路径外的目录将被打包到主包中\n主包也可以有自己的 pages，即最外层的 pages 字段。\nsubpackage 的根目录不能是另外一个 subpackage 内的子目录\ntabBar 页面必须在主包内\n\n独立分包独立于主包和其他分包运行。从&#x3D;&#x3D;独立分包中页面进入小程序时&#x3D;&#x3D;，&#x3D;&#x3D;不需要下载主包&#x3D;&#x3D;。当用户进入普通分包或主包内页面时，主包才会被下载。\n\n独立分包中不能依赖主包和其他分包中的内容，包括 js 文件、template、wxss、自定义组件、插件等（使用 分包异步化 时 js 文件、自定义组件、插件不受此条限制）\n主包中的 app.wxss 对独立分包无效，应避免在独立分包页面中使用 app.wxss 中的样式；\nApp 只能在主包内定义，独立分包中不能定义 App，会造成无法预期的行为；\n独立分包中暂时不支持使用插件\n\n四、生命周期应用的生命周期：\nonLaunch：首次打开小程序（全局只触发一次）\nonShow：初始化后或从后台切回前台\nonHide：切到后台\nonError：出现错误\n\n页面的生命周期：\nonLoad：页面加载时执行，只执行一次\nonShow：页面展示时执行，执行多次；\nonReady：页面初次渲染时执行，只执行一次；\nonHide：页面从前台进入后台时执行；\nonUnload：页面卸载时执行；\n\n执行顺序：onLoad –&gt; onShow –&gt; onReady –&gt; onHide\n从A页面切换到B页面，再从B页面返回到A页面时，只触发onShow\n组件的生命周期：created（重要）：组件实例刚刚被创建好时触发。此时还不能调用 setData\nattached（重要）：在组件完全初始化完毕、进入页面节点树后被触发。this.data 已被初始化为组件的当前值\nready：在组件在视图层布局完成后执行\ndetached（重要）：在组件离开页面节点树后被触发\n","categories":["JS"],"tags":["小程序"]},{"title":"Vue3查缺补漏","url":"/2022/03/02/vue3%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/","content":"\n\nv-showv-show 不支持在 &lt;template&gt; 元素上使用，也不能和 v-else 搭配使用。\n当 v-if 和 v-for 同时存在于一个元素上的时候，v-if 会首先被执行。\n同时使用 v-if 和 v-for 是不推荐的，因为这样二者的优先级不明显。\nv-for同时使用 v-if 和 v-for 是不推荐的，因为这样二者的优先级不明显。\n当它们同时存在于一个节点上时，v-if 比 v-for 的优先级更高。\n这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名。\nreactive()创建一个响应式对象或数组\n&lt;script setup&gt;import &#123; reactive &#125; from &#x27;vue&#x27;const state = reactive(&#123; count: 0 &#125;)function increment() &#123;  state.count++&#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;increment&quot;&gt;    &#123;&#123; state.count &#125;&#125;  &lt;/button&gt;&lt;/template&gt;\n\n局限性：\n仅对对象类型有效（对象、数组和 Map、Set 这样的集合类型），而对 string、number 和 boolean 这样的 原始类型 无效。\n因为 Vue 的响应式系统是通过属性访问进行追踪的，因此我们必须始终保持对该响应式对象的相同引用。\n\n这意味着我们不可以随意地“替换”一个响应式对象，因为这将导致对初始引用的响应性连接丢失：\nlet state = reactive(&#123; count: 0 &#125;)// 上面的引用 (&#123; count: 0 &#125;) 将不再被追踪（响应性连接已丢失！）state = reactive(&#123; count: 1 &#125;)\n\n同时这也意味着当我们将响应式对象的属性赋值或解构至本地变量时，或是将该属性传入一个函数时，我们会失去响应性：\nconst state = reactive(&#123; count: 0 &#125;)// n 是一个局部变量，同 state.count// 失去响应性连接let n = state.count// 不影响原始的 staten++// count 也和 state.count 失去了响应性连接let &#123; count &#125; = state// 不会影响原始的 statecount++// 该函数接收一个普通数字，并且// 将无法跟踪 state.count 的变化callSomeFunction(state.count\n\nref()Vue 提供了一个 ref() 方法来允许我们创建可以使用任何值类型的响应式ref\n&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0)function increment() &#123;  count.value++&#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;increment&quot;&gt;    &#123;&#123; count &#125;&#125; &lt;!-- 无需 .value --&gt;  &lt;/button&gt;&lt;/template&gt;\n\ncomputed()计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算。 只要 依赖 不改变，无论多少次访问 都会立即返回先前的计算结果，而不用重复执行 getter 函数\nGetter 不应有副作用不要在 getter 中做异步请求或者更改 DOM！\n一个计算属性的声明中描述的是如何根据其他值派生一个值。因此 getter 的职责应该仅为计算和返回该值。\n避免直接修改计算属性值从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。\nwatch()、watchEffect()侦听数据源类型watch 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：\nconst x = ref(0)const y = ref(0)// 单个 refwatch(x, (newX) =&gt; &#123;  console.log(`x is $&#123;newX&#125;`)&#125;)// getter 函数watch(  () =&gt; x.value + y.value,  (sum) =&gt; &#123;    console.log(`sum of x + y is: $&#123;sum&#125;`)  &#125;)// 多个来源组成的数组watch([x, () =&gt; y.value], ([newX, newY]) =&gt; &#123;  console.log(`x is $&#123;newX&#125; and y is $&#123;newY&#125;`)&#125;)\n\n注意，你不能直接侦听响应式对象的属性值。\n需要用一个返回该属性的 getter 函数：\nconst obj = reactive(&#123; count: 0 &#125;)// 错误，因为 watch() 得到的参数是一个 numberwatch(obj.count, (count) =&gt; &#123;  console.log(`count is: $&#123;count&#125;`)&#125;)// 提供一个 getter 函数watch(  () =&gt; obj.count,  (count) =&gt; &#123;    console.log(`count is: $&#123;count&#125;`)  &#125;)\n\nwatch(todoId, async () =&gt; &#123;  const response = await fetch(    `https://jsonplaceholder.typicode.com/todos/$&#123;todoId.value&#125;`  )  data.value = await response.json()&#125;, &#123;    immediate: true, // 强制侦听器的回调立即执行    flush: &#x27;post&#x27;, // 侦听器回调中能访问被 Vue 更新之后的 DOM&#125;)\n\nwatchEffect() 允许我们自动跟踪回调的响应式依赖。上面的侦听器可以重写为：\nwatchEffect(async () =&gt; &#123;  const response = await fetch(    `https://jsonplaceholder.typicode.com/todos/$&#123;todoId.value&#125;`  )  data.value = await response.json()&#125;, &#123;     flush: &#x27;post&#x27; // 后置刷新的watchEffect()有个更方便的别名watchPostEffect()&#125;)\n\n要手动停止一个侦听器，请调用 watch 或 watchEffect 返回的函数：\nconst unwatch = watchEffect(() =&gt; &#123;&#125;)// 当该侦听器不再需要时unwatch()\n\n需要异步创建侦听器的情况很少，请尽可能选择同步创建。如果需要等待一些异步数据，你可以使用条件式的侦听逻辑：\n// 需要异步请求得到的数据const data = ref(null)watchEffect(() =&gt; &#123;  if (data.value) &#123;    // 数据加载后执行某些操作...  &#125;&#125;)\n\nref引用在元素上，则获取的是DOM元素；\n&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;// 声明一个 ref 来存放该元素的引用// 必须和模板里的 ref 同名const input = ref(null)onMounted(() =&gt; &#123;  input.value.focus()&#125;)&lt;/script&gt;&lt;template&gt;  &lt;input ref=&quot;input&quot; /&gt;&lt;/template&gt;\n\n引用在选项式API子组件上：被引用的组件实例和该子组件的 this 完全一致。这意味着父组件对子组件的每一个属性和方法都有完全的访问权。当然也因此，应该只在绝对需要时才使用组件引用。大多数情况下，你应该首先使用标准的 props 和 emit 接口来实现父子组件交互。\n引用在组合式子组件上：父组件无法访问到一个使用了 &lt;script setup&gt; 的子组件中的任何东西，除非子组件在其中通过 defineExpose 宏显式暴露：\n&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const a = 1const b = ref(2)defineExpose(&#123;  a,  b&#125;)&lt;/script&gt;\n\n组件基础传递 propsdefineProps();\n&lt;!-- Child.vue --&gt;&lt;script setup&gt;defineProps([&#x27;title&#x27;])&lt;/script&gt;&lt;template&gt;  &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;&lt;/template&gt;\n\n监听事件defineEmits();\n&lt;!-- Child.vue --&gt;&lt;script setup&gt;defineProps([&#x27;title&#x27;])defineEmits([&#x27;enlarge-text&#x27;])&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;blog-post&quot;&gt;    &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;    &lt;button @click=&quot;$emit(&#x27;enlarge-text&#x27;)&quot;&gt;Enlarge text&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;!-- Parent.vue --&gt;&lt;Child @enlarge-text=&quot;postFontSize += 0.1&quot; title=&quot;test&quot;/&gt;\n\n\n\nv-modal在组件上使用v-modal。\n方法一：&lt;!-- CustomInput.vue --&gt;&lt;script setup&gt;defineProps([&#x27;modelValue&#x27;])defineEmits([&#x27;update:modelValue&#x27;])&lt;/script&gt;&lt;template&gt;  &lt;input    :value=&quot;modelValue&quot;    @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;  /&gt;&lt;/template&gt;\n\n&lt;CustomInput v-model=&quot;searchText&quot; /&gt;\n\n方法二：&lt;!-- CustomInput.vue --&gt;&lt;script setup&gt;import &#123; computed &#125; from &#x27;vue&#x27;const props = defineProps([&#x27;modelValue&#x27;])const emit = defineEmits([&#x27;update:modelValue&#x27;])const value = computed(&#123;  get() &#123;    return props.modelValue  &#125;,  set(value) &#123;    emit(&#x27;update:modelValue&#x27;, value)  &#125;&#125;)&lt;/script&gt;&lt;template&gt;  &lt;input v-model=&quot;value&quot; /&gt;&lt;/template&gt;\n\n\n\n透传 Attributes“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或者 v-on 事件监听器。最常见的例子就是 class、style 和 id。\n禁用 Attributes 继承如果你使用了 &lt;script setup&gt;，你需要一个额外的 &lt;script&gt; 块来书写这个选项声明：\n&lt;script&gt;// 使用普通的 &lt;script&gt; 来声明选项export default &#123;  inheritAttrs: false&#125;&lt;/script&gt;&lt;script setup&gt;// ...setup 部分逻辑&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;btn-wrapper&quot;&gt;    &lt;button class=&quot;btn&quot; v-bind=&quot;$attrs&quot;&gt;click me&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n\n多根节点的 Attributes 继承和单根节点组件有所不同，有着多个根节点的组件没有自动 attribute 透传行为。如果 $attrs 没有被显式绑定，将会抛出一个运行时警告。\n&lt;header&gt;...&lt;/header&gt;&lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;&lt;footer&gt;...&lt;/footer&gt;\n\n&lt;script setup&gt;import &#123; useAttrs &#125; from &#x27;vue&#x27;const attrs = useAttrs()&lt;/script&gt;\n\n虽然这里的 attrs 对象总是反映为最新的透传 attribute，但它并不是响应式的 (考虑到性能因素)。你不能通过侦听器去监听它的变化。\n","categories":["Vue"],"tags":["Vue"]},{"title":"Vue自定义指令","url":"/2022/01/21/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","content":"\n\n\n将一个自定义指令全局注册到应用层级也是一种常见的做法：\nconst app = createApp(&#123;&#125;)// 使 v-focus 在所有组件中都可用app.directive(&#x27;focus&#x27;, &#123;  /* ... */&#125;)\n\n\n\n一个指令的定义对象可以提供几种钩子函数 (都是可选的)：\n// vue2.xconst myDirective = &#123;   // 在绑定元素的父组件 及他自己的所有子节点都挂载完成后调用  bind(el, binding, vnode, prevVnode) &#123;&#125;,    // 在绑定元素的父组件 及他自己的所有子节点都更新后调用  update(el, binding, vnode, prevVnode) &#123;&#125;, \t  unbind(el, binding, vnode, prevVnode) &#123;&#125;&#125;// vue3.xconst myDirective = &#123;   // 在绑定元素的父组件  // 及他自己的所有子节点都挂载完成后调用  mounted(el, binding, vnode, prevVnode) &#123;&#125;,    // 在绑定元素的父组件  // 及他自己的所有子节点都更新后调用  updated(el, binding, vnode, prevVnode) &#123;&#125;,    // 绑定元素的父组件卸载后调用  unmounted(el, binding, vnode, prevVnode) &#123;&#125;&#125;\n\n\nel：指令绑定到的元素。这可以用于直接操作 DOM。\n\nbinding：一个对象，包含以下属性。\nvalue：传递给指令的值。例如在 v-my-directive=&quot;1 + 1&quot; 中，值是 2。\noldValue：之前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否更改，它都可用。\narg：传递给指令的参数 (如果有的话)。例如在 v-my-directive:foo 中，参数是 &quot;foo&quot;。\nmodifiers：一个包含修饰符的对象 (如果有的话)。例如在 v-my-directive.foo.bar 中，修饰符对象是 &#123; foo: true, bar: true &#125;。\ninstance：使用该指令的组件实例。\ndir：指令的定义对象。\n\nvnode：代表绑定元素的底层 VNode。\n\nprevNode：之前的渲染中代表指令所绑定元素的 VNode。仅在 beforeUpdate 和 updated 钩子中可用。\n\n\n除了 el 外，其他参数都是只读的，不要更改它们。若你需要在不同的钩子间共享信息，推荐通过元素的 dataset attribute 实现。\n简化形式对于自定义指令来说，一个很常见的情况是仅仅需要在 mounted 和 updated 上实现相同的行为，除此之外并不需要其他钩子。这种情况下我们可以直接用一个函数来定义指令，如下所示：\n&lt;div v-color=&quot;color&quot;&gt;&lt;/div&gt;\n\napp.directive(&#x27;color&#x27;, (el, binding) =&gt; &#123;  // 这会在 `mounted` 和 `updated` 时都调用  el.style.color = binding.value&#125;)\n\n\n\n例子：tab切换// tab.vue&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;;const index = ref(0);const tabs = ref([&#x27;tab1&#x27;, &#x27;tab2&#x27;, &#x27;tab3&#x27;])const changeTab = (v) =&gt; &#123;  index.value = v;&#125;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;tabWrapper&quot; v-tab=&quot;&#123;    cIndex: index,    className: &#x27;tab&#x27;,    activeClass: &#x27;active&#x27;  &#125;&quot;&gt;    &lt;template v-for=&quot;(tab, i) in tabs&quot; :key=&quot;tab&quot;&gt;      &lt;div class=&quot;tab&quot; @click=&quot;changeTab(i)&quot;&gt;&#123;&#123; tab &#125;&#125;&lt;/div&gt;    &lt;/template&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot;&gt;.tabWrapper &#123;  display: flex;  .tab &#123;    display: flex;    justify-content: center;    align-items: center;    height: 50px;    width: 100px;    border: 1px solid #ccc;    cursor: pointer;    &amp;:nth-child(2) &#123;      border-left: none;      border-right: none;    &#125;    &amp;.active &#123;      background-color: green;      color: #ffffff;    &#125;  &#125;&#125;&lt;/style&gt;\n\n// src/directives/tab.jsconst VTab = &#123;  mounted(el, binding) &#123;    const &#123; cIndex, activeClass, className &#125; = binding.value;    const tabItems = el.getElementsByClassName(className);    tabItems[cIndex].className += ` $&#123;activeClass&#125;`;  &#125;,  updated(el, binding) &#123;    const &#123; cIndex: oldCIndex &#125; = binding.oldValue;    const &#123; cIndex, activeClass, className &#125; = binding.value;    const tabItems = el.getElementsByClassName(className);    tabItems[oldCIndex].className = className;    tabItems[cIndex].className += ` $&#123;activeClass&#125;`;  &#125;&#125;export default VTab;\n\n// src/directives/index.jsimport tab from &quot;./tab&quot;;const loadDirectives = (app) =&gt; &#123;  app.directive(&#x27;tab&#x27;, tab);&#125;export default loadDirectives;\n\n// main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;;import loadDirectives from &#x27;./directives&#x27;;const app = createApp(App);loadDirectives(app);app.mount(&#x27;#app&#x27;)\n\n\n\n\n\n使用场景：\n按钮权限 v-has\n图片懒加载 v-lazy\n防抖 V-debounce\n拖拽指令 v-draggable mousemove. mouseup monsedown.dragenter、dragover、drop。\n\n","categories":["Vue"],"tags":["Vue"]},{"title":"Vue2遗漏知识点","url":"/2022/03/17/vue2%E9%81%97%E6%BC%8F%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"\n\n\n1.不要在选项 property 或回调上使用箭头函数比如 created: () =&gt; console.log(this.a) 或 vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())。\n因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止。\n经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。\n2.动态参数可以在指令参数中使用 JavaScript 表达式，方法是用方括号括起来：\n&lt;!-- 注意，参数表达式的写法存在一些约束。--&gt;&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;\n\n这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的组件实例有一个 data property attributeName，其值为 &quot;href&quot;，那么这个绑定将等价于 v-bind:href。\n同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：\n&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;\n\n在这个示例中，当 eventName 的值为 &quot;focus&quot; 时，v-on:[eventName] 将等价于 v-on:focus。\n注意事项对动态参数值约定动态参数预期会求出一个字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。\n对动态参数表达式约定动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：\n&lt;!-- 这会触发一个编译警告 --&gt;&lt;a v-bind:[&#x27;foo&#x27; + bar]=&quot;value&quot;&gt; ... &lt;/a&gt;\n\n变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。\n在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：\n&lt;!--  在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。  除非在实例中有一个名为“someattr”的 property，否则代码不会工作。--&gt;&lt;a v-bind:[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt;\n\n3.修饰符【详情见第9条】修饰符 (modifier) 是以半角句号.指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。\n例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：\n&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;\n\n4.计算属性缓存 vs 方法我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。\n然而，不同的是计算属性是基于它们的反应依赖关系缓存的。计算属性只在相关&#x3D;&#x3D;响应式依赖发生改变时&#x3D;&#x3D;它们才会重新求值。\n这就意味着只要相关响应式依赖还没有发生改变，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数。\n这也同样意味着下面的计算属性将不再更新，因为 Date.now () &#x3D;&#x3D;不是响应式依赖&#x3D;&#x3D;：\ncomputed: &#123;  now() &#123;    return Date.now()  &#125;&#125;\n\n相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。\n我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 list，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 list。如果没有缓存，我们将不可避免的多次执行 list 的 getter！如果你不希望有缓存，请用 method 来替代。\n5.绑定 HTML Class对象语法当有如下模板：\n&lt;div  class=&quot;static&quot;  :class=&quot;classObject&quot;&gt;&lt;/div&gt;\n\n和如下 data：\n// 或者data() &#123;  return &#123;    classObject: &#123;      active: true,      &#x27;text-danger&#x27;: false    &#125;  &#125;&#125;\n\n数组语法&lt;div :class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;&lt;!-- 或者 --&gt;&lt;div :class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;\n\ndata() &#123;  return &#123;    activeClass: &#x27;active&#x27;,    errorClass: &#x27;text-danger&#x27;,    isActive: true  &#125;&#125;\n\n6.绑定 HTML Style数组语法:style 的数组语法可以将多个样式对象应用到同一个元素上：\n&lt;div :style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;\n\n多重值可以为 style 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：\n&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt;\n\n7.条件渲染v-show带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display。\n注意，v-show 不支持 &lt;template&gt; 元素，也不支持 v-else。\nv-if VS v-show\nv-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\nv-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\nv-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n\n一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。\n8.列表渲染v-for 与 v-if 一同使用永远不要把 v-if 和 v-for 同时用在同一个元素上。\n当它们处于同一节点，v-if 的优先级比 v-for 更高，这意味着 v-if 将没有权限访问 v-for 里的变量：\n一般我们在两种常见的情况下会倾向于这样做：\n\n为了过滤一个列表中的项目 (比如 v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;)。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。\n为了避免渲染本应该被隐藏的列表 (比如 v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;)。这种情形下，请将 v-if 移动至容器元素上 (比如 ul、ol、template)。\n\nvue2：v-if 的优先级比 v-for 更低\nvue3：v-if 的优先级比 v-for 更高\n9.事件处理访问原始的 DOM 事件有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：\n&lt;button @click=&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;&gt;  Submit&lt;/button&gt;\n\nmethods: &#123;  warn(message, event) &#123;    // now we have access to the native event    if (event) &#123;      event.preventDefault()    &#125;  &#125;&#125;\n\n多事件处理器事件处理程序中可以有多个方法，这些方法由逗号运算符分隔：\n&lt;!-- 这两个 one() 和 two() 将执行按钮点击事件 --&gt;&lt;button @click=&quot;one($event), two($event)&quot;&gt;  Submit&lt;/button&gt;\n\nmethods: &#123;  one(event) &#123;    // first handler logic...  &#125;,  two(event) &#123;    // second handler logic...  &#125;&#125;\n\n事件修饰符\n.stop：停止冒泡；\n.prevent：阻止事件默认行为；\n.capture：添加事件监听器时使用事件捕获模式；\n.self：只当事件是从侦听器绑定的元素本身触发时才触发回调\n.once：只触发一次回调；\n.passive\n\n&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a @click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div @click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div @click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;\n\n\nTIP\n使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。\n\n10.Props传入一个对象的所有 property如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。例如，对于一个给定的对象 post\npost: &#123;  id: 1,  title: &#x27;My Journey with Vue&#x27;&#125;\n\n下面的模板：\n&lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt;\n\n等价于：\n&lt;blog-post v-bind:id=&quot;post.id&quot; v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;\n\n单向数据流所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。\n另外，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。\n\n提示\n注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态。\n\nProp 验证app.component(&#x27;my-component&#x27;, &#123;  props: &#123;    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)    propA: Number,    // 多个可能的类型    propB: [String, Number],    // 必填的字符串    propC: &#123;      type: String,      required: true    &#125;,    // 带有默认值的数字    propD: &#123;      type: Number,      default: 100    &#125;,    // 带有默认值的对象    propE: &#123;      type: Object,      // 对象或数组默认值必须从一个工厂函数获取      default: function() &#123;        return &#123; message: &#x27;hello&#x27; &#125;      &#125;    &#125;,    // 自定义验证函数    propF: &#123;      validator: function(value) &#123;        // 这个值必须匹配下列字符串中的一个        return [&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27;].indexOf(value) !== -1      &#125;    &#125;,    // 具有默认值的函数    propG: &#123;      type: Function,      // 与对象或数组默认值不同，这不是一个工厂函数 —— 这是一个用作默认值的函数      default: function() &#123;        return &#x27;Default function&#x27;      &#125;    &#125;  &#125;&#125;)\n\n当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。\n\n提示\n注意那些 prop 会在一个组件实例创建之前进行验证，所以实例的 property (如 data、computed 等) 在 default 或 validator 函数中是不可用的。\n\n11.非 Prop 的 Attribute一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 props 或 emits 定义的 attribute。常见的示例包括 class、style 和 id 属性。\nAttribute 继承当组件返回单个根节点时，非 prop attribute 将自动添加到根节点的 attribute 中。\nclass&lt;!-- 具有非prop attribute的Date-picker组件--&gt;&lt;date-picker class=&quot;date-picker&quot;&gt;&lt;/date-picker&gt;&lt;!-- 渲染 date-picker 组件 --&gt;&lt;div class=&quot;date-picker&quot; &gt;  &lt;input type=&quot;datetime&quot; /&gt;&lt;/div&gt;\n\n自定义属性&lt;!-- 具有非prop attribute的Date-picker组件--&gt;&lt;date-picker data-status=&quot;activated&quot;&gt;&lt;/date-picker&gt;&lt;!-- 渲染 date-picker 组件 --&gt;&lt;div data-status=&quot;activated&quot;&gt;  &lt;input type=&quot;datetime&quot; /&gt;&lt;/div&gt;\n\n事件监听器&lt;date-picker @change=&quot;submitChange&quot;&gt;&lt;/date-picker&gt;\n\napp.component(&#x27;date-picker&#x27;, &#123;  created() &#123;    console.log(this.$attrs) // &#123; onChange: () =&gt; &#123;&#125;  &#125;  &#125;&#125;)\n\n禁用 Attribute 继承如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。例如：\n禁用 attribute 继承的常见情况是需要将 attribute 应用于根节点之外的其他元素。\n通过将 inheritAttrs 选项设置为 false，你可以访问组件的 $attrs property，该 property 包括组件 props 和 emits property 中未包含的所有属性 (例如，class、style、v-on 监听器等)。\n与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。如果未显式绑定 $attrs，将发出运行时警告。\n&lt;custom-layout id=&quot;custom-layout&quot; @click=&quot;changeValue&quot;&gt;&lt;/custom-layout&gt;\n\n// 这将发出警告app.component(&#x27;custom-layout&#x27;, &#123;  template: `    &lt;header&gt;...&lt;/header&gt;    &lt;main&gt;...&lt;/main&gt;    &lt;footer&gt;...&lt;/footer&gt;  `&#125;)// 没有警告，$attrs被传递到&lt;main&gt;元素app.component(&#x27;custom-layout&#x27;, &#123;  template: `    &lt;header&gt;...&lt;/header&gt;    &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;    &lt;footer&gt;...&lt;/footer&gt;  `&#125;)\n\n组件上使用v-modelv-model 参数默认情况下，组件上的 v-model 使用 modelValue 作为 prop 和 update:modelValue 作为事件。\n&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt;&lt;!-- 等价于以下代码 --&gt;&lt;custom-input  :model-value=&quot;searchText&quot;  @update:model-value=&quot;searchText = $event&quot;&gt;&lt;/custom-input&gt;\n\napp.component(&#x27;custom-input&#x27;, &#123;  props: [&#x27;modelValue&#x27;],  template: `    &lt;input      :value=&quot;modelValue&quot;      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;    &gt;  `&#125;)\n\n我们可以通过向 v-model 传递参数来修改这些名称：\n&lt;my-component v-model:foo=&quot;bar&quot;&gt;&lt;/my-component&gt;\n\n子组件将需要一个 foo prop 并发出 update:foo 要同步的事件：\nconst app = Vue.createApp(&#123;&#125;)app.component(&#x27;my-component&#x27;, &#123;  props: &#123;    foo: String  &#125;,  template: `    &lt;input       type=&quot;text&quot;      :value=&quot;foo&quot;      @input=&quot;$emit(&#x27;update:foo&#x27;, $event.target.value)&quot;&gt;  `&#125;)\n\n多个 v-model 绑定通过利用以特定 prop 和事件为目标的能力，正如我们之前在 v-model 参数中所学的那样，我们现在可以在单个组件实例上创建多个 v-model 绑定。\n每个 v-model 将同步到不同的 prop，而不需要在组件中添加额外的选项：\n&lt;user-name  v-model:first-name=&quot;firstName&quot;  v-model:last-name=&quot;lastName&quot;&gt;&lt;/user-name&gt;\n\nconst app = Vue.createApp(&#123;&#125;)app.component(&#x27;user-name&#x27;, &#123;  props: &#123;    firstName: String,    lastName: String  &#125;,  template: `    &lt;input       type=&quot;text&quot;      :value=&quot;firstName&quot;      @input=&quot;$emit(&#x27;update:firstName&#x27;, $event.target.value)&quot;&gt;    &lt;input      type=&quot;text&quot;      :value=&quot;lastName&quot;      @input=&quot;$emit(&#x27;update:lastName&#x27;, $event.target.value)&quot;&gt;  `&#125;)\n\n12.插槽具名插槽有时我们需要多个插槽。例如对于一个带有如下模板的 &lt;base-layout&gt; 组件：\n&lt;div class=&quot;container&quot;&gt;  &lt;header&gt;    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;  &lt;/header&gt;  &lt;main&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/main&gt;  &lt;footer&gt;    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;  &lt;/footer&gt;&lt;/div&gt;\n\n一个不带 name 的 &lt;slot&gt; 出口会带有隐含的名字“default”。\n在向具名插槽提供内容的时候，我们可以在一个 &lt;template&gt; 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：\n&lt;base-layout&gt;  &lt;template v-slot:header&gt;    &lt;h1&gt;Here might be a page title&lt;/h1&gt;  &lt;/template&gt;  &lt;template v-slot:default&gt;    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;    &lt;p&gt;And another one.&lt;/p&gt;  &lt;/template&gt;  &lt;template v-slot:footer&gt;    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;  &lt;/template&gt;&lt;/base-layout&gt;\n\n渲染的 HTML 将会是：\n&lt;div class=&quot;container&quot;&gt;  &lt;header&gt;    &lt;h1&gt;Here might be a page title&lt;/h1&gt;  &lt;/header&gt;  &lt;main&gt;    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;    &lt;p&gt;And another one.&lt;/p&gt;  &lt;/main&gt;  &lt;footer&gt;    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;  &lt;/footer&gt;&lt;/div&gt;\n\n注意，**v-slot 只能添加在 &lt;template&gt; 上** (只有一种例外情况)\n作用域插槽有时让插槽内容能够访问子组件中才有的数据是很有用的。当一个组件被用来渲染一个项目数组时，这是一个常见的情况，我们希望能够自定义每个项目的渲染方式。\napp.component(&#x27;todo-list&#x27;, &#123;  data() &#123;    return &#123;      items: [&#x27;Feed a cat&#x27;, &#x27;Buy milk&#x27;]    &#125;  &#125;,  template: `    &lt;ul&gt;      &lt;li v-for=&quot;( item, index ) in items&quot;&gt;        &lt;slot :item=&quot;item&quot;&gt;&lt;/slot&gt;      &lt;/li&gt;    &lt;/ul&gt;  `&#125;)\n\n绑定在 &lt;slot &gt; 元素上的 attribute 被称为插槽 prop。现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字：\n&lt;todo-list&gt;  &lt;template v-slot:default=&quot;slotProps&quot;&gt;    &lt;i class=&quot;fas fa-check&quot;&gt;&lt;/i&gt;    &lt;span class=&quot;green&quot;&gt;&#123;&#123; slotProps.item &#125;&#125;&lt;/span&gt;  &lt;/template&gt;&lt;/todo-list&gt;\n\n当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用\n&lt;todo-list v-slot=&quot;slotProps&quot;&gt;  &lt;i class=&quot;fas fa-check&quot;&gt;&lt;/i&gt;  &lt;span class=&quot;green&quot;&gt;&#123;&#123; slotProps.item &#125;&#125;&lt;/span&gt;&lt;/todo-list&gt;\n\n注意默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确。\n只要出现多个插槽，请始终为所有的插槽使用完整的基于 &lt;template&gt; 的语法：\n&lt;todo-list&gt;  &lt;template v-slot:default=&quot;slotProps&quot;&gt;    &lt;i class=&quot;fas fa-check&quot;&gt;&lt;/i&gt;    &lt;span class=&quot;green&quot;&gt;&#123;&#123; slotProps.item &#125;&#125;&lt;/span&gt;  &lt;/template&gt;  &lt;template v-slot:other=&quot;otherSlotProps&quot;&gt;    ...  &lt;/template&gt;&lt;/todo-list&gt;\n\n具名插槽的缩写跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header：\n&lt;base-layout&gt;  &lt;template #header&gt;    ...  &lt;/template&gt;  &lt;template #default&gt;    ...  &lt;/template&gt;  &lt;template #footer&gt;    ...  &lt;/template&gt;&lt;/base-layout&gt;\n\n然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：\n&lt;!-- This will trigger a warning --&gt;&lt;todo-list #=&quot;&#123; item &#125;&quot;&gt;  &lt;i class=&quot;fas fa-check&quot;&gt;&lt;/i&gt;  &lt;span class=&quot;green&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/span&gt;&lt;/todo-list&gt;\n\n如果你希望使用缩写的话，你必须始终以明确插槽名取而代之：\n&lt;todo-list #default=&quot;&#123; item &#125;&quot;&gt;  &lt;i class=&quot;fas fa-check&quot;&gt;&lt;/i&gt;  &lt;span class=&quot;green&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/span&gt;&lt;/todo-list&gt;\n\n13.提供 &#x2F; 注入通常，当我们需要将数据从父组件传递到子组件时，我们使用 props。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人。\n对于这种情况，我们可以使用 provide 和 inject 对。父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 provide 选项来提供数据，子组件有一个 inject 选项来开始使用这个数据。\nconst app = Vue.createApp(&#123;&#125;)app.component(&#x27;todo-list&#x27;, &#123;  data() &#123;    return &#123;      todos: [&#x27;Feed a cat&#x27;, &#x27;Buy tickets&#x27;]    &#125;  &#125;,  provide: &#123;    user: &#x27;John Doe&#x27;   &#125;,  template: `    &lt;div&gt;      &#123;&#123; todos.length &#125;&#125;    &lt;/div&gt;  `&#125;)app.component(&#x27;todo-list-statistics&#x27;, &#123;  inject: [&#x27;user&#x27;],  created() &#123;    console.log(`Injected property: $&#123;this.user&#125;`) // &gt; 注入 property: John Doe  &#125;&#125;)\n\n果我们尝试在此处提供一些组件实例 property，则这将不起作用；我们需要将 provide 转换为返回对象的函数\napp.component(&#x27;todo-list&#x27;, &#123;  data() &#123;    return &#123;      todos: [&#x27;Feed a cat&#x27;, &#x27;Buy tickets&#x27;]    &#125;  &#125;,  provide() &#123;    return &#123;      todoLength: this.todos.length    &#125;  &#125;&#125;)\n\n处理响应性在上面的例子中，如果我们更改了 todos 的列表，这个更改将不会反映在注入的 todoLength property 中。这是因为默认情况下，provide/inject 绑定不是被动绑定。（vue2.x中也不提供响应式的property）\n在vue3中，我们可以通过将 ref property 或 reactive 对象传递给 provide 来更改此行为。在我们的例子中，如果我们想对祖先组件中的更改做出反应，我们需要为我们提供的 todoLength 分配一个组合式 API computed property：\napp.component(&#x27;todo-list&#x27;, &#123;  provide() &#123;    return &#123;      todoLength: Vue.computed(() =&gt; this.todos.length)    &#125;  &#125;&#125;)\n\n$forceUpdate【待完成】14.混入基础混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\n选项合并当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。\n比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。\nconst myMixin = &#123;  data() &#123;    return &#123;      message: &#x27;hello&#x27;,      foo: &#x27;abc&#x27;    &#125;  &#125;&#125;const app = Vue.createApp(&#123;  mixins: [myMixin],  data() &#123;    return &#123;      message: &#x27;goodbye&#x27;,      bar: &#x27;def&#x27;    &#125;  &#125;,  created() &#123;    console.log(this.$data) // =&gt; &#123; message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; &#125;  &#125;&#125;)\n\n同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。\n值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。\nconst myMixin = &#123;  methods: &#123;    foo() &#123;      console.log(&#x27;foo&#x27;)    &#125;,    conflicting() &#123;      console.log(&#x27;from mixin&#x27;)    &#125;  &#125;&#125;const app = Vue.createApp(&#123;  mixins: [myMixin],  methods: &#123;    bar() &#123;      console.log(&#x27;bar&#x27;)    &#125;,    conflicting() &#123;      console.log(&#x27;from self&#x27;)    &#125;  &#125;&#125;)// =&gt; 1.&quot;混入对象的钩子被调用&quot;// =&gt; 2.&quot;组件钩子被调用&quot;const vm = app.mount(&#x27;#mixins-basic&#x27;)vm.foo() // =&gt; &quot;foo&quot;vm.bar() // =&gt; &quot;bar&quot;vm.conflicting() // =&gt; &quot;from self&quot;\n\n全局混入混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响每一个之后创建的组件 (例如，每个子组件)。\nconst app = Vue.createApp(&#123;  myOption: &#x27;hello!&#x27;&#125;)// 为自定义的选项 &#x27;myOption&#x27; 注入一个处理器。app.mixin(&#123;  created() &#123;    const myOption = this.$options.myOption    if (myOption) &#123;      console.log(myOption)    &#125;  &#125;&#125;)// 将myOption也添加到子组件app.component(&#x27;test-component&#x27;, &#123;  myOption: &#x27;hello from component!&#x27;&#125;)app.mount(&#x27;#mixins-global&#x27;)// =&gt; &quot;hello!&quot;// =&gt; &quot;hello from component!&quot;\n\n大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为插件发布，以避免重复应用混入。\n自定义选项合并策略自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向 app.config.optionMergeStrategies 添加一个函数\n合并策略接收在父实例和子实例上定义的该选项的值，分别作为第一个和第二个参数。让我们来检查一下使用 mixin 时，这些参数有哪些：\n// 子实例const app = Vue.createApp(&#123;  custom: &#x27;hello!&#x27;&#125;)app.config.optionMergeStrategies.custom = (toVal, fromVal) =&gt; &#123;  console.log(fromVal, toVal)  // =&gt; &quot;goodbye!&quot;, undefined  // =&gt; &quot;hello&quot;, &quot;goodbye!&quot;  // fromVal 子实例自定义选项的值  // toVal 父实例自定义选项的值  return fromVal || toVal&#125;// 父实例app.mixin(&#123;  custom: &#x27;goodbye!&#x27;,  created() &#123;    console.log(this.$options.custom) // =&gt; &quot;hello!&quot;  &#125;&#125;)\n\n15.TeleportVue 鼓励我们通过将 UI 和相关行为封装到组件中来构建 UI。我们可以将它们嵌套在另一个内部，以构建一个组成应用程序 UI 的树。\n然而，有时组件模板的一部分逻辑上属于该组件，而从技术角度来看，最好将模板的这一部分移动到 DOM 中 Vue app 之外的其他位置。\n一个常见的场景是创建一个包含全屏模式的组件。在大多数情况下，你希望模态的逻辑存在于组件中，但是模态的定位就很难通过 CSS 来解决，或者需要更改组件组合。\n例如：有一个嵌套的组件，子组件是一个模态框组件，模态框组件组件会用到脱离文档流的定位，一般我们需要将该组件的DOM元素移动到body元素的最后面，如果是嵌套组件的话，该DOM元素将被嵌套在父组件元素里。\nTeleport 提供了一种干净的方法，允许我们控制在 DOM 中哪个父节点下呈现 HTML，而不必求助于全局状态或将其拆分为两个组件。\n&lt;body&gt;  &lt;div style=&quot;position: relative;&quot;&gt;    &lt;h3&gt;Tooltips with Vue 3 Teleport&lt;/h3&gt;    &lt;div&gt;      &lt;modal-button&gt;&lt;/modal-button&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;\n\n&lt;template&gt;  &lt;button @click=&quot;modalOpen = true&quot;&gt;    Open full screen modal! (With teleport!)  &lt;/button&gt;  &lt;teleport to=&quot;body&quot;&gt;    &lt;div v-if=&quot;modalOpen&quot; class=&quot;modal&quot;&gt;      &lt;div&gt;        I&#x27;m a teleported modal!         (My parent is &quot;body&quot;)        &lt;button @click=&quot;modalOpen = false&quot;&gt;          Close        &lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/teleport&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;modal-button&#x27;  data() &#123;    return &#123;       modalOpen: false    &#125;  &#125;&#125;&lt;/script&gt;\n\n因此，一旦我们单击按钮打开模式，Vue 将正确地将模态内容渲染为 body 标签的子级。\n与 Vue components 一起使用如果 &lt;teleport&gt; 包含 Vue 组件，则它仍将是 &lt;teleport&gt; 父组件的逻辑子组件\n这也意味着来自父组件的注入按预期工作，并且子组件将嵌套在 Vue Devtools 中的父组件之下，而不是放在实际内容移动到的位置。\n在同一目标上使用多个 teleport一个常见的用例场景是一个可重用的 &lt;Modal&gt; 组件，它可能同时有多个实例处于活动状态。对于这种情况，多个 &lt;teleport&gt; 组件可以将其内容挂载到同一个目标元素。顺序将是一个简单的追加——稍后挂载将位于目标元素中较早的挂载之后。\n&lt;teleport to=&quot;#modals&quot;&gt;  &lt;div&gt;A&lt;/div&gt;&lt;/teleport&gt;&lt;teleport to=&quot;#modals&quot;&gt;  &lt;div&gt;B&lt;/div&gt;&lt;/teleport&gt;&lt;!-- result--&gt;&lt;div id=&quot;modals&quot;&gt;  &lt;div&gt;A&lt;/div&gt;  &lt;div&gt;B&lt;/div&gt;&lt;/div&gt;\n\n16.钩子函数Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。\n\n\n\n生命周期\n描述\n\n\n\nbeforeCreate\n组件实例被创建之初，组件的属性生效之前\n\n\ncreated\n组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，**$el** 还不可用\n\n\nbeforeMount\n在挂载开始之前被调用：相关的 render 函数首次被调用\n\n\nmounted\nel 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子\n\n\nbeforeUpdate\n组件数据更新之前调用，发生在虚拟 DOM 打补丁之前\n\n\nactivited\nkeep-alive 专属，组件被激活时调用\n\n\ndeactivated\nkeep-alive 专属，组件被销毁时调用\n\n\nbeforeDestory\n组件销毁前调用\n\n\ndestoryed\n组件销毁后调用\n\n\n生命周期示意图\n\n\nwatch异步过滤器过滤器实质不改变原始数据，只是对数据进行加工处理后，返回过滤后的数据再进行调用处理，我们也可以理解成纯函数。\n&#123;&#123; messgae | filterA(&quot;arg1&quot;, &quot;arg2&quot;) | filterB(&quot;arg1&quot;, &quot;arg2&quot;) &#125;&#125;\n\nvue.filter(&#x27;filterA&#x27;, function(value) &#123;\t// 返回处理后的值&#125;)vue.filter(&#x27;filterB&#x27;, function(value) &#123;\t// 返回处理后的值&#125;)\n\n常见场景：&#x3D;&#x3D;单位转换、千分符、文本格式化、时间格式化&#x3D;&#x3D;等操作。 这个写个方法不香么?Vue3 果断废弃了过滤器……\n&lt;p&gt; &#123;&#123;format(number)&#125;&#125;&lt;/p&gt;\n\nconst format = () =&gt; &#123;\treturn parseFloat(n).toFixed(2);&#125;\n\n","categories":["Vue"],"tags":["Vue"]},{"title":"Vue易错知识点","url":"/2022/02/19/vue%E6%98%93%E9%94%99%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"\n\n\n一、vue2 部分1. 父子组件的生命周期挂载： 父beforeCreate -&gt; 父created -&gt; 父 beforeMount -&gt; \n​\t\t\t子beforeCreate -&gt;  -&gt; 子 created -&gt; beforeMount -&gt; 子 mounted -&gt; \n​\t\t\t父 mounted\n更新：父 beforUpdate -&gt; 子 beforUpdate -&gt; 子 updated -&gt; 父 updated\n卸载：父beforeDestroy &gt; 子beforeDestroy  &gt; 子destroyed &gt; 父destroyed\n2. mixin特点：1.混入对象会合并到当前组件\n2.混入的对象有同名选项时，以组件数据优先\n3.当多个组件引入混入对象时，其中一个组件改变了混入中的某个属性值或者方法内部的做操时，其他组件不受影响。\n缺点1.多个混入时，不清晰的数据来源；（不清楚调用的是哪个混入的属性或方法）\n2.命名空间冲突\n3.隐式的跨混入交流（混入之间的依赖）\n生命周期顺序：mixin的生命周期钩子在组件的生命周期钩子之前执行\nmixin beforeCreate &gt; 父 beforeCreate &gt; mixin created &gt; 父created &gt; mixin的beforeMount &gt; 父beforeMount  &gt; mixin的mounted &gt;父mounted\n3. nextTick问题：\n\nnextTick是做什么的?\n为什么需要它呢?\n开发时何时使用它? \n下面介绍一下如何使用nextTick\n原理解读，结合异步更新和nextTick生效方式，会显得你格外优秀\n\n1.nextTick是做什么的?nextTick是等待下一次 DOM 更新刷新的工具方法。\n2.为什么需要它呢?Vue有个异步更新策略，意思是如果数据变化，Vue不会立刻更新DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的所有数据变更会异步的批量更新。这一策略导致我们对数据的修改不会立刻体现在DOM上，此时如果想要获取更新后的DOM状态，就需要使用nextTick。\n3.开发时何时使用它?\ncreated中想要获取DOM时;\n响应式数据变化后获取DOM更新后的状态，比如希望获取列表更新后的高度\n\n5.原理解读将传入的回调函数包装成异步任务，异步任务又分微任务和宏任务，为了尽快执行所以优先选择微任务；\n在内部会尝试使用原生的Promise.then (IE不支持)、MutationObserver 和 setImmediate (高版本IE专享)，如果执行环境还不支持的话，则会采用 setTimeout(fn, 0)\n异步方法，异步渲染最后一步，与JS事件循环联系紧密。主要使用了宏任务微任务（setTimeout、promise那些），定义了一个异步方法，多次调用nextTick会将方法存入队列，通过异步方法清空当前队列。\nforceUpdate\n4. 组件通信方式\n**props / $emit**：父子组件通信\n\nref：父子组件通信\n\n$parent &#x2F; $children &#x2F; $root：访问父 &#x2F; 子实例 &#x2F; 根实例\n\nEventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信\n// main.jsVue.prototype.$EventBus = new Vue()// A组件：向EventBus发送事件this.$EventBus.$emit(&quot;msg&quot;, &#x27;123&#x27;);// B组件：接收事件 this.$EventBus.$on(&quot;msg&quot;, (data) =&gt; &#123;   this.msg = data; &#125;);\n\n$attrs&#x2F;$listeners 适用于 隔代组件通信\n\nv-bind=&quot;$attrs&quot; \nv-on=&quot;$listeners&quot;\n\n\nprovide / inject 适用于 隔代组件通信\n\n插槽：Vue3 可以通过 usesolt 获取插槽数据。\n\nmitt.js 适用于任意组件通信\n（Vue3中移除了$on，$off等方法，所以 EventBus不再使用，相应的替换方案就是mitt.js）\n\n\n二、Vue3 部分1. ref 和 reactive 的区别ref 可以将一个&#x3D;&#x3D;普通数据类型（如数字、字符串等）转换为一个响应式对象&#x3D;&#x3D;，从而让这个数据在Vue的响应式系统中被追踪。ref返回一个对象，这个对象有一个.value属性，用来获取和设置这个响应式对象的值\nconst count = ref(0);console.log(count.value); // 0count.value = 1;console.log(count.value); // 1\n\nreactive 可以将一个&#x3D;&#x3D;普通的Javascript对象转换为一个响应式对象&#x3D;&#x3D;。它会递归地将这个对象的所有属性都转换为响应式对象，从而让整个对象在Vue的响应式系统中被追踪。reactive返回一个Proxy对象，用来代理原始对象的访问和修改。\nconst state = reactive(&#123;  count: 0,  message: &#x27;hello&#x27;&#125;);console.log(state.count); // 0state.count = 1;console.log(state.count); // 1\n\nref：如果是基本类型，会使用包装类变成对象，然后使用defineProperty劫持，如果是对象，则使用reactive（Proxy）处理；\nreactive：解构会丧失响应式\n2. ref 可以大量的替换成 reactive 吗不能直接把ref替换成reactive。\nref主要用于将基本数据类型（如字符串、数字等）转换为响应式数据，并提供一个.value属性用于访问和修改该数据。而reactive则用于将一个普通的JavaScript对象转换为响应式对象，并使用Proxy来拦截对该对象的访问和修改，以实现响应式更新。\n因此，如果你需要使用响应式数据来存储基本数据类型，或者你只需要响应式地跟踪一个值的变化，那么ref仍然是更合适的选择。而如果你需要管理一个对象的多个属性，并希望这些属性可以响应式地更新，那么reactive会更加合适\nPinia解决了什么问题\n简化状态管理：Pinia 提供了一个简洁的 API。使得我们可以更容易地定义和管理状态，并在整个应用程序中共享它们。\n更好的类型支持：Pinia 提供了一个类型安全的 API，可以让我们更容易地编写类型安全的代码，并减少错误。\n更好的可测试性：Pinia 的状态管理使得我们可以更容易地对 Vue 3 组件进行单元测试，从而提高代码的可测试性。\n更好的性能：Pinia 的状态管理实现了基于 Proxy 的响应式系统，从而提高了性能并减少了不必要的重渲染\n\n三、区别1. 响应式原理的区别\nObject.defineProperty 无法监控到数组方法，导致通过数组添加元素，不能实时响应;\nObject.defineProperty 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历。如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。\nProxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。\n\n数组问题：const arrayMethods = Array.prototype;//先克隆一份Array的原型出来const arrayProto = Object.create(arrayMethods);const methodsToPatch = [  &#x27;push&#x27;,   &#x27;pop&#x27;,   &#x27;shift&#x27;,   &#x27;unshif&#x27;,  &#x27;splice&#x27;,  &#x27;sort&#x27;,   &#x27;reverse&#x27;]methodsToPatch.forEach(method =&gt; &#123;  arrayProto[method] = function () &#123;    //执行原始操作    arrayMethods[method].apply(this,arguments)    console.log(&#x27;监听赋值成功&#x27;, method)  &#125;&#125;)if (Array.isArray(obj)) &#123;  //如果是数组，重写原型  obj.__proto__ = arrayProto;  // 传入数据可能是多维度的，需要执行响应式  for(let i=0; i&lt; obj.length; i++) &#123;    observer(obj[i]);  &#125;&#125; else &#123;  for(const key in obj) &#123;    // 给对象中的每一个方法都设置响应式    defineProperty(obj, key, obj[key])  &#125;&#125;\n\n\n\n性能优化的方式：\n数据层级不易过深，合理设置响应式数据；\n通过 obiect.freeze(方法冻结非响应式属性；\n使用数据时缓存值的结果，不频繁取值；\n合理设置 Key 属性；\nv-show 和 v-if 的选取；\n控制组件粒度 -&gt; Vue 采用组件级更新采用函数式组件 -&gt; 函数式组件开销低；\n采用异步组件 -&gt; 借助webpack分包的能力；\n使用keep-alive缓存组件 v-once；\n分页、虚拟滚动、时间分片等策略..；\n\n首屏加载慢的优化：使用路由懒加载、异步组件，实现组件拆分，减少入口文件体积大小(优化体验骨架屏)\n抽离公共代码，采用 splitChunks 进行代码分割。\n组件加载采用按需加载的方式\n静态资源缓存，采用 HTTP 缓存 (强制缓存、对比缓存) 、使用 localstorage 实现缓存资源.\n图片资源的压缩，雪碧图、对小图片进行 base64 减少 http 请求\n打包时开启 gzip 压缩处理 compression-webpack-plugin 插件\n静态资源采用 CDN 提速。\n终极的手段使用 SSR 对首屏做服务端渲染\n","categories":["Vue"],"tags":["Vue"]},{"title":"Vue原理解析","url":"/2022/02/04/Vue%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","content":"\n\n\n![image-20230313201943916](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230313201943916.png)\n一.实现一个指令解析器Compile\n获取页面元素，添加到文档碎片对象（DocumentFragment）中。\n编译指令：\n\n\n将文档碎片中的元素，按节点类型分为元素节点和文本节点；\n处理元素节点的指令和事件，同时为每一个属性绑定观察者，将来数据发生变化，触发回调，进行更新。\n\n// fnName: text、html、modelmodel(node, expr, vm) &#123;  const value = this.getVal(expr, vm);  // 绑定观察者，将来数据发生变化，触发回调，进行更新  // 绑定更新函数 数据 =&gt; 视图  new Watcher(vm, expr, (newVal) =&gt; &#123;    this.updater.modelUpdater(node, newVal);  &#125;);  // 视图 =&gt; 数据 =&gt; 视图  node.addEventListener(&#x27;input&#x27;, (e) =&gt; &#123;    this.setVal(expr, vm, e.target.value)  &#125;, false)  this.updater.modelUpdater(node, value);&#125;,\n\n\n将文档碎片对象追加到目标根元素（#app）;\n\n二、实现一个数据观察者Observer，劫持监听所有属性\n递归遍历所有属性，使用defineProperty劫持所有属性；\nget方法中，订阅数据变化时，往 Dep 中添加观察者；\nset方法中，告诉Dep，通知变化；\n\ndefineReactive(obj, key, value) &#123;  // 递归 遍历属性  this.observer(value);  const dep = new Dep();  // 劫持并监听所有的属性  Object.defineProperty(obj, key, &#123;    enumerable: true,    get() &#123;      // 订阅数据变化时，往 Dep 中添加观察者      // 往Dep中收集依赖（属性/观察者），一个属性对应一个观察者      Dep.target &amp;&amp; dep.addSub(Dep.target);      return value;    &#125;,    set: newVal =&gt; &#123;      this.observer(newVal);      if (newVal !== value) &#123;        value = newVal;      &#125;      // 告诉Dep，通知变化      dep.notify();    &#125;  &#125;)&#125;\n\n\n\n三、订阅器Dep\n收集依赖，即观察者Watcher（一个属性对应一个观察者）。\n通知观察者去更新。\n\nclass Dep &#123;  constructor() &#123;    this.subs = [];  &#125;  // 收集观察者  addSub(watcher) &#123;    this.subs.push(watcher);  &#125;  // 通知观察者去更新  notify() &#123;    console.log(&#x27;通知了观察者&#x27;, this.subs);    this.subs.forEach(w =&gt; &#123;      w.update()    &#125;)  &#125;&#125;\n\n\n\n四、观察者Watcher（也叫订阅者）\n实例接收一个回调方法；\n有一个更新函数，此函数在触发set()方法时，通知订阅器触发此方法，调用回调方法更新视图\n\nclass Watcher &#123;  constructor(vm, expr, cb) &#123;    this.vm = vm;    this.expr = expr;    this.cb = cb;    // 保存旧值    this.oldVal = this.getOldVal();  &#125;  update() &#123;    const newVal = compileUtil.getVal(this.expr, this.vm);    if(newVal !== this.oldVal) &#123;      this.cb(newVal)    &#125;  &#125;&#125;\n\n\n\n![image-20230313201943916](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230313201943916.png)\n采用数据劫持 配合 发布者-订阅者模式 的方式，通过Object.defineProperty() 来劫持各个属性的 setter 和 getter，在数据变动时，发布消息给依赖收集器，去通知观察者，更新视图。\nMVVM 作为绑定的入口，整合 Observer，Compile 和 Watcher。三者通过 Observer 来监听 model 数据变化，通过 Compile 来解析编译模板指令，最终利用Watcher 搭起 Observer，Compile 之间的通信桥梁，达到 数据变化 -&gt; 视图更新；视图交互变化 -&gt; 数据model变更 的双向绑定效果。\n\n对象内部通过 defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存放他所依赖的 watcher（依赖收集），当属性变化后会通知自己对应的 watcher 去更新(派发更新)。\n\n底层实现原理vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 Vue是一个典型的MVVM框架，模型（Model）只是普通的javascript对象，修改它则视图（View）会自动更新。这种设计让状态管理变得非常简单而直观。\nObserver（数据监听器） : Observer的核心是通过Object.defineProprtty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher\nWatcher（订阅者） : Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是：\n\n在自身实例化时往属性订阅器(dep)里面添加自己\n自身必须有一个update()方法\n待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调\n\nCompile（指令解析器） : Compile主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新视图\n![image-20230519090610718](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230519090610718.png)\n虚拟 domVirtual DOM 是 DOM 节点在 JavaScript 中的一种抽象数据结构，之所以需要虚拟 DOM，是因为浏览器中操作 DOM 的代价比较昂贵，频繁操作 DOM 会产生性能问题。\n虚拟 DOM 的作用是在每一次响应式数据发生变化引起页面重渲染时，Vue 对比更新前后的虚拟 DOM，匹配找出尽可能少的需要更新的真实 DOM，从而达到提升性能的目的。\n虚拟 DOM 的实现原理主要包括以下 3 部分：\n\n用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；\ndiff 算法 — 比较两棵虚拟 DOM 树的差异；\npatch 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。\n\nVue3Vue3.x 响应式数据原理是什么？\n\n\nObject.defineProperty 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应\nObject.defineProperty 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy 可以劫持整个对象，并返回一个新的对象。\nProxy 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。\nProxy 有多达 13 种拦截方法\nProxy作为新标准将受到浏览器厂商重点持续的性能优化\n\n\nProxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？\n判断当前 Reflect.get 的返回值是否为 Object，如果是则再通过 reactive 方法做代理， 这样就实现了深度观测。\n监测数组的时候可能触发多次 get&#x2F;set，那么如何防止触发多次呢？\n我们可以判断 key 是否为当前被代理对象 target 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 trigger。\n","categories":["Vue"],"tags":["原理"]},{"title":"Fiber 原理","url":"/2022/07/23/Fiber%E5%8E%9F%E7%90%86/","content":"\n\n什么是Firber\n一种数据结构：它可以用一个纯JS 对象来表示:\n一个执行单元：每次执行完一个执行单元，React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去。\n\nFiber关键特性：\n增量渲染\n不同更新的优先级\n暂停，终止，复用渲染任务\n并发方面新的基础能力\n\nReact Fiber 运行流程图\n帧的概念\n目前大多数设备的屏幕的刷新率为60次&#x2F;秒， 即60帧每秒， 人眼舒适放松时可视帧数是每秒24帧 ， 帧数 (fps) 越高，所显示的动作就会越流畅，小于这个值的时候，用户就会感觉到卡顿\n所以对于现在主流屏幕设备来说，每个帧的预算时间就是1&#x2F;60 约等于16.66毫秒\n每个帧的开头包括样式计算、布局和绘制\nJavaScript执行Javascript引擎和页面渲染在同一个线程中，GUI渲染和Javascript执行两者之间是互斥的\n如果某个任务执行时间过长，浏览器就会推迟渲染。\n\n\nFiber 结构示意图\nwindow.requestAnimationFramewindow.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器&#x3D;&#x3D;下一次重绘之前执行&#x3D;&#x3D;\n注意：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()\n当你准备更新动画时你应该调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数(即你的回调函数)。回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。为了提高性能和电池寿命，因此在大多数浏览器里，当requestAnimationFrame() 运行在后台标签页或者隐藏的iframe里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命。\n回调函数会被传入DOMHighResTimeStamp参数，DOMHighResTimeStamp指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间。在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳，即使在计算上一个回调函数的工作负载期间已经消耗了一些时间。该时间戳是一个十进制数，单位毫秒，最小精度为1ms(1000μs)。\n请确保总是使用第一个参数(或其它获得当前时间的方法)计算每次调用之间的时间间隔，否则动画在高刷新率的屏幕中会运行得更快。请参考下面例子的做法。\nwindow.requestAnimationFrame(callback);\n\n参数\ncallback\n下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，该参数与performance.now()的返回值相同，它表示requestAnimationFrame() 开始去执行回调函数的时刻。\n\n\n返回值一个 long 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。你可以传这个值给 window.cancelAnimationFrame() 以取消回调函数。\nconst element = document.getElementById(&#x27;some-element-you-want-to-animate&#x27;);let start;function step(timestamp) &#123;  if (start === undefined)    start = timestamp;  const elapsed = timestamp - start;  //这里使用`Math.min()`确保元素刚好停在200px的位置。  element.style.transform = &#x27;translateX(&#x27; + Math.min(0.1 * elapsed, 200) + &#x27;px)&#x27;;  if (elapsed &lt; 2000) &#123; // 在两秒后停止动画    window.requestAnimationFrame(step);  &#125;&#125;window.requestAnimationFrame(step);\n\nrequestIdleCallback\n 这是一个实验中的功能 \n\n`window.requestIdleCallback()`方法插入一个函数，这个函数将在浏览器空闲时期被调用。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间`timeout`，则有可能为了在超时前执行函数而打乱执行顺序。\n\n你可以在空闲回调函数中调用requestIdleCallback()，以便在下一次通过事件循环之前调度另一个回调。\n强烈建议使用timeout选项进行必要的工作，否则可能会在触发回调之前经过几秒钟。\nvar handle = window.requestIdleCallback(callback[, options])\n\nrequestAnimationFrame的回调会在每一帧确定执行，属性高优先级任务，而requestIdleCallback的回调则不一定，属性低优先级的任务\n返回值一个ID，可以把它传入 Window.cancelIdleCallback() 方法来结束回调。\n参数\ncallback\n一个在事件循环空闲时即将被调用的函数的引用。函数会接收到一个名为 IdleDeadline 的参数，这个参数可以获取当前空闲时间以及回调是否在超时时间前已经执行的状态。\n\noptions 可选\n包括可选的配置参数。具有如下属性：timeout： 如果指定了timeout，并且有一个正值，而回调在timeout毫秒过后还没有被调用，那么回调任务将放入事件循环中排队，即使这样做有可能对性能产生负面影响。\n\n\n\n以下是用户对性能延迟的感知：\n\n\n\n延迟时间\n用户感知\n\n\n\n0-16ms\n很流畅\n\n\n0-100ms\n基本流畅\n\n\n100-1000ms\n感觉到网站上有一些加载任务\n\n\n1000ms or more\n失去耐心了\n\n\n10000ms or more\n直接离开，不会再访问了\n\n\n事件处理最好在 50ms 内完成\nMessageChannelChannel Messaging API的**MessageChannel** 接口允许我们创建一个新的消息通道，并通过它的两个MessagePort 属性发送数据。\n\n目前requestIdleCallback只有chrome支持\n\n所以React利用MessageChannel模拟了requestIdleCallback,将回调延迟到绘制操作之后执行\n\nMessageChannel API 允许我们创建一个新的消息通道，并通过他的两个MessagePort属性发送数据\n\nMessageChannel创建了一个通信的管道，这个管道有两个端口，每个端口都可以通过postMessage发送数据，而一个端口只要绑定了onmessage回调方法，就可以接受另外一个端口传过来的数据\n\nMessageChannel是一个宏任务。\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        let channel = new MessageChannel();        let port1 = channel.port1;        let port2 = channel.port2;        port1.onmessage = function(e)&#123;            console.log(&quot;接收到的数据:&quot;,e.data);        &#125;        port2.onmessage = function(e)&#123;            console.log(&quot;接收到的数据:&quot;,e.data);        &#125;        port1.postMessage(&quot;port1&quot;);        port2.postMessage(&quot;port2&quot;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nrafTime   从页面导航开始，这一帧开始的时间\nperformance.timing.navigationStart +performance.now()  约等于Date.now();\nlet activeFrameTime = 1000/60;// 约等于 16.6let frameDeadline; // 这一帧的截止时间let pendingCallback;let channel = new MessageChannel();let timeRemaining = ()=&gt; frameDeadline-performance.now();channel.port2.onmessage = function()&#123;    let currentTime = performance.now();    // 如果帧的截止时间已经小于当前时间，说明已经过期了    let didTimeout = frameDeadline &lt;= currentTime;    if(didTimeout || timeRemaining()&gt;0)&#123;        if(pendingCallback)&#123;            pendingCallback(&#123;didTimeout,timeRemaining&#125;);        &#125;    &#125;    &#125;window.requestIdleCallback = (callback,options)=&gt;&#123;window.requestAnimationFrame ((rafTime)=&gt;&#123;    console.log(&quot;rafTime&quot;,rafTime);        frameDeadline = rafTime+activeFrameTime;        pendingCallback = callback;        // 其实发消息之后，相当于添加一个宏任务        // debugger        channel.port1.postMessage(&quot;hello&quot;);&#125;);&#125;\n\nFiber执行阶段每次渲染有两个阶段：Reconciliation(协调render阶段)和Commit(提交阶段)\n\n协调的阶段：可以认为是Diff阶段，这个阶段可以被终止，这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等，这些变更React称之为副作用。\n\n提交阶段：将上一阶段计算出来的需要处理的副作用(effects)一次性执行了。这个阶段必须同步执行，不能被打断。\n\n\n遍历规则深度优先\n\n模拟实现\n工作单元\n\nlet element = (&lt;div id=&quot;A1&quot;&gt;    &lt;div id=&quot;B1&quot;&gt;            &lt;div id=&quot;C1&quot;&gt;&lt;/div&gt;            &lt;div id=&quot;C2&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div id=&quot;B2&quot;&gt;&lt;/div&gt;&lt;/div&gt;)let root = document.getElementById(&quot;root&quot;);// 下一个工作单元// fiber 其实也是一个普通的JS对象let workInProgressRoot = &#123;    stateNode: root, // 此fiber对应的DOM节点    props: &#123;        children:[element]    &#125;&#125;let nextUnitOfWork = workInProgressRoot;const  PLACEMENT = &quot;PLACEMENT&quot;// 定义一个工作循环function workloop(deadline) &#123;     console.log(&quot;开始工作循环&quot;);    while (nextUnitOfWork&amp;&amp;deadline.timeRemaining()&gt;0) &#123;         nextUnitOfWork =  performUnitOfWork(nextUnitOfWork);    &#125;    if (!nextUnitOfWork) &#123;         commitRoot();    &#125;&#125;function commitRoot() &#123;     let currentFiber = workInProgressRoot.firstEffect;    while (currentFiber) &#123;         console.log(&quot;commitRoot:&quot;, currentFiber.props.id);        if (currentFiber.effectTag === &quot;PLACEMENT&quot;) &#123;             currentFiber.return.stateNode.appendChild(currentFiber.stateNode)        &#125;        currentFiber = currentFiber.nextEffect;    &#125;    workInProgressRoot = null;&#125;/** * beginWork 1. 创建此Fiber的真实DOM * 通过虚拟DOM创建Fiber树结构 * @param &#123;*&#125; workingInProgressFiber  */function performUnitOfWork(workingInProgressFiber) &#123;     beginWork(workingInProgressFiber);    if (workingInProgressFiber.child) &#123;         return workingInProgressFiber.child;    &#125;    while (workingInProgressFiber) &#123;         // 如果没有儿子当前节点其实就结束了        completeUnitOfWork(workingInProgressFiber);        if (workingInProgressFiber.sibling) &#123;             return workingInProgressFiber.sibling;        &#125;        workingInProgressFiber = workingInProgressFiber.return;    &#125;&#125;function completeUnitOfWork(workingInProgressFiber) &#123;     console.log(&quot;completeUnitOfWork&quot;, workingInProgressFiber.props.id);    // 构建副作用链，上面只有副作用的节点    let returnFiber = workingInProgressFiber.return;// A1    if (returnFiber) &#123;         // 把当前fiber有副作用的子链表挂载到父身上        if (!returnFiber.firstEffect) &#123;             returnFiber.firstEffect = workingInProgressFiber.firstEffect;        &#125;        if (workingInProgressFiber.lastEffect) &#123;             if (returnFiber.lastEffect) &#123;                 returnFiber.lastEffect.nextEffect = workingInProgressFiber.firstEffect;            &#125;            returnFiber.lastEffect = workingInProgressFiber.lastEffect;        &#125;        if (workingInProgressFiber.effectTag) &#123;             if (returnFiber.lastEffect) &#123;                returnFiber.lastEffect.nextEffect = workingInProgressFiber;            &#125; else &#123;                 returnFiber.firstEffect = workingInProgressFiber;            &#125;            returnFiber.lastEffect = workingInProgressFiber;        &#125;    &#125;&#125;function beginWork(workingInProgressFiber) &#123;     console.log(&quot;beginWork&quot;, workingInProgressFiber.props.id);    if (!workingInProgressFiber.stateNode) &#123;       workingInProgressFiber.stateNode =   document.createElement(workingInProgressFiber.type);    &#125;    for (let key in workingInProgressFiber.props) &#123;         if (key !== &quot;children&quot;)            workingInProgressFiber.stateNode[key] = workingInProgressFiber.props[key];    &#125;// 在beginwork 里面是不挂载的    // 创建子Fiber    let previousFiber;    Array.isArray(workingInProgressFiber.props.children)&amp;&amp;workingInProgressFiber.props.children.forEach((child,index) =&gt; &#123;         let childFiber = &#123;            type: child.type,// DOM节点类型            props: child.props,            return: workingInProgressFiber,            effectTag:PLACEMENT,// 这个fiber必须要插入到父节点中            nextEffect: null,// 下一个副作用节点        &#125;        if (index === 0) &#123;            workingInProgressFiber.child = childFiber;        &#125; else &#123;             previousFiber.sibling = childFiber;        &#125;        previousFiber = childFiber;    &#125;)&#125;// 空闲时间requestIdleCallback(workloop);\n","categories":["React"],"tags":["React"]},{"title":"NextJs 的预渲染","url":"/2022/08/05/NextJs/","content":"\n\n一、预渲染的三种模式普通的单页应用只有一个 HTML，初次请求返回的 HTML 中没有任何页面内容，需要通过网络请求 JS bundle 并渲染，整个渲染过程都在客户端完成，所以叫客户端渲染（CSR）\n缺点：\n\n白屏时间过长：在 JS bundle 返回之前，页面一直是空白的。假如 bundle 体积过大或者网络条件不好的情况下，体验会更不好\nSEO 不友好：搜索引擎访问页面时，只会看 HTML 中的内容，默认是不会执行 JS，所以抓取不到页面的具体内容\n\n1. 服务端渲染 SSR(Server Side Rendering)在服务端直接实时同构渲染当前用户访问的页面，返回的 HTML 包含页面具体内容，提高用户的体验。\nNext.js 提供 getServerSideProps 异步函数，以在 SSR 场景下获取额外的数据并返回给组件进行渲染。getServerSideProps 可以拿到每次请求的上下文（Context)，举个例子：\nexport default function FirstPost(props) &#123;  // 在 props 中拿到数据  const &#123; title &#125; = props;  return (    &lt;Layout&gt;      &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;    &lt;/Layout&gt;  )&#125;export async function getServerSideProps(context) &#123;  console.log(&#x27;context&#x27;, context.req);  // 模拟获取数据  const title = await getTitle(context.req);  // 把数据放在 props 对象中返回出去  return &#123;    props: &#123;      title    &#125;  &#125;&#125;\n\nSSR 方案虽然解决了 CSR 带来的两个问题，但是同时又引入另一个问题：需要一个服务器承载页面的实时请求、渲染和响应，这无疑会增大服务端开发和运维的成本。\n另外对于一些较为静态场景，比如博客、官网等，它们的内容相对来说比较确定，变化不频繁，每次通过服务端渲染出来的内容都是一样的，无疑浪费了很多没必要的服务器资源。这时，有没有一种方案可以让这些页面变得静态呢？这时，静态站点生成（SSG，也叫构建时预渲染）诞生了。\n2. 静态生成 SSG(Static Site Generation)是指在应用编译构建时预先渲染页面，并生成静态的 HTML。把生成的 HTML 静态资源部署到服务器后，浏览器不仅首次能请求到带页面内容的 HTML ，而且不需要服务器实时渲染和响应，大大节约了服务器运维成本和资源。\nNext.js 默认为每个页面开启 SSG。对于页面内容需要依赖静态数据的场景，允许在每个页面中 export 一个 getStaticProps 异步函数，在这个函数中可以把该页面组件所需要的数据收集并返回。当 getStaticProps 函数执行完成后，页面组件就能在 props 中拿到这些数据并执行静态渲染。\n举个在静态路由中使用 SSG 的例子：\n// pages/posts/first-post.jsfunction Post(props) &#123;\tconst &#123; postData &#125; = props;    return &lt;div&gt;&#123;postData.title&#125;&lt;/div&gt;&#125;export async function getStaticProps() &#123;  // 模拟获取静态数据\tconst postData = await getPostData();  return &#123;  \tprops: &#123; postData &#125;  &#125;&#125;\n\n\n\n动态路由的场景:\n// pages/posts/[id].jsfunction Post(props) &#123;\tconst &#123; postData &#125; = props;  return &lt;div&gt;&#123;postData.title&#125;&lt;/div&gt;&#125;export async function getStaticPaths() &#123;  // 返回该动态路由可能会渲染的页面数据，比如 params.id  const paths = [    &#123; params: &#123; id: &#x27;ssg-ssr&#x27; &#125;&#125;,    &#123; params: &#123; id: &#x27;pre-rendering&#x27; &#125;&#125;  ]  return &#123;    paths,    // 命中尚未生成静态页面的路由直接返回 404 页面    fallback: false  &#125;&#125;export async function getStaticProps(&#123; params &#125;) &#123;  // 使用 params.id 获取对应的静态数据  const postData = await getPostData(params.id)  return &#123;    props: &#123;      postData    &#125;  &#125;&#125;\n\n当我们执行 nextjs build 后，可以看到打包结果包含 pre-rendering.html 和 ssg-ssr.html 两个 HTML 页面，也就是说在执行 SSG 时，会对 getStaticPaths 函数返回的 paths 数组进行循环，逐一预渲染页面组件并生成 HTML。\n├── server|  ├── chunks|  ├── pages|  |  ├── api|  |  ├── index.html|  |  ├── index.js|  |  ├── index.json|  |  └── posts|  |     ├── [id].js|  |     ├── first-post.html|  |     ├── first-post.js|  |     ├── pre-rendering.html       # 预渲染生成 pre-rendering 页面|  |     ├── pre-rendering.json|  |     ├── ssg-ssr.html             # 预渲染生成 ssg-ssr 页面|  |     └── ssg-ssr.json\n\nSSG 虽然很好解决了白屏时间过长和 SEO 不友好的问题，但是它仅仅适合于页面内容较为静态的场景，比如官网、博客等。\n面对页面数据更新频繁或页面数量很多的情况，它似乎显得有点束手无策，毕竟在静态构建时不能拿到最新的数据和无法枚举海量页面。这时，就需要增量静态再生成(Incremental Static Regeneration)方案了。\n3. 增量静态再生 ISR(Incremental Static Regeneration)允许在应用运行时再重新生成每个页面 HTML，而不需要重新构建整个应用。\n。这样即使有海量页面，也能使用上 SSG 的特性。一般来说，使用 ISR 需要 getStaticPaths 和 getStaticProps 同时配合使用。举个例子：\n// pages/posts/[id].jsfunction Post(props) &#123;\tconst &#123; postData &#125; = props;  return &lt;div&gt;&#123;postData.title&#125;&lt;/div&gt;&#125;export async function getStaticPaths() &#123;  const paths = await fetch(&#x27;https://.../posts&#x27;);  return &#123;    paths,    // 页面请求的降级策略，这里是指不降级，等待页面生成后再返回，类似于 SSR    fallback: &#x27;blocking&#x27;  &#125;&#125;export async function getStaticProps(&#123; params &#125;) &#123;  // 使用 params.id 获取对应的静态数据  const postData = await getPostData(params.id)  return &#123;    props: &#123;      postData    &#125;,    // 开启 ISR，最多每10s重新生成一次页面    revalidate: 10,  &#125;&#125;\n\n在应用编译构建阶段，会生成已经确定的静态页面，和上面 SSG 执行流程一致。\n在 getStaticProps 函数返回的对象中增加 revalidate 属性，表示开启 ISR。\n在上面的例子中，指定 revalidate = 10，表示最多10秒内重新生成一次静态 HTML。当浏览器请求已在构建时渲染生成的页面时，首先返回的是缓存的 HTML，10s 后页面开始重新渲染，页面成功生成后，更新缓存，浏览器再次请求页面时就能拿到最新渲染的页面内容了。\n对于浏览器请求构建时未生成的页面时，会马上生成静态 HTML。在这个过程中，getStaticPaths 返回的 fallback 字段有以下的选项：\n\nfallback: &#39;blocking&#39;：不降级，并且要求用户请求一直等到新页面静态生成结束，静态页面生成结束后会缓存\nfallback: true：降级，先返回降级页面，当静态页面生成结束后，会返回一个 JSON 供降级页面 CSR 使用，经过二次渲染后，完整页面出来了\n\n在上面的例子中，使用的是不降级方案(fallback: &#39;blocking&#39;)，实际上和 SSR 方案有相似之处，都是阻塞渲染，只不过多了缓存而已。\n也不是所有场景都适合使用 ISR。对于实时性要求较高的场景，比如新闻资讯类的网站，可能 SSR 才是最好的选择。\n总结\n静态生成是在构建时生成 HTML 的预呈现方法。然后在每个请求上重新使用预呈现的 HTML。\n服务器端呈现是在每个请求上生成 HTML 的预呈现方法。\n\n","categories":["React"],"tags":["Next.js"]},{"title":"Jest 单元测试-基础","url":"/2022/08/19/Jest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E5%9F%BA%E7%A1%80/","content":"\n\n1、一个简单的测试例子创建项目：\nyarn init -y\n\n安装jest库：\nyarn add jest -D\n\njest不支持es-module，可添加如下包：\nyarn add --dev babel-jest @babel/core @babel/preset-env\n\n添加.babelrc\n&#123;  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;,      &#123;        &quot;targets&quot;: &#123;          &quot;node&quot;: &quot;current&quot;        &#125;      &#125;    ]  ]&#125;\n\npackage.json添加命令：\n&quot;scripts&quot;: &#123;  &quot;test&quot;: &quot;jest&quot;&#125;,\n\n新建一个math.js\nconst sum = (a, b) =&gt; a + b;// module.exports = &#123; sum &#125;export &#123; sum &#125;\n\n新建一个math.test.js\n// const &#123; sum &#125; = require(&#x27;./math.js&#x27;);import &#123; sum &#125; from &#x27;./math.js&#x27;;describe(&#x27;Math module&#x27;, () =&gt; &#123;  test(&#x27;should return sum result when two number plus&#x27;, () =&gt; &#123;    const a = 1;    const b = 2;    const result = sum(a, b);    expect(result).toBe(3);  &#125;)&#125;)\n\n执行 yarn test，测试通过。\n常用方法：\n.toBe(value)\t严格相等\n.toEqual(vlaue)\t对象之间的值是否相等，而不是引用相等\n.toBeFalsy()\t判断boolean值\n.toHaveLength(number)\t数组长度\n.toHaveBeenCalled()\t当前方法是否被调换用\n.toHaveBeenCalledTimes(number)\t当前方法被调换用的次数\n.toThrow(error?)\t是否有没有异常\n.toMatchSnapshot(propertyMatchchers?, hint?)\t与上一次快照结果是否相等\n.toMatchInlineSnapshot(propertyMatchers?, inlineSnapshot)\nexpect.extend(matchers)\t扩展断言器\n\n2、jest.mock作用：1.可以mock掉 某个依赖文件中的方法\n\n\n\n新建两个文件\nservice.js：\nexport const getNames = () =&gt; []\n\nsearchName.js：\n// 表示接口数据，这里的为空数组 []import &#123; getNames &#125; from &quot;./service&quot; /// 根据关键字搜索name，结果最多显示3个export const searchNames = (term) =&gt; &#123;  const matches = getNames().filter(names =&gt; names.includes(term));  return matches.length &gt; 3 ? matches.slice(0, 3) : matches;&#125;export const functionNotTested = (term) =&gt; &#123;  return `Hello $&#123;term&#125;`&#125;\n\n\n\n编写测试用例 searchName.test.js：\n用例一：\nimport &#123; searchNames &#125; from &quot;./searchName&quot;;test(&quot;should return search results&quot;, () =&gt; &#123;  const keyword = &#x27;Frank&#x27;;  const result = searchNames(keyword);  expect(result).toEqual([]);&#125;)\n\n用例二：jest.mock。只想测试searchNames的功能，并不想知道它所依赖的service.js里面的getNames是怎么实现的，这时候可以用的jest.mock来mock掉service.js里面的getNames\njest.mock(&#x27;./service.js&#x27;, () =&gt; (&#123;  getNames: jest.fn(() =&gt; [&#x27;John&#x27;, &#x27;Paul&#x27;, &#x27;George&#x27;, &#x27;Ringo&#x27;])&#125;))test(&quot;should return target result when found search&#x27;&quot;, () =&gt; &#123;  const keyword = &#x27;John&#x27;;  const result = searchNames(keyword);  expect(result).toEqual([&#x27;John&#x27;]);&#125;)\n\n\n\n3、fn.mockImplementation使用fn.mockImplementation通过实现的方式给方法初始值。\n重写以上代码：\nimport &#123; searchNames &#125; from &quot;./searchName&quot;;import &#123; getNames &#125; from &quot;./service&quot;;jest.mock(&#x27;./service.js&#x27;, () =&gt; (&#123;  getNames: jest.fn()&#125;))test(&quot;should return search result&quot;, () =&gt; &#123;  const keyword = &#x27;Frank&#x27;;  getNames.mockImplementation(() =&gt; []);  const result = searchNames(keyword);  expect(result).toEqual([]);&#125;)test(&quot;should return target result when found search&quot;, () =&gt; &#123;  const keyword = &#x27;John&#x27;;  getNames.mockImplementation(() =&gt; [&#x27;John&#x27;, &#x27;Paul&#x27;, &#x27;George&#x27;, &#x27;Ringo&#x27;]);  const result = searchNames(keyword);  expect(result).toEqual([&#x27;John&#x27;]);&#125;)\n\n\n\n剩下几种情况的测试用例：\ntest(&quot;should not return more than 3 matches&quot;, () =&gt; &#123;  const keyword = &#x27;John&#x27;;  getNames.mockImplementation(() =&gt; [    &#x27;John&#x27;,    &#x27;John Wick 1&#x27;,    &#x27;John Wick 2&#x27;,    &#x27;John Wick 3&#x27;,    &#x27;Paul&#x27;,    &#x27;George&#x27;,    &#x27;Ringo&#x27;  ])  const result = searchNames(keyword);  expect(result).toHaveLength(3);&#125;)test(&#x27;should handle null or undefined as input&#x27;, () =&gt; &#123;  getNames.mockImplementation(() =&gt; []);  expect(searchNames(undefined)).toEqual([])  expect(searchNames(null)).toEqual([])&#125;)test(&#x27;should return serach result is case sensitive&#x27;, () =&gt; &#123;  getNames.mockImplementation(() =&gt; [&#x27;John&#x27;, &#x27;Paul&#x27;, &#x27;George&#x27;, &#x27;Ringo&#x27;]);  expect(searchNames(&#x27;john&#x27;)).toEqual([])&#125;)test(&#x27;should return serach result is case sensitive&#x27;, () =&gt; &#123;  expect(functionNotTested(&#x27;John&#x27;)).toEqual(&#x27;Hello John&#x27;);&#125;)\n\n\n\n4、toMatchInlineSnapshot()toMatchSnapshot：生成测试快照文件；\ntoMatchInlineSnapshot：避免生成比较大的测试文件\n使用toMatchInlineSnapshot快照测试，将预期值直接填入\ntest(&#x27;should say hi when search&#x27;, () =&gt; &#123;  const result = functionNotTested(&#x27;John&#x27;);  expect(result).toMatchInlineSnapshot();&#125;)\n\n运行 yarn test 之后就，会得到一下代码:\ntest(&#x27;should say hi when search&#x27;, () =&gt; &#123;  const result = functionNotTested(&#x27;John&#x27;);\texpect(result).toMatchInlineSnapshot(`&quot;Hello John&quot;`);&#125;\n\n\n\n5、介绍一个新命令，可以查看测试覆盖率：yarn test --coverage\n\n同时，会在项目目录下生成一个coverage文件夹，可以打开lcov-report/index.html查看测试覆盖率\n使用testing-library做UI测试\n查询组件渲染元素的方法：\n\n\n\ntype\nNo Match\n1 Match\n1+Match\nAwait?\n\n\n\ngetBy\nthrow\nreturn\nthrow\nNo\n\n\nfindBy\nthrow\nreturn\nthrow\nYes\n\n\nqueryBy\nnull\nreturn\nthrow\nNo\n\n\ngetAllBy\nthrow\narray\narray\nNo\n\n\nfindAllBy\nthrow\narray\narray\nYes\n\n\nqueryAllBy\n[]\narray\narray\nNo\n\n\nuserEvent.click();userEvent.dbClick();userEvent.type();userEvent.keyboard();userEvent.upload();userEvent.clear();userEvent.selectOptions();userEvent.deSelectOptions();userEvent.tab();userEvent.hover();userEvent.unhover();userEvent.paste();\n\n\n\n\n\n\n\n","categories":["测试"],"tags":["Jest"]},{"title":"React VS Vue","url":"/2022/06/24/React%20VS%20Vue/","content":"\n\n\n一、组件化共同点：react和vue都推崇组件化，通过将页面拆分成一个一个小的可复用单元来提高代码的复用率和开发效率。\n都有父子组件传参，都有数据状态管理，都有前端路由等。\n不同点：\nReact推荐的做法是JSX\nVue 推荐的做法是 template 的单文件组件格式\n\n二、虚拟DOM\n虚拟dom是一个js对象，存储在内存之中。\n虚拟dom能够描述真实dom（存在一个对应关系）\n当数据变化的时候，生成新的DOM，对比新旧虚拟DOM的差异，将差异更新到真实DOM上\n\n优点：\n减少 DOM 操作：虚拟 DOM 可以将多次 DOM 操作合并为一次操作\n研发效率的问题：数据驱动视图，使得前端开发能够基于函数式 UI 的编程方式实现高效的声明式编程。\n跨平台的问题：同一套虚拟 DOM，可以对接不同平台的渲染逻辑，从而实现“一次编码，多端运行”。\n\n相同点：不管是Vue的Template模板+options api 写法， 还是React的Class或者Function写法,最后都是生成render函数，而render函数执行返回VNode(虚拟DOM的数据结构，本质上是棵树)。\n当每一次UI更新时，总会根据render重新生成最新的VNode，然后跟以前缓存起来老的VNode进行比对，再使用Diff算法（框架核心）去真正更新真实DOM\n差异：更新策略不同：\n按颗粒度分为tree diff, component diff, element diff. tree diff 比较同层级dom节点，进行增、删、移操作。如果遇到component， 就会重新tree diff流程。\n在react中，当状态发生改变时，组件树就会自顶向下的全diff, 重新render页面， 重新生成新的虚拟dom tree, 新旧dom tree进行比较， 进行patch打补丁方式，局部更新dom。所以react为了避免父组件更新而引起不必要的子组件更新， 可以在shouldComponentUpdate做逻辑判断，减少没必要的render， 以及重新生成虚拟dom，做差量对比过程。\n在vue中， 通过Object.defineProperty 把 data 属性全部转为 getter&#x2F;setter。同时watcher实例对象会在组件渲染时，将属性记录为dep, 当dep 项中的 setter被调用时，通知watch重新计算，使得关联组件更新。\n三、数据驱动视图vue中的数据驱动视图Vuejs的数据驱动是通过MVVM这种框架来实现的。MVVM框架主要包含3个部分:model、view和 viewModel。\n首先，vuejs在实例化的过程中，会对遍历传给实例化对象选项中的data 选项，遍历其所有属性并使用 Object.defineProperty 把这些属性全部转为 getter&#x2F;setter。\n同时每一个实例对象都有一个watcher实例对象，他会在模板编译的过程中,用getter去访问data的属性，watcher此时就会把用到的data属性记为依赖，这样就建立了视图与数据之间的联系。当之后我们渲染视图的数据依赖发生改变（即数据的setter被调用）的时候，watcher会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染。这样就实现了所谓的数据对于视图的驱动。\nReact的数据驱动视图：首先了解一些列内容：\n\npending：当前所有等待更新的state队列。\nisBatchingUpdates：React中用于标识当前是否处理批量更新状态，默认false。\ndirtyComponent：当前所有待更新state的组件队列。\n\nReact通过setState实现数据驱动视图，通过setState来引发一次组件的更新过程从而实现页面的重新渲染(除非shouldComponentUpdate返回false)。\n\nsetState()首先将接收的第一个参数state存储在pending队列中；（state）\n判断当前React是否处于批量更新状态，是的话就将需要更新state的组件添加到dirtyComponents中；（组件）\n不是的话，它会遍历dirtyComponents的所有组件，调用updateComponent方法更新每个dirty组件（开启批量更新事务）\n\n","categories":["React"],"tags":["React"]},{"title":"React 知识点总结","url":"/2022/11/11/React%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","content":"\n\n![image-20230422145757216](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230422145757216.png)\nReact 副作用：是在组件渲染期间发生的任何操作，这些操作不仅仅是更新 DOM。副作用可能包括网络请求、访问本地存储、添加或删除事件监听器等。副作用是与 React 的声明式编程模型相对的\n什么是React\nReact 是一个网页UI框架，通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。\n它的核心设计思路有三点，分别是声明式、组件化与通用性。\n声明式的优势在于直观与组合。\n组件化的优势在于视图的拆分与模块复用，可以更容易做到高内聚低耦合。\n通用性在于一次学习，随处编写。比如 React Native，React 360 等，这里主要靠虚拟 DOM 来保证实现。\n这使得 React 的适用范围变得足够广，无论是 Web、Native、VR，甚至 Shell 应用都可以进行开发。这也是 React 的优势。\n但作为一个视图层的框架，React 的劣势也十分明显。它并没有提供完整的一揽子解决方案，在开发大型前端应用时，需要向社区寻找并整合解决方案。虽然一定程度上促进了社区的繁荣，但也为开发者在技术选型和学习适用上造成了一定的成本。\n\n什么是JSXReact本身并不强制使用JSX：class Hello extends React.Component&#123;  render() &#123;    return React.createElement(    \t&#x27;div&#x27;,      null,      `hello $&#123;this.props.toWhat&#125;`    );  &#125;&#125;ReactDOM.render(\tReact.createElement(Hello, &#123;toWhat, &#x27;World&#x27;&#125;, null),  document.getElementById(&#x27;root&#x27;))\n\nReact 需要将组件转化为虚拟 DOM 树；\nXML在树结构的描述上天生具有可读性强的优势。\nclass Hello extends React.Component&#123;  render() &#123;    return &lt;div&gt;Hello &#123;this.props.toWath&#125;&lt;/div&gt;  &#125;&#125;ReactDOM.render(  &lt;Hello toWhat=&quot;world&quot;/&gt;  document.getElementById(&#x27;root&#x27;))\n\n模板以AngularJS 为例\n&lt;!doctype html&gt;&lt;htmlng-app=&quot;docsBindExample&quot;&gt;\t&lt;head&gt;    &lt;script src=&quot;http://code.angularjs.org/1.2.25/angular.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;scriptjs&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;div ng-controller&quot;Ctrl1&quot;    Hello &lt;input ng-model=&#x27;name&#x27;&gt; &lt;hr/&gt;    &lt;span ng-bind=&quot;name&quot;&gt;&lt;/span&gt; &lt;br/&gt;    &lt;span ng:bind=&quot;name&quot;&gt;&lt;/span&gt; &lt;br/&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/htmlgn-app&gt;\n\n\n\n模板字符串var box = jsx`\t&lt;$&#123;Box&#125;&gt;\t$&#123;\t\tshouldShowAnswer(user) ?    jsx`&lt;$&#123;Answer&#125;&gt;&lt;/$&#123;Answer&#125;&gt;` :\t\tjsx`&lt;$&#123;Box.Comment&#125;&gt;Text Content&lt;/$&#123;Box.Comment&#125;&gt;`\t&#125;\t&lt;/$&#123;Box&#125;&gt;`;\n\n\n\n总结\n\n\nJSX 是一个 JavaScript 的语法扩展，结构类似于XML。\n\nJSX主要用来声明React元素，但React并取强制要求是用JSX，即使使用了JSX，也会在构建的过程中通过babel插件转化为React.CreateElement，所以JSX更像是React.CreateElement的语法糖，可以看出React团队并不想引入JavaScript本身以外的开发体系，而是通过合理的关注点分离保持组件开发的纯粹性。\n\n对比\n\n模板：引入模板语法和模板指令等概念是一种不佳的实现方案；\n模板字符串：造成多次嵌套，使整个结构变的复杂，并且优化代码提示也会变的困难重重\nJXON：同样因为语法提示问题被React放弃\n\n\n\n最后选用了JSX，因为JSX与其设计思想贴合，不需要引入过多新的概念，对代码编辑器的提示也极为友好。\n如何避免生命周期的坑\n在不恰当的时机调用了不合适的代码\n在需要调用时，却忘记了调用\n\n建立时机与操作的对应关系\n\n\n\n\n\n\n\n社区中去除 constructor 的原因\nconstructor 中并不推荐去处理初始化以外的逻辑；\nconstructor 不属于 React 的生命周期，只是 Class 的初始化函数；\n通过移除 constructor，代码也会变得更简洁；\n\n挂载阶段getDerivedStateFromPorps本函数的作用是使组件在 props 变化时更新 state。\n触发时机：（只要父级组件重新渲染时就会被调用）\n\n当 props 被传入时；\nstate 发生改变时；\nforceUpdate 被调用时；\n\n&#x3D;&#x3D;你可能不需要使用派生state&#x3D;&#x3D;。两种反模式使用方式：\n\n直接复制 props 到 state\n在 props 变化后修改 state\n\n这两种写法，&#x3D;&#x3D;除了增加代码的维护成本外，没有任何好处&#x3D;&#x3D;。\nUNSAFE_componentWillMount用于组件将加载前做某些操作，但目前被标记为弃用。因在 React 异步渲染机制下，该方法&#x3D;&#x3D;可能被多次调用&#x3D;&#x3D;。\n常见的错误是：和服务器端同构渲染的时候，如果在该函数里面发起网络请求，会在服务端和客户端分别执行一次。\nrenderrender 函数返回的 JSX 结构，用于描述具体的渲染内容。\n不应该在render 函数里面产生任何副作用，比如使用setState或者绑定事件。\nrender函数在每次渲染时都会被调用，而setState会触发渲染，会造成死循环。绑定事件会被频繁调用注册。\n更新阶段指外部 props 传入，或 state 发生变化时的阶段。\n\n\n\n\nUNSAFE_componentWillReceiveProps：在getDerivedStateFromPorps存在时，不会被调用。\nUNSAFE_componentWillUpdate：因为在后续的React异步渲染设置中，可能会&#x3D;&#x3D;出现暂停更新渲染&#x3D;&#x3D;的情况；\ngetSnapshotBeforeUpdate： 返回值会作为 componentDidUpdate 的第三个参数使用。\n卸载阶段componentWillUnmount\n主要用于执行清理工作。一定要在该阶段解除事件绑定，取消定时器。\n不然会导致定时器在组件销毁后一直在不停地执行；\n职责：\n什么情况下会触发重新渲染？\n渲染中发生报错后会怎样? 该如何处理?\n\n函数组件：任何情况下都会重新渲染，没有生命周期，官方提供React.memo优化手段。\nReact.memo并不是阻断渲染，而是&#x3D;&#x3D;跳过渲染组件的操作，并直接复用最后一次渲染的结果&#x3D;&#x3D;\nReact.Component：不实现 shouldComponentUpdate 函数，有两种情况触发重新渲染\n\n当 state 发生变化时\n当父级组件的 Props 传入时\n\nReact.PureComponent：默认实现了 shouldComponentUpdate 函数仅在 props 与 state 进行浅比较后，确认有变更时才会触发重新渲染。\n错误边界：class ErrorBoundary extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123; hasError: false &#125;;  &#125;    static getDerivedStateFromError(error) &#123;\t\t// 更新state使下一次渲染能够显示降级后的UI    return &#123; hasError: true &#125;  &#125;  \tcomponentDidCatch(error, info) &#123;    // Display fallback UI    this.setState(&#123; hasError: true &#125;);    // You can also log the error to an error reporting service    logErrorToMyService(error, info);  &#125;&#125;\n\ncomponentDidCatch：捕获报错的具体类型，并将错误类型上传到服务端去。\n用户执行某个操作时，触发了bug，引发了崩溃，页面会突然白屏，但渲染时的报错，只能通过 componentDidCatch 捕获。这是在做线上错误监控时，极其容易忽略的点。\nReact 的请求应该放在哪里，为什么？对于异步请求，应放在 componentDidMount 中操作从时间顺序看，除 componentDidMount 还可以有以下选择：\n\nconstructor：可放，从设计言不推荐，主要用于初始化 state 与函数绑定，不承载业务逻辑且随着类属性流行，constructor 已很少用\ncomponentWillMount：已被标记废弃，在新的异步渲染架构下会触发多次渲染，易引发 Bug，不利未来 React 升级后的代码维护\n\n类组件和函数组件的区别？相同点：函数组件和类组件&#x3D;&#x3D;使用方式&#x3D;&#x3D;和&#x3D;&#x3D;最终呈现效果&#x3D;&#x3D;上是完全一致的。\n很难从使用体验上区分两者，而且现代浏览器，闭包和类的性能是在极端场景下才会有区别。所以基本认为两者作为组件是完全一致的。\n不同点：基础认知：本质上代表两种&#x3D;&#x3D;不同设计思想&#x3D;&#x3D;与心智模式\n\n类组件的根基是 OOP，面向对象编程；\n函数组件的根基是 FP，也就是函数式编程；\n\n函数式编程：假定输入和输出，存在某种特定的映射关系时，那么输入一定的情况下，输出必然是确定的。\n本质上，最大的不同：&#x3D;&#x3D;相较于类组件，函数组件更纯粹、简单、易测试&#x3D;&#x3D;。\n使用场景：\n\n在不使用 Recompose 或者 Hooks 的情况下如需使用生命周期，就用类组件，限定场景是固定的。\n在 recompose 或 Hooks 的加持下，类组件与函数组件的能力边界完全相同，都可使用类似生命周期等能力\n\n设计模式：\n\n类组件可以实现继承\n函数组件缺少继承能力\n\nReact不推荐使用继承，组合由于继承\n未来趋势：\n&#x3D;&#x3D;函数组件&#x3D;&#x3D;成为了社区未来主推的方案。\n类组件不能适应未来趋势的原因：\n\nthis 的模糊性\n业务逻辑散落在生命周期中\nReact组件，代码缺少标准的拆分方式\n\n使用Hooks函数组件可以提供比原生更细腻的逻辑组织与复用，而且能更好的适应时间切片与并发模式。\n如何设计React组件\n把只作展示、独立运行、不额外增加功能的组件，称为哑组件或无状态组件、&#x3D;&#x3D;展示组件&#x3D;&#x3D;；\n把处理业务逻辑与数据状态的组件称为有状态组件、&#x3D;&#x3D;灵巧组件&#x3D;&#x3D;。灵巧组件一定包含至少一个灵巧组件或展示组件。\n\n展示组件展示组件受制于外部的 props 控制，具有极强的通用性，复用率很高\n代理组件：常用于封装常用属性，减少重复代码。\n即对UI库的二次封装，对于常用属性给默认值，如果需要修改属性，直接传入props覆盖默认值即可。\n虽然这样的封装看起来多此一举，但是切断了外部组件的强依赖性。\n两个问题：\n\n如果当前组件库不能使用，是否能实现业务上的无痛切换；\n如需批量修改基础组件的字段，如何解决?\n\n&#x3D;&#x3D;代理组件的设计模式&#x3D;&#x3D;很好地解决了以上问题业务上看，代理组件隔绝 Antd，仅是一个组件 Props API 层的交互\n样式组件：也是一种代理组件，只是又细分了处理样式领域，将当前的关注点分离到当前组件内\n\n\n复杂的样式管理对于Button是没有意义的，如果直接使用Button在属性上进行修改，对于工程代码而言，这是编写大量的面条代码。StyleButton的思路就是，样式判断逻辑附令到自身上来，面向未来改动的时候会更加友好。\n布局组件基本设计与样式组件完全一样，基于自身特性做了一个小小的优化\n灵巧组件灵巧组件面向业务，功能更丰富、复杂性更高，复用度更低；\n展示组件专注于组件本身特性，灵巧组件专注于组合组件。\n容器组件几乎没有复用性，主要用在拉取数据与组合组件两个方面。（没有冗余的样式和逻辑处理）\n高阶组件：React 中复用组件逻辑的高级技术，是基于 React 的组合特性形成的设计模式；\n高阶组件的参数是组件，返回值为新组件的函数。\n作用：\n\n逻辑复用\n链式调用\n渲染劫持\n\n例子：登录态的判断。【数据埋点】\n\n\n\n\n例子：渲染劫持\n通过控制 render 函数修改输出内容，常见的场景是显示加载元素\n\n\n\n\n缺陷：\n丢失静态函数\nrefs属性不能透传\n\n使用Storybook工具对basic组件进行组件管理\nsetState 是同步更新还是异步更新合成事件：\nReact 给 document 挂上事件监听\nDOM 事件触发后冒泡到 document\nReact 找到对应的组件造出一个合成事件出来\n并按组件树模拟一遍事件冒泡\n\nReact 17 之前的事件冒泡流程图：事件委托挂载在document上\n\n\nReact 17 之后的事件冒泡流程图：事件委托不再挂载在document上，而是挂载在DOM容器上\n\n\n\n\nclass Coun t extends Component&#123;  state = &#123;    count:0  &#125;  \t  componentDidMount()&#123;    this.setState(&#123;      count: this.state.count + 1    &#125;, () =&gt; &#123;      console.log(this.state.count) // 1    &#125;)\t    this.setState(&#123;      count: this.state.count + 1    &#125;, () =&gt; &#123;      console.log(this.state.count) // 1    &#125;)  &#125;     componentDidMount()&#123;    this.setState(preState =&gt; &#123;      count: preState.count + 1    &#125;, () =&gt; &#123;      console.log(this.state.count) // 1    &#125;)\t    this.setState(preState =&gt; &#123;      count: preState.count + 1    &#125;, () =&gt; &#123;      console.log(this.state.count) // 2    &#125;)  &#125;  &#125;\n\n是否觉得 React 的 setState 执行像是一个队列?React 根据队列逐一执行，合并 state 数据完成后执行回调，根据结果更新虚拟 DOM触发渲染。\n异步更新（非真异步）——原因：\n\n保持内部的一致性（如果把setState改成同步了，但是props不是）\n启用并发更新\n\n在源码中，通过isBatchingUpdates判断setStates是先存进队列还是直接更新。true：执行异步操作，false：直接更新。\n在 React 的生命周期事件和合成事件中可拿到isBatchingUpdates 控制权将状态放进队列，控制执行节奏。\nsetState 之后发生了什么React 利用状态队列机制实现了 setState 的“异步”更新，避免频繁的重复更新 state。\n首先将新的 state 合并到状态更新队列中，然后根据更新队列和 shouldComponentUpdate 的状态来判断是否需要更新组件。\n在“异步”中，\n如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行；\n如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。\nclass Demo extends Component &#123;  state = &#123;    count: 1,    number: 2  &#125;  handleAdd = () =&gt; &#123;    this.setState(&#123; count: 2 &#125;)    this.setState(&#123; count: 3 &#125;)    this.setState(&#123;number: 100&#125;)    this.setState(&#123;number: 200&#125;)  &#125;  render() &#123;    const &#123; count, number &#125; = this.state;    console.log(count, number); // 点击之后，只会打印一次    return (      &lt;div&gt;        count: &#123;count&#125; - number: &#123;number&#125;        &lt;button onClick=&#123;this.handleAdd&#125;&gt;Add&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;\n\nsetState 本身代码的执行肯定是同步的，这里的异步是指是多个 state 会合成到一起进行批量更新。 同步还是异步取决于它被调用的环境。\n\n如果 setState 在 React 能够控制的范围被调用，它就是异步的；\n如果 setState 在原生 JavaScript 控制的范围被调用，它就是同步的；\n\n1.异步情况：在合成事件处理函数，生命周期函数\n2.同步情况：在原生事件处理函数，定时器回调函数，Ajax 回调函数\n//setTimeout事件import React,&#123; Component &#125; from &quot;react&quot;;class Count extends Component&#123;    constructor(props)&#123;        super(props);        this.state = &#123;            count:0        &#125;    &#125;     componentDidMount()&#123;        //自定义dom事件，也是同步修改        document.querySelector(&#x27;#btn&#x27;).addEventListener(&#x27;click&#x27;,()=&gt;&#123;            this.setState(&#123;                count: this.state.count + 1            &#125;);            console.log(this.state.count); // 1        &#125;);    &#125;     btnAction = ()=&gt;&#123;\t\t\t\t// 如果在这里执行setState，则是异步的；    \t\t            setTimeout(()=&gt;&#123;\t          // 这里则是同步的            this.setState(&#123;                count: this.state.count + 1            &#125;);            console.log(this.state.count); // 1        &#125;)    &#125;    render()&#123;        return (            &lt;&gt;                &lt;p&gt;count:&#123;this.state.count&#125;&lt;/p&gt;                &lt;button onClick=&#123;this.btnAction&#125;&gt;增加&lt;/button&gt;\t\t\t\t\t\t\t\t&lt;button id=&quot;btn&quot;&gt;绑定点击事件&lt;/button&gt;            &lt;/&gt;        )    &#125;&#125;export default Count;\n\n\n\n笔试题：\nclass Count extends Component&#123;  state = &#123;    count:0  &#125;  \t  componentDidMount()&#123;    this.setState(&#123; count: this.state.count + 1 &#125;) // this.state.count是0    console.log(this.state.count) // 0\t    this.setState(&#123; count: this.state.count + 1 &#125;) // 这里的 this.state.count 还是0    console.log(this.state.count) // 0        setTimeout(() =&gt; &#123;      this.setState(&#123; count: this.state.count + 1 &#125;) // 这里的 this.state.count 是 1    \tconsole.log(this.state.count) // 2            this.setState(&#123; count: this.state.count + 1 &#125;)    \tconsole.log(this.state.count) // 3\t    &#125;)  &#125;&#125;\n\n\n\n如果面向组件跨层通信\n\n\n\nContext 存储的变量难以追溯数据源以及确认变动点。当组件依赖Context时，会提升组件耦合度，不利于组件的复用与测试。\nVirtual DOM的工作原理是什么Fackbook的初衷\n\n简化前端开发\n防止XSS。\n\n&#x3D;&#x3D;通过虚拟DOM来规避风险&#x3D;&#x3D;。因为直接操作DOM会带来XSS的风险，也可能因为技术水平的限制，带来性能的问题。（如果你心爱的东西不喜欢有人去触碰，最好的办法是把它封起来，与使用者相隔离，因此有了我们今天看到的虚拟DOM）\n\nJSX 所描述的结构，会转译成 React.createElement 函数：\n\n// JSX描述&lt;input type=&quot;button&quot;/&gt;  // Babel转义后React.createElement(&#x27;input&#x27;, &#123; type: &#x27;button &#x27;&#125;)\n\n\nReact 会持有一颗虚拟 DOM 树。在状态变更后，会触发虚拟 DOM 树的修改，再以此为基础修改真实 DOM\n\nReact.createElement 返回的结果应是一个 JavaScript obiect\n&#123;  tag: &#x27;input&#x27;,  props: &#123;\t\ttype: &#x27;button&#x27;  &#125;,  children: []&#125;\n\ndiff 函数，去计算状态变更前后的虚拟 DOM 树差异；\n渲染函数，渲染整个虚拟 DOM 树或者处理差异点；\n优势\n性能优越\n规避XSS\n可跨平台（RN，小程序）\n\n边界：大量的直接操作 DOM 容易引起网页性能下降。这时 React 基于虚拟 DOM 的 diff 处理与批处理操作，可降低 DOM 的操作范围与频次，提升页面性能\n什么时候虚拟DOM慢呢？\n首次渲染或者微量操作的时候，虚拟DOM就会比真实的DOM更慢。\n虚拟 DOM 一定可以规避 XSS 吗?\n虚拟 DOM 内部确保字符转义，确实可做到这点，但 React 存在风险，因为 React 留有 dangerouslySetlnnerHTML API 绕过转义。\n跨平台的成本更低\n在 React Native 后，前端社区从虚拟 DOM 中体会到跨平台的无限前景，所以在后续发展中，都借鉴虚拟 DOM。\n缺点\n内存占用较高\n无法进行极致优化\n\n因为当前网页的虚拟DOM包含真实DOM的完整信息，而且由于是Object，内存占用肯定会有所上升。\n虽然虚拟DOM足以应对绝大部分应用的性能要求，但在一些性能要求高的应用中无法进行针对性的优化。\n与其他框架相比，React的diff有何不同diff算法是指，生成更新补丁的方式。主要应用于虚拟DOM树变化，更新真实DOM。\n\n真实的 DOM 首先会映射为虚拟 DOM；\n当虚拟 DOM 变化后，会根据差异计算生成 patch。patch 是结构化的数据，包含增加、更新、移除等；\n根据 patch 去更新真实的DOM，反馈到用户界面上\n\n![image-20230423111726301](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230423111726301.png)\ndiff算法：\n\n更新时机——触发更新、进行差异对比的时机。（setState，hooks调用之后，此时树的节点发生变化，开始比对）\n遍历算法——深度优先遍历\n优化策略\n\n\n深度优先遍历——从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止然后回溯前一个节点，进行右子树节点遍历，直到遍历完所有可达节点\n\n虽然深度优先遍历保证了组件的生命周期时序不错乱，但传统的 diff 算法带来一个严重的性能瓶颈，复杂程度为 O(n3)，其中 n 表示树的节点总数。\nReact 用了一个非常经典的手法将复杂度降低为 O(n)就是分治，即通过“分而治之”这一巧妙的思想分解问题。\n将单一节点比对，转化为了三种类型节点比对。React从&#x3D;&#x3D;树、组件、元素&#x3D;&#x3D;三个方面进行了优化。\n策略一：忽略节点跨层级操作场景，提升比对效率；需进行&#x3D;&#x3D;树比对&#x3D;&#x3D;，即对树进行分层比较两棵树&#x3D;&#x3D;只对同一层次节点进行比较&#x3D;&#x3D;，如发现节点已不存在则该节点及其子节点会被完全删除，不会用于进一步比较提升了比对效率\n策略二：如果组件的 class 一致，则默认为相似的树结构，否则默认为不同的树结构如果组件是同一类型则进行树比对，如果不是则直接放入补丁中。\n只要父组件类型不同，就会被重新渲染，这就是shouldComponentUpdate&#x2F;PureComponent&#x2F;React.memo可以提高性能的原因\n策略三：同一层级子节点，可通过标记 key 的方式进行列表对比。元素比对主要发生在同层级中，通过标记节点操作生成补丁。\n节点操作包含了插入、移动、删除等。\n其中节点排序，同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要的作用。\n通过标记 key 的方式，React 可以直接移动 DOM 节点，降低内耗\nFiberreact16引入了fiber机制，进行了优化。\n1、Fiber 机制下节点与树分别采用 FiberNode 与 FiberTree 进行重构\n\nFiberNode使用了双链表的结构，可以直接找到兄弟节点和子节点，使得整个更行过程可以随时暂停、恢复。\nFiberTree是通过FiberNode构成的树。\n\n2、Fiber 机制下整个更新过程由 current 与 worklnProgress 两株树，双缓冲完成\n\n当worklnProgress更新完成后，通过修改current的相关指针指向的节点，直接抛弃老树。虽然非常简单粗暴，却非常合理。\n\n其他框架PReact  diff 算法相较于React，整体设计思路相似。\n最层次的元素采用真实DOM对比操作，并没有采用Fiber的设计。\nVue 2.0 使用了 snabbdom，整体思路与 React 相同。\n但在元素对比时，如果新旧两元素是同一元素，且没有设置 key 时，snabbdom 在 diff 子元素中会一次性对比&#x3D;&#x3D;旧节点&#x3D;&#x3D;、&#x3D;&#x3D;新节点&#x3D;&#x3D;及它们的&#x3D;&#x3D;首尾元素&#x3D;&#x3D;四个节点，以及&#x3D;&#x3D;验证列表&#x3D;&#x3D;是否有变化。\nVue3.0 整体变化不大。\n最后\nReact拥有完整的diff算法策略，且拥有随时中断更新的时间切片能力。在大批量更新的极端情况下，拥有更友好的交互体验。\nPReact可以在一些对性能要求不高，仅需要渲染的简单场景下使用。\nVue的diff策略整体与React对齐，虽然缺乏时间切片能力，但并不意味这Vue的性能更差，因为在Vue3初期引入过，后来因为收益不高移除掉了。除了高帧率动画、其他场景几乎都可以防抖节流去提高乡音性能。\n如何根据React diff算法原理优化代码？\n根据 diff 算法的设计原则，应尽量避免跨层级节点移动，\n通过设置唯一 key 进行优化，尽量减少组件层级深度，因为过深的层级会加深遍历深度，带来性能问题\n设置 shouldComponentUpdate 或者 React.pureComponet 减少 diff 次数\n\nReact的渲染异常会造成什么后果“错误边界” 相关内容：如果渲染异常，在没有任何降级保护措施的情况下，页面会直接显示白屏。\n通用方案：getDerivedStateFromError&#x2F;componentDidCatch\ngetDerviedStateFromError和componentDidCatch的区别是前者展示降级UI，后者记录具体的错误信息，它只能用于class组件\nclass ErrorBoundary extends React.Component&#123;  constructor(props)&#123;    super(props)    this.state=&#123;      hasError:false    &#125;  &#125;  staic getDerivedStateFromError()&#123;    return &#123; hasError:true&#125;  &#125;  componentDidCatch(err,info)&#123;    console.error(err,info)  &#125;  render()&#123;    if(this.state.hasError)&#123;      return &lt;div&gt;Oops,err&lt;/div&gt;    &#125;    return this.props.children  &#125;&#125;\n\n&#x3D;&#x3D;错误边界无法捕获自身的错误，也无法捕获事件处理、异步代码(setTimeout、requestAnimationFrame)、服务端渲染的错误&#x3D;&#x3D;\n预防在渲染层，render 中 return 后的 JSX，都是在进行数据的拼装与转换\n\n如果在拼装的过程中出现错误，那直接会导致编译的失败\n但如果在转换的过程中出现错误，就很不容易被发现\n\n前端数据基本上都是通过后端业务接口获取，那么是数据否可靠，就成为了一个至关重要的问题。\n这个问题被称为null-safety，也就是空安全，目前对于这个问题比较成熟的解决方案是使用idx\nidx 在使用时需要配置 Babel 插件，再引入idx 库。然后通过 idx 函数包裹需要使用的 object，再在回调函数中取需要的值。\nidx的代码既不优雅，也不简洁，还需要引入babel插件，所以使用者寥寥无几。\n优雅的解决方案：Es202，可选链操作符\n兜底应该限制崩溃的层级。错误边界加到哪里，崩溃就止步于哪里，其他组件还可正常使用；\n所以只需给关键的 UI 组件添加错误边界，那就可应用&#x3D;&#x3D;高阶组件（或者自定义hooks）&#x3D;&#x3D;\n需保障方案在项目中的覆盖量，统计兜底页面成功兜底次数，最后兜底页面展示时能及时完成线上报警。\n每个公司至少会接入统计工具，如百度统计、Google 统计完成业务分析，只需在代码中，添加一行统计代码\n如何提升React代码的可维护性1、预防与兜底预防：从上线前开始可对代码做哪些措施防止出现线上问题兜底：上线后又可以做哪些方案加快线上故障的定位速度\n预防通过使用人工或者工具审查的方式去实现。\n人工审查代码的方式，标准称谓是 Code Review基于React 写法的易错点，团队内部会总结出一些实践准则。\n工具审查的方式，标准称谓是静态代码检查工具（ESLint）\n兜底在线环境的代码通常是经过 UglifyJS &#x2F; terser混淆并压缩的，所以直接看报错信息不能得知对应的源码是什么样的，不利于排查问题。\n最理想的情况莫过于改造编译流水线，在发布过程中上传 sourcemap 到报错收集平台。\n在 Webpack 中添加 sourcemap 相关插件就可在编译过程，直接上传 sourcemap 到 Sentry 的报错平台\n\n\n在使用 Sentry 捕获报错时，就能够直接查看对应的源码了：\n\n\n使用 Mozilla 开源的工具 sourcemap，直接恢复对应的源代码信息。\n2、可改变性从代码层面来讲，可变性代表了代码的可拓展能力。\n两个思路提升代码的可拓展性：\n\n从组件的角度出发，通过分离容器组件与展示组件的方式分离模块。其中推荐了 Storybook 来沉淀展示组件。\n框架状态管理框架中有相对成熟的设计模式，比如 Redux 中的action、reducer 等，它的边界很清楚很容易明白业务逻辑该如何拆解、如何放入模块中。\n\n3、稳定性在前端项目中，无论是单元测试还是集成测试，整体覆盖比例都很低。常常通过人工测试“点点点”的方式保证稳定性。\n前端测试并不好写。针对 UI 层不好写：\n国内业务迭代模式都非常快，快到 UI层难以有稳定的测试代码，所以通常不会花太多时间去写组件的测试。基于实际情况，有条件写测试的话，也是尽量给核心业务写测试，更利于整体项目的稳定性。\n4、依从性遵循约定，提升代码可读性、减少人为因素，加强工具干预：\n\n针对样式的Stylelint\n针对JS的ESLint\n针对代码提交的commitlint\n针对编辑器风格的Editorconfig\n针对代码风格的Prettier\n\nReact Hooks使用限制有哪些？为什么使用Hooks1、组件之间难以复用状态逻辑如果涉及场景更复杂，多级组件需共享状态，就需使用 Redux 或 Mobx 来解决了。\n既然是每个人都遇到的问题，最好考虑从 React 层提供 API 来解决。（高阶组件）\n2、复杂的组件变得难以理解主要指出生命周期函数没能提供最佳的代码编程实践范式\n如 componentDidMount，在这里设置页面标题、拉取用户信息、拉取按钮权限信息。ComponentDidMount 函数内部逻辑随意堆砌，内容杂乱，缺乏专注性，往往还会对上下文产生依赖。\n在componentDidMount中使用事件注册、订阅消息等，都需要在componentWillUnmount中去取消它。订阅与取消订阅并没有直接关联在一起，而是通过生命周期函数去使用这非常的反模式，也就导致组件难以分解，且到处都是状态逻辑。\n3、人和机器都容易混淆类\nthis 首当其冲，值捕获的问题。\n还有一个与 this 相关的问题，就是用 bind 函数包一下来绑定事件。虽然现在通过了类属性方案，也可使用Babel 插件提前开发，但整个提案仍是草案阶段。\n在类中难以做编译优化，React 团队一直在做前端编译层的优化工作，如常数折叠、内联展开及死码删除。\n\n方案：\n不要在 React 的循环、条件或嵌套函数中调用 Hook。\n在React函数组件中调用Hook\n\n防范措施因 React 的内在设计原理，所以不可能绕过限制规则，但可在代码中禁止错误的使用方式。\n工程化的东西最终应落地到工具上，其实只需在 ESLint 中引入 eslint-plugin-react-hooks 完成自动化检查就可以了在处理代码编写方式问题时，应优先想到从 Lint 工具入手\nuseEffect 与 useLayoutEffect的区别相同点使用方式上：useLayoutEffect 的函数签名与 useEffect 相同，使用方式完全一致，甚至在一定程度上可以相互替换。\n运行效果：useEffect 与 useLayoutEffect 两者都是用于处理副作用。这些副作用包括改变 DOM、设置订阅、操作定时器等\n不同点使用场景：大多数场景下可直接使用 useEffect，但代码引起页面闪烁，就推荐使用useLayoutEffect 处理\n如有直接操作 DOM 样式或引起 DOM 样式更新的场景，更推荐使用 useLayoutEffect\n独有能力：\nEffect：异步处理副作用；\nLayoutEffect：同步处理副作用；\n\n设计原理标记为 HookLayout 的 effect 会在所有的 DOM 变更之后同步调用，所以可以使用它来读取 DOM 布局并同步触发重渲染。\n计算量较大的耗时任务必然会造成阻塞，所以就需根据实际情况酌情考虑。如果非必要情况下，使用标准的 useEffect 可以避免阻塞\nuseEffect 依赖为空数组与 componentDidMount 区别在 render 执行之后，componentDidMount 会执行，如果在这个生命周期中再一次 setState ，会导致再次 render ，返回了新的值，浏览器只会渲染第二次 render 返回的值，这样可以避免闪屏。\n但是 useEffect 是在真实的 DOM 渲染之后才会去执行，这会造成两次 render ，有可能会闪屏。\n实际上 useLayoutEffect 会更接近 componentDidMount 的表现，它们都同步执行且会阻碍真实的 DOM 渲染的。\n","categories":["React"],"tags":["React"]},{"title":"React 组件逻辑复用","url":"/2022/05/17/React%E7%BB%84%E4%BB%B6%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/","content":"\n\n1、HOC 高阶组件export const withSize = (Component) =&gt; &#123;  return class toSize extends React.Component &#123;    state = &#123;      xPos: document.documentElement.clientWidth,      yPos: document.documentElement.clientHeight    &#125;;      getPos = () =&gt; &#123;      this.setState(&#123;        xPos: document.documentElement.clientWidth,        yPos: document.documentElement.clientHeight      &#125;)    &#125;      componentDidMount() &#123;      window.addEventListener(&#x27;resize&#x27;, this.getPos);    &#125;      componentWillUnmount() &#123;      window.removeEventListener(&#x27;resize&#x27;, this.getPos);    &#125;    render() &#123;      return &lt;Component &#123;...this.state&#125;/&gt;    &#125;    &#125;&#125;\n\nconst SubWithFoo = withSize(Foo)const SubWithBar = withSize(Bar)export default class HOCPage extends React.Component &#123;  render() &#123;    return &lt;&gt;\t\t  &lt;SubWithFoo/&gt;      &lt;SubWithBar/&gt;    &lt;/&gt;  &#125;&#125;\n\n\n\n具体实践渲染劫持：可以根据部分参数去决定是否渲染组件。\nconst HOC = (WrappedComponent) =&gt;  return class extends WrappedComponent &#123;    render() &#123;      if (this.props.isRender) &#123;        return super.render();      &#125; else &#123;        return &lt;div&gt;Loading...&lt;/div&gt;;      &#125;    &#125;  &#125;\n\n\n\n权限控制：\nfunction AuthWrapper(WrappedComponent) &#123;  return class AuthWrappedComponent extends React.Component &#123;    state = &#123;      permissionDenied: -1,    &#125;;            render() &#123;      const &#123; permissionDenied &#125; = this.state;      if (permissionDenied === -1) &#123;        return null; // 鉴权接口请求未完成      &#125;      if (permissionDenied) &#123;        return &lt;div&gt;功能即将上线，敬请期待~&lt;/div&gt;;      &#125;      return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;    &#125;  &#125;&#125;\n\n\n\n登录态的判断：\nconst isLogin = !!localStorage.getItem(&#x27;token&#x27;);const checkLogin = (WrappedComponent) =&gt; &#123;  return (props) =&gt; &#123;    return (isLogin ? &lt;WrappedComponent &#123;...props&#125;/&gt; : &lt;LoginPage/&gt;)  &#125;&#125;class RawUserPage extends Component &#123;...&#125;const UserPage = checkLogin(RawUserPage);\n\n\n\n缺陷：\n丢失静态函数\nrefs属性不能透传\n\n丢失静态函数当我们应用HOC去增强另一个组件时，我们实际使用的组件已经不是原组件了，所以我们拿不到原组件的任何静态属性，我们可以在HOC的结尾手动拷贝他们：\nfunction proxyHOC(WrappedComponent) &#123;  class HOCComponent extends Component &#123;    render() &#123;      return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;    &#125;  &#125;  HOCComponent.staticMethod = WrappedComponent.staticMethod;  // ...   return HOCComponent;&#125;\n\nrefs属性不能透传使用高阶组件后，获取到的ref实际上是最外层的容器组件，而非原组件，但是很多情况下我们需要用到原组件的ref。\n高阶组件并不能像透传props那样将refs透传，我们可以用一个回调函数来完成ref的传递：\nfunction hoc(WrappedComponent) &#123;  return class extends Component &#123;    getWrappedRef = () =&gt; this.wrappedRef;    render() &#123;      return &lt;WrappedComponent ref=&#123;ref =&gt; &#123; this.wrappedRef = ref &#125;&#125; &#123;...this.props&#125; /&gt;;    &#125;  &#125;&#125;@hocclass Input extends Component &#123;  render() &#123; return &lt;input&gt;&lt;/input&gt; &#125;&#125;class App extends Component &#123;  render() &#123;    return (      &lt;Input ref=&#123;ref =&gt; &#123; this.inpitRef = ref.getWrappedRef() &#125;&#125; &gt;&lt;/Input&gt;    );  &#125;&#125;\n\n\n\n2、render propsclass MouseTracker extends React.Component &#123;  state = &#123;    x: 0,    y: 0,  &#125;  handleMouseMove = event =&gt; &#123;    this.setState(&#123;      x: event.clientX,      y: event.clientY,    &#125;)  &#125;  render() &#123;    return (      &lt;div onMouseMove=&#123;this.handleMouseMove&#125; &gt;        &#123;this.props.render(this.state)&#125;      &lt;/div&gt;    )  &#125;&#125;\n\nimport MouseTracker from &#x27;./MouseTracker&#x27;function Tracker() &#123;  return (    &lt;MouseTracker      render=&#123;props =&gt; (        &lt;div style=&#123;&#123; height: &#x27;100vh&#x27; &#125;&#125;&gt;          &#123;props.x&#125;,&#123;props.y&#125;        &lt;/div&gt;      )&#125;    /&gt;  )&#125;\n\n\n\n3、自定义Hooksexport const useTracking = () =&gt; &#123;  const [tracking, setTracking] = useState(&#123;&#125;);  useDeepEffect(    () =&gt; &#123;      switch (tracking.eventType) &#123;        case &#x27;pageview&#x27;:          gaPageView(tracking);          gaFunnelStep(tracking.funnelStep, tracking.eventName);          break;        default:          gaNewEvent(tracking);          break;      &#125;    &#125;,    [tracking],  );  // Return enabled state and setter for tracking  return [tracking, setTracking];&#125;;\n\nconst useError = () =&gt; &#123;  const &#123; setError, cleanError, cleanToastBanner &#125; = useContext(ErrorBoundaryContext);  return &#123; setError, cleanError, cleanToastBanner &#125;;&#125;;\n\n\n\n好处:\n\n跨组件复用: 其实 render props &#x2F; HOC 也是为了复用，相比于它们，Hooks 作为官方的底层 API，最为轻量，而且改造成本小，不会影响原来的组件层次结构和传说中的嵌套地狱；\n类定义更为复杂\n\n\n不同的生命周期会使逻辑变得分散且混乱，不易维护和管理；\n时刻需要关注this的指向问题；\n代码复用代价高，高阶组件的使用经常会使整个组件树变得臃肿；\n\n\n状态与 UI 隔离: 正是由于 Hooks 的特性，状态逻辑会变成更小的粒度，并且极容易被抽象成一个自定义 Hooks，组件中的状态和 UI 变得更为清晰和隔离。\n\n","categories":["React"],"tags":["React"]},{"title":"React 组件优化","url":"/2022/05/30/React%E7%BB%84%E4%BB%B6%E4%BC%98%E5%8C%96/","content":"\n\n正常情况下，父组件状态发生变化重新渲染，会导致子组件也重新渲染，即使子组件依赖的属性在父组件中没有发生改变。\n一、shouldComponentUpdate(nextProps, nextState)此方法基本不使用。\n可以通过子组件的props与nextProps进行对比，如果值相等，则不渲染\nclass Child extends Component &#123;  shouldComponentUpdate(nextProps) &#123;    if (this.props.name === nextProps.name) &#123;      return false;    &#125;    return true;  &#125;  render() &#123;    console.log(&#x27;child render&#x27;)    return (      &lt;h3&gt;        childComponent: &#123;this.props.name&#125;      &lt;/h3&gt;    )  &#125;&#125;export default class MemoComponent extends Component &#123;  state = &#123; count: 1 &#125;  handleAdd = () =&gt; &#123;    this.setState(&#123;      count: this.state.count + 1    &#125;)  &#125;  render() &#123;    console.log(&#x27;render&#x27;)    const &#123; count &#125; = this.state;    return (      &lt;div&gt;        Count: &#123;count&#125;       &lt;button onClick=&#123;this.handleAdd&#125;&gt;Add&lt;/button&gt;       &lt;div&gt;          &lt;Child name=&#123;&#x27;张三&#x27;&#125;/&gt;       &lt;/div&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n二、PureComponentclass组件中shouldComponentUpdate方法的替代品\nclass Child extends PureComponent &#123;  render() &#123;    console.log(&#x27;child render&#x27;)    return (      &lt;h3&gt;        childComponent: &#123;this.props.name&#125;      &lt;/h3&gt;    )  &#125;&#125;\n\n只要父组件的name属性没发生改变，就不会重新渲染Child组件。\n但是如果父组件传递的属性值是function或object，情况就有所不同\n情况一：子组件还是会重新渲染fnexport default class MemoComponent extends Component &#123;  render() &#123;    return (      &lt;Child name=&#123;&#x27;张三&#x27;&#125; fn=&#123;() =&gt; &#123;&#125;&#125;/&gt;    )  &#125;&#125;\n\n情况二：子组件不会重新渲染fnexport default class MemoComponent extends Component &#123;  callback = () =&gt; &#123; &#125;  render() &#123;    return (       &lt;Child name=&#123;&#x27;张三&#x27;&#125; fn=&#123;this.callback&#125;/&gt;    )  &#125;&#125;\n\n情况三：子组件不会重新渲染objectexport default class MemoComponent extends Component &#123;  state = &#123;     person: &#123;      name: &#x27;xiaoming&#x27;,      age: 18    &#125;  &#125;  changeAge = () =&gt; &#123;    this.setState(&#123;      person: &#123;        name: &#x27;xiaoming&#x27;,        age: this.state.person.age + 1      &#125;    &#125;)  &#125;  callback = () =&gt; &#123; &#125;  render() &#123;    console.log(&#x27;render&#x27;)    const &#123; person &#125; = this.state;    return (      &lt;div&gt;        &lt;Child name=&#123;person.name&#125;/&gt;        &lt;button onClick=&#123;this.changeAge&#125;&gt;Change&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;class Child extends PureComponent &#123;  render() &#123;    console.log(&#x27;child render&#x27;)    return (      &lt;h3&gt;        childComponent: &#123;this.props.name&#125;      &lt;/h3&gt;    )  &#125;&#125;\n\n三、memo用于函数组件。是class组件中PureComponent的替代品\nconst Child = memo((&#123; name &#125;) =&gt; &#123;  console.log(&#x27;child render&#x27;)  return (    &lt;h3&gt;      childComponent: &#123;name&#125;    &lt;/h3&gt;  )&#125;)\n\n四、useMemo 缓存一个值const CallBackAndMemo = () =&gt; &#123;  const [count, setCount] = useState(0);  const [flag, setFlag] = useState(false);  return (    &lt;&gt;      &lt;Child count=&#123;count&#125; flag=&#123;flag&#125; /&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Add&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; setFlag(!flag)&#125;&gt;Toggle&lt;/button&gt;    &lt;/&gt;  )&#125;const convert = (flag) =&gt; &#123;  console.log(&#x27;convert&#x27;)  return flag ? &#x27;AAA&#x27; : &#x27;BBB&#x27;;&#125;const Child = (&#123; count, flag &#125;) =&gt; &#123;  const name = convert(flag);  return (    &lt;&gt;      &lt;p&gt;count: &#123;count&#125;&lt;/p&gt;      &lt;p&gt;name: &#123;name&#125;&lt;/p&gt;    &lt;/&gt;  )&#125;\n\n每次更改父组件的count或者flag属性时，都会重新调用convert方法。(上)\nconst Child = (&#123; count, flag &#125;) =&gt; &#123;    const name = useMemo(() =&gt; &#123;        return convert(flag)    &#125;, [flag]);  return (    &lt;&gt;      &lt;p&gt;count: &#123;count&#125;&lt;/p&gt;      &lt;p&gt;name: &#123;name&#125;&lt;/p&gt;    &lt;/&gt;  )&#125;\n\n使用useMemo(() &#x3D;&gt;{}, [])可以将name值缓存起来，或者传入依赖项，只有在依赖项发生变化时，才会重新调用convert方法。（上）\n五、useCallback 缓存一个函数const Child = (&#123; count, flag &#125;) =&gt; &#123;  const convert = useCallback(() =&gt; &#123;    // 使用useCallback缓存一个函数，函数每次都会被调用，但是参数flag的值不会发生改变    // 只有当依赖项，传入flag时，才会变化    console.log(&#x27;convert&#x27;, flag)    return flag ? &#x27;AAA&#x27; : &#x27;BBB&#x27;;  &#125;, [flag])  const name = convert(flag);  return (    &lt;&gt;      &lt;p&gt;count: &#123;count&#125;&lt;/p&gt;      &lt;p&gt;name: &#123;name&#125;&lt;/p&gt;    &lt;/&gt;  )&#125;\n\n useCallback 的功能完全可以由 useMemo 所取代。唯一的区别是：**&#x3D;&#x3D;useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你&#x3D;&#x3D;**。\n\n","categories":["React"],"tags":["React"]},{"title":"Fiber入门","url":"/2022/07/07/Fiber%E5%85%A5%E9%97%A8/","content":"\n\n你是如何理解fiber的?React Fiber 是一种基于浏览器的单线程调度算法。\nReact 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使用了循环来代替之前的递归。\nFiber：一种将 recocilation （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。\n1）背景Fiber 产生的根本原因，是**&#x3D;&#x3D;大量的同步计算任务阻塞了浏览器的 UI 渲染&#x3D;&#x3D;**。\n默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。当我们调用setState更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。\n2）实现原理\nReact 内部运转分三层：\nVirtual DOM 层，描述页面长什么样。\nReconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。\nRenderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。\n\n\n\nFiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示：const fiber = &#123;    stateNode,    // 节点实例    child,        // 子节点    sibling,      // 兄弟节点    return,       // 父节点&#125;\n\n\n为了实现不卡顿，就需要有一个调度器 (Scheduler) 来进行任务分配。优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。任务的优先级有六种：\nsynchronous，与之前的Stack Reconciler操作一样，同步执行\ntask，在next tick之前执行\nanimation，下一帧之前执行\nhigh，在不久的将来立即执行\nlow，稍微延迟执行也没关系\noffscreen，下一次render时或scroll时才执行\n\n\nFiber Reconciler（react ）执行过程分为2个阶段：\n阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。\n阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。\n\n\nFiber树：React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。&#x3D;&#x3D;Fiber Tree 一个重要的特点是链表结构，将递归遍历 变成 循环遍历，然后配合 requestIdleCallback API，实现任务拆分、中断与恢复。&#x3D;&#x3D;\n\nFiber架构相对于以前的递归更新组件有什么优势？\n递归更新组件会让JS调用栈占用很长时间。\n\n因为浏览器是单线程的，它将GUI渲染，事件处理，JS执行等等放在了一起，只有将它做完才能做下一件事，如果有足够的时间，浏览器是会对我们的代码进行编译优化（JIT）及进行热代码优化。\n\nFiber架构正是利用这个原理将组件渲染分段执行，提高这样浏览器就有时间优化 JS 代码与修正 reflow！\n\n\n4.Fiber是将组件分段渲染，那第一段渲染之后，怎么知道下一段从哪个组件开始渲染呢？\nFiber节点拥有return，child，sibling 三个属性，分别对应父节点， 第一个孩子， 它右边的兄弟， 有了它们就足够将一棵树变成一个链表， 实现深度优化遍历。\n\n5.怎么决定每次更新的数量？\n将虚拟 DOM 转换为 Fiber 节点，首先它规定一个时间段内，然后在这个时间段能转换多少个FiberNode，就更新多少个。\n因此我们需要将我们的更新逻辑分成两个阶段，第一个阶段是将虚拟DOM转换成Fiber, Fiber转换成组件实例或真实DOM（不插入DOM树，插入DOM树会reflow）。Fiber转换成后两者明显会耗时，需要计算还剩下多少时间。\n比如，可以记录开始更新视图的时间var now &#x3D; new Date - 0，假如我们更新试图自定义需要100毫秒，那么定义结束时间是var deadline &#x3D; new Date + 100 ,所以每次更新一部分视图，就去拿当前时间new Date&lt;deadline做判断，如果没有超过deadline就更新视图，超过了，就进入下一个更新阶段。\n\n6.如何调度时间才能保证流畅？\n使用浏览器自带的api - requestIdleCallback。\n它的第一个参数是一个回调，回调有一个参数对象，对象有一个timeRemaining方法，就相当于new Date - deadline，并且它是一个高精度数据， 比毫秒更准确。\n这个因为浏览器兼容性问题，react团队自己实现了requestIdleCallback。\n\n7.fiber带来的新的生命周期是什么？创建时：\nconstructor -&gt;\ngetDerivedStateFromProps(参数nextProps, prevState,注意里面this不指向组件的实例)-&gt;\nrender -&gt;\ncomponentDidMount\n\n更新时：\ngetDerivedStateFromProps(这个是props更新才调用，setState时不调用这个生命周期， 参数nextProps, prevState) -&gt;\nshouldComponentUpdate(setState时调用参数nextProps, nextState)-&gt;\nrender-&gt;\ngetSnapsshotBeforeUpdate(替换 componentWillUpdate)\ncomponentDidUpdate(参数prevProps, prevState, snapshot)\n\n8.请简单谈一下react的事件机制\n当用户在为onClick添加函数时，React并没有将Click事件绑定在DOM上面。\n而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装交给中间层SyntheticEvent（负责所有事件合成）。\n所以当事件触发的时候，对使用统一的分发函数dispatchEvent将指定函数执行。\n\n9.为什么列表循环渲染的key最好不要用index变化前数组的值是[1,2,3,4]，key就是对应的下标：0，1，2，3变化后数组的值是[4,3,2,1]，key对应的下标也是：0，1，2，3\n\n\n那么diff算法在变化前的数组找到key &#x3D; 0的值是1，在变化后数组里找到的key &#x3D; 0的值是4;\n因为子元素不一样就重新删除并更新;\n但是如果加了唯一的key,如下\n\n变化前数组的值是[1,2,3,4]，key就是对应的下标：id0，id1，id2，id3变化后数组的值是[4,3,2,1]，key对应的下标也是：id3，id2，id1，id0\n\n\n那么diff算法在变化前的数组找到key &#x3D; id0的值是1，在变化后数组里找到的key&#x3D; id0的值也是1;\n因为子元素相同，就不删除并更新，只做移动操作，这就提升了性能;\n\nfiber架构Fiber的可中断、可恢复怎么实现的\nfiber是协程，是比线程更小的单元，可以被人为中断和恢复，当react更新时间超过1帧时，会产生视觉卡顿的效果，因此我们可以通过fiber把浏览器渲染过程分段执行，每执行一会就让出主线程控制权，执行优先级更高的任务\n&#x3D;&#x3D;fiber是一个链表结构，它有三个指针，分别记录了当前节点的下一个兄弟节点，子节点，父节点。当遍历中断时，它是可以恢复的，只需要保留当前节点的索引，就能根据索引找到对应的节点&#x3D;&#x3D;\nFiber更新机制\n初始化\n\n创建fiberRoot（React根元素）和rootFiber(通过ReactDOM.render或者ReactDOM.createRoot创建出来的)\n进入beginWork\n\nworkInProgress: 正在内存中构建的fiber树叫workInProgress fiber，在第一次更新时，所有的更新都发生在workInProgress树，在第一次更新后，workInProgress树上的状态是最新状态，它会替换current树\ncurrent: 正在视图层渲染的树叫current fiber树\ncurrentFiber.alternate = workInProgressFiberworkInProgressFiber.alternate = currentFiber\n\n\n深度调和子节点，渲染视图\n\n在新建的alternate树上，完成整个子节点的遍历，包括fiber的创建，最后会以workInProgress树最为最新的渲染树，fiberRoot的current指针指向workInProgress使其变成current fiber，完成初始化流程\n更新\n\n重新创建workInProgress树，复用当前current树上的alternate，作为新的workInProgress\n\n渲染完成后，workInProgress树又变成current树\n双缓冲模式\n话剧演出中，演员需要切换不同的场景，以一个一小时话剧来说，在舞台中切换场景，时间来不及。一般是准备两个舞台，切换场景从左边舞台到右边舞台演出\n在计算机图形领域，通过让图形硬件交替读取两套缓冲数据，可以实现画面的无缝切换，减少视觉的抖动甚至卡顿。\nreact的current树和workInProgress树使用双缓冲模式，可以减少fiber节点的开销，减少性能损耗\nReact渲染流程\n如图，React用JSX描述页面，JSX经过babel编译为render function，执行后产生VDOM，VDOM不是直接渲染的，会先转换为fiber，再进行渲染。vdom转换为fiber的过程叫reconcile，转换过程会创建DOM，全部转换完成后会一次性commit到DOM，这个过程不是一次性的，而是可打断的，这就是fiber架构的渲染流程\n![image-20230510160353449](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230510160353449.png)\nvdom（React Element对象）中只记录了子节点，没有记录兄弟节点，因此渲染不可打断\nfiber（fiberNode对象）是一个链表，它记录了父节点、兄弟节点、子节点，因此是可以打断的\n","categories":["React"],"tags":["React"]},{"title":"React Refs的使用","url":"/2022/06/09/React%20Refs/","content":"\n\nRef获取Dom元素的几种方式import React, &#123; Component, createRef &#125; from &#x27;react&#x27;export default class Refs extends Component &#123;  title3 = createRef();  componentDidMount() &#123;    console.log(this.refs.title1)    console.log(this.title2)    console.log(this.title3.current)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h2 ref=&quot;title1&quot;&gt;111&lt;/h2&gt;        &lt;h2 ref=&#123;x =&gt; this.title2 = x&#125;&gt;222&lt;/h2&gt;        &lt;h2 ref=&#123;this.title3&#125;&gt;333&lt;/h2&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n\n\nRef获取组件实例获取 class组件 实例：class ChildClass extends Component &#123;  classTest() &#123;    console.log(&#x27;ChildClass&#x27;)  &#125;  render() &#123;    return (      &lt;div&gt;ChildClass&lt;/div&gt;    )  &#125;&#125;export default class Refs extends Component &#123;  title1 = createRef();  componentDidMount() &#123;    this.title1.current.classTest(); // print &quot;ChildClass&quot;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;ChildClass ref=&#123;this.title1&#125;/&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n如果用上述方法获取函数组件实例，会报错：\nconst ChildFn = function () &#123;  const fnTest = () =&gt; console.log(&#x27;ChildClass&#x27;)  return &lt;div&gt;ChildFn&lt;/div&gt;&#125;export default class Refs extends Component &#123;  title1 = createRef();  componentDidMount() &#123;    this.title2.current.fnTest()  &#125;  render() &#123;    return (      &lt;div&gt;\t\t\t\t&lt;ChildFn ref=&#123;this.title2&#125;/&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n\n\n给 函数组件 设置 ref：无法获取函数组件实例，但是可以使用**forwardRef** 实现 ref 转发，用于&#x3D;&#x3D;获取组件内部的某个元素&#x3D;&#x3D;；\nconst ChildFn = forwardRef((props, ref) =&gt; &#123;  const fnTest = () =&gt; console.log(&#x27;ChildClass&#x27;)  return &lt;div ref=&#123;ref&#125;&gt;ChildFn&lt;/div&gt;&#125;)export default class Refs extends Component &#123;  title1 = createRef();  componentDidMount() &#123;    console.log(this.title2.current); // print &quot;&lt;div&gt;ChildFn&lt;/div&gt;&quot;  &#125;  render() &#123;    return (      &lt;div&gt;\t\t\t\t&lt;ChildFn ref=&#123;this.title2&#125;/&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n\n\n获取 函数组件 的属性和方法使用forwardRef 结合 useImperativeHandle 方法获取子组件的属性和方法：\nconst ChildFn = forwardRef((props, ref) =&gt; &#123;  const fnTest = () =&gt; console.log(&#x27;ChildClass&#x27;)  useImperativeHandle(ref, () =&gt; &#123;    return &#123;      fnTest // 对父组件暴露的属性和方法    &#125;  &#125;)  return &lt;div ref=&#123;ref&#125;&gt;ChildFn&lt;/div&gt;&#125;)export default class Refs extends Component &#123;  title1 = createRef();  componentDidMount() &#123;    this.title2.current.fnTest() // print &quot;ChildClass&quot;  &#125;  render() &#123;    return (      &lt;div&gt;\t\t\t\t&lt;ChildFn ref=&#123;this.title2&#125;/&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n\n\n合成事件![image-20230508141147710](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230508141147710.png)\n![image-20230508140851198](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230508140851198.png)\n","categories":["React"],"tags":["React"]},{"title":"React 生命周期函数","url":"/2022/05/02/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/","content":"\n\n\n// unsafe, 组件将要挂载时，render之前 componentWillMount() &#123;   console.log(&#x27;componentWillMount&#x27;) &#125; // unsafe, 父组件更改当前组件的属性时，会触发此方法 componentWillReceiveProps(nextProps) &#123;   console.log(&#x27;componentWillReceiveProps&#x27;, nextProps) &#125; // 组件被挂载后，render之后 componentDidMount() &#123;   console.log(&#x27;componentDidMount&#x27;) &#125; // unsafe 组价更新之前 componentWillUpdate(nextProps, nextState) &#123;   console.log(&#x27;componentWillUpdate&#x27;, nextProps, nextState); &#125; // 组件更新之后，render之后（初次加载不触发） componentDidUpdate(prevProps, prevState) &#123;   console.log(&#x27;componentDidUpdate&#x27;, prevProps, prevState) &#125; static getDerivedStateFromProps = (props, state) =&gt; &#123;   // 挂载必须经历的生命周期，代替componentWillUpdate, componentWillReceiveProps, componentWillMount   // 组件每次被rerender的时，包括在组件构建之后(虚拟dom之后，实际dom挂载之前)，每次获取新props或state之后；   // 每次接收新的props之后都会返回一个对象作为新的state，返回null则说明不需要更新state   // 此函数是一个静态函数，所以函数体内不能访问this，输出完全由输入决定   console.log(&#x27;static getDerivedStateFromProps(props, state)&#x27;, props, state)   return state &#125; // 组件卸载时触发，解绑事件、计时器、异步请求等 componentWillUnmount() &#123; &#125;\n\n\n\n挂在阶段：componentWillMount() &#123;&#125; // 没有挂载 Domrender() &#123;&#125;componentDidMount() &#123;&#125;\t// 已经挂载 Dom\n\n更新阶段：// props 发生改变后，相应改变组件的一些 state。// 在这个方法中改变 state 不会二次渲染，而是直接合并 statecomponentWillReceiveProps(nextProps) &#123;&#125;// 判断是否需要更新渲染组件，优化 react 应用的主要手段之一// 返回 false 就不会再向下执行生命周期了，在这个阶段不可以 setState()，会导致循环调用。shouldComponentUpdate(nextProps, nextState)&#123;  return false;&#125;// Dom 更新前。不可以 setState()，会导致循环调用。componentWillUpdate(nextProps, nextState)&#123;&#125;render()&#123;&#125;getSnapShotBeforeUpdate()&#123;&#125;// 组件更新之后，render之后（初次加载不触发）componentDidUpdate(prevProps, prevState) &#123;&#125;\n\n卸载阶段：componentWillUnmount() &#123;&#125;\n\n在 React 16 中官方已经建议删除以下三个方法，非要使用必须加前缀：UNSAVE_componentWillMount()&#123;&#125;componentWillReceivePorps() &#123;&#125;componentWillUpdate()&#123;&#125;\n\n取代这两三个生命周期的以下两个新的：static getDerivedStateFromProps(nextProps, nextState) &#123;  // 1.挂载必须经历的生命周期,  // 代替componentWillUpdate, componentWillReceiveProps, componentWillMount    // 2.组件每次被rerender的时，  // 包括在组件构建之后(虚拟dom之后，实际dom挂载之前)，每次获取新props或state之后；    // 3.每次接收新的props之后都会返回一个对象作为新的state，返回null则说明不需要更新state    // 4.此函数是一个静态函数，所以函数体内不能访问this，输出完全由输入决定    console.log(&#x27;static getDerivedStateFromProps(props, state)&#x27;, props, state)    return state&#125;getSnapshotBeforeUpdate(prevProps,prevState) &#123;  &#125;\n\n为什么要废弃三个生命周期\n被废弃的三个函数都是在render之前，因为fiber的出现，很可能因为高优先级任务的出现打断现有任务导致它们被执行多次。\ncomponentWillReceiveProps 和 componentWillUpdate 里滥用 setState 导致重复渲染死循环的。\n\n1.componentWillMount\n这个函数的功能完全可以使用componentDidMount和 constructor来代替。而如果抛去异步获取数据，其余的即是初始化而已，这些功能都可以在constructor中执行\n","categories":["React"],"tags":["React"]},{"title":"Webpack 总结","url":"/2022/10/29/webpack%E6%80%BB%E7%BB%93/","content":"\n\n\n1.常见的Loader\nraw-loader：加载文件原始内容（utf-8）\n\nfile-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)\n\nurl-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)\n\nimage-loader：加载并且压缩图片文件\n\ncss-loader：加载 CSS，支持模块化、压缩、文件导入等特性\n\nstyle-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS\n\nsass-loader：将SCSS&#x2F;SASS代码转换成CSS\n\nsvg-inline-loader：将压缩后的 SVG 内容注入代码中\n\nvue-loader：加载 Vue.js 单文件组件\n\neslint-loader：通过 ESLint 检查 JavaScript 代码\n\nbabel-loader：把 ES6 转换成 ES5\n\n\n2.常见的Plugin\nignore-plugin：忽略部分文件\nhtml-webpack-plugin：简化了 HTML 文件的创建，以便为你的 webpack 包提供服务。\nterser-webpack-plugin: 支持压缩 ES6 (Webpack4)\nwebpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度\nmini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)\nserviceworker-webpack-plugin：为网页应用增加离线缓存功能\nclean-webpack-plugin: 目录清理\nModuleConcatenationPlugin: 开启 Scope Hoisting\nspeed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)\nwebpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)\n\n3.Loader和Plugin的区别Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。\nPlugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。\nLoader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。\nPlugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。\n4.Webpack构建流程Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：\n\n初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数\n\n开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译\n\n确定入口：根据配置中的 entry 找出所有的入口文件\n\n编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理\n\n完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系\n\n输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会\n\n输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统\n\n\n在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。\n简单说\n\n初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler\n编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理\n输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中\n\n5.提高效率的插件\nwebpack-dashboard：可以更友好的展示相关打包信息。\n\nwebpack-merge：提取公共配置，减少重复配置代码\n\nspeed-measure-webpack-plugin：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。\n\nsize-plugin：监控资源体积变化，尽早发现问题\n\nHotModuleReplacementPlugin：模块热替换\n\n\n6.source map是什么，生产环境怎么用source map 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。\nmap文件只要不打开开发者工具，浏览器是不会加载的。\n线上环境一般有三种处理方案：\n\nhidden-source-map：借助第三方错误监控平台 Sentry 使用\nnosources-source-map：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高\nsourcemap：通过 nginx 设置将 .map 文件只对白名单开放(公司内网)\n\n注意：避免在生产中使用 inline- 和 eval-，因为它们会增加 bundle 体积大小，并降低整体性能。\n7.模块打包原理Webpack 实际上为每个模块创造了一个可以导出和导入的环境，本质上并没有修改 代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。\n8.文件监听原理在发现源码发生变化时，自动重新构建出新的输出文件。\nWebpack开启监听模式，有两种方式：\n\n启动 webpack 命令时，带上 –watch 参数\n在配置 webpack.config.js 中设置 watch:true\n\n缺点：每次需要手动刷新浏览器\n原理：轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 aggregateTimeout 后再执行。\nmodule.export = &#123;      watch: true,    \t\t\t\t\t\t// 默认false,也就是不开启        watchOptions: &#123;   \t\t\t\t\t// 只有开启监听模式时，watchOptions才有意义          ignored: /node_modules/,  // 默认为空，不监听的文件或者文件夹，支持正则匹配                     aggregateTimeout:300,     // 监听到变化发生后会等300ms再去执行，默认300ms        poll:1000    // 判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒问1000次         &#125;&#125;\n\n\n\n9.热更新原理(敲黑板，这道题必考)\nWebpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。\nHMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该chunk的增量更新。\n\n注：WDS即 webpack dev server\n\n后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。\n细节请参考Webpack HMR 原理解析\n10.对bundle体积进行监控和分析使用 webpack-bundle-analyzer 生成 bundle 的模块组成图，显示所占体积。\nbundlesize 工具包可以进行自动化资源体积监控。\n11.文件指纹文件指纹是打包后输出的文件名的后缀。\n\nHash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改\nChunkhash：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash\nContenthash：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变\n\nJS的文件指纹设置module.exports = &#123;  entry: &#123;      app: &quot;./scr/app.js&quot;,       search: &quot;./src/search.js&quot;  &#125;,   output: &#123;      filename: &quot;[name][chunkhash:8].js&quot;,       path: &quot;__dirname/dist&quot;  &#125;&#125;\n\nCSS的文件指纹设置设置 MiniCssExtractPlugin 的 filename，使用 contenthash。\nmodule.exports = &#123;     entry: &#123;            app: &#x27;./scr/app.js&#x27;,           search: &#x27;./src/search.js&#x27;    &#125;,     output: &#123;           filename: &#x27;[name][chunkhash:8].js&#x27;,         path:__dirname + &#x27;/dist&#x27;     &#125;,     plugins:[      new MiniCssExtractPlugin(&#123;           filename: `[name][contenthash:8].css`      &#125;)     ]&#125;\n\n图片的文件指纹设置设置file-loader的name，使用hash。\n占位符名称及含义\n\n\nconst path = require(&#x27;path&#x27;);module.exports = &#123;     entry: &#x27;./src/index.js&#x27;,     output: &#123;          filename:&#x27;bundle.js&#x27;,      path:path.resolve(__dirname, &#x27;dist&#x27;)    &#125;,     module:&#123;          rules:[&#123;               test:/\\.(png|svg|jpg|gif)$/,             use:[&#123;                      loader:&#x27;file-loader&#x27;,               options:&#123;                    name:&#x27;img/[name][hash:8].[ext]&#x27;                 &#125;              &#125;]        &#125;]     &#125;&#125;\n\n\n\n12.在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？可以使用 enforce 强制执行 loader 的作用顺序，pre 代表在所有正常 loader 之前执行，post 是所有 loader 之后执行。(inline 官方不推荐使用)\n13.优化 Webpack 的构建速度\n使用高版本的 Webpack 和 Node.js\n\n多进程/多实例构建：thread-loader\n\n压缩代码\n\n多进程并行压缩\n\nwebpack-paralle-uglify-plugin\nuglifyjs-webpack-plugin 开启 parallel 参数 (不支持ES6)\nterser-webpack-plugin 开启 parallel 参数\n\n通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，通过 css-loader 的 minimize 选项开启 cssnano 压缩 CSS。\n\n图片压缩\n\n使用基于 Node 库的 imagemin (很多定制选项、可以处理多种图片格式)\n配置 image-webpack-loader\n\n\n缩小打包作用域：\n\nexclude&#x2F;include (确定 loader 规则范围)\nresolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)\nresolve.mainFields 只采用 main 字段作为入口文件描述字段 (减少搜索步骤，需要考虑到所有运行时依赖的第三方模块的入口文件描述字段)\nresolve.extensions 尽可能减少后缀尝试的可能性\nnoParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)\nIgnorePlugin (完全排除模块)\n合理使用alias\n\n\n提取页面公共资源：\n\n基础包分离：\n使用 html-webpack-externals-plugin，将基础包通过 CDN 引入，不打入 bundle 中\n用 SplitChunksPlugin 进行(公共脚本、基础包、页面公共文件)分离(Webpack4内置) ，替代了 CommonsChunkPlugin 插件\n\n\n\n\nDLL：\n\n使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。\nHashedModuleIdsPlugin 可以解决模块数字id问题\n\n\n充分利用缓存提升二次构建速度：\n\nbabel-loader 开启缓存\nterser-webpack-plugin 开启缓存\n使用 cache-loader 或者 hard-source-webpack-plugin\n\n\nTree shaking\n\n打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉(只能对ES6 Modlue生效) 开发中尽可能使用ES6 Module的模块，提高tree shaking效率\n禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking\n使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码\npurgecss-webpack-plugin 和 mini-css-extract-plugin配合使用(建议)\n\n\n\n\nScope hoisting\n\n构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突\n必须是ES6的语法，因为有很多第三方库仍采用 CommonJS 语法，为了充分发挥 Scope hoisting 的作用，需要配置 mainFields 对第三方模块优先采用 jsnext:main 中指向的ES6模块化语法\n\n\n动态Polyfill\n\n建议采用 polyfill-service 只给用户返回需要的polyfill，社区维护。 (部分国内奇葩浏览器UA可能无法识别，但可以降级返回所需全部polyfill)\n\n\n\n14.代码分割的本质及意义代码分割的本质其实就是在源代码直接上线和打包成唯一脚本main.bundle.js这两种极端方案之间的一种更适合实际场景的中间状态。\n「用可接受的服务器性能压力增加来换取更好的用户体验。」\n源代码直接上线：虽然过程可控，但是http请求多，性能开销大。\n打包成唯一脚本：一把梭完自己爽，服务器压力小，但是页面空白期长，用户体验不好。\n15.编写loader的思路Loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 Loader 只负责自己需要负责的事情。\n\nLoader 运行在 Node.js 中，我们可以调用任意 Node.js 自带的 API 或者安装第三方模块进行调用\nWebpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串，当某些场景下 Loader 处理二进制文件时，需要通过 exports.raw &#x3D; true 告诉 Webpack 该 Loader 是否需要二进制数据\n尽可能的异步化 Loader，如果计算量很小，同步也可以\n使用 loader-utils 和 schema-utils 为我们提供的实用工具\n加载本地 Loader 方法\nNpm link\nResolveLoader\n\n\n\nhttps://juejin.cn/post/7100534685134454815\n16.编写Plugin的思路webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在特定的阶段钩入想要添加的自定义功能。\nWebpack 的 Tapable 事件流机制保证了插件的有序性，使得整个系统扩展性良好。\n\ncompiler 暴露了和 Webpack 整个生命周期相关的钩子\ncompilation 暴露了与模块和依赖有关的粒度更小的事件钩子\n插件需要在其原型上绑定apply方法，才能访问 compiler 实例\n传给每个插件的 compiler 和 compilation对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件\n找出合适的事件点去完成想要的功能\nemit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改(emit 事件是修改 Webpack 输出资源的最后时机)\nwatch-run 当依赖的文件发生变化时会触发\n\n\n异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住\n\n17.Babel原理Babel 是一个 &#x3D;&#x3D;JavaScript 编译器&#x3D;&#x3D;，是一个工具链，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。\nBabel 本质上就是在操作 AST 来完成代码的转译。&#x3D;&#x3D;AST是抽象语法树&#x3D;&#x3D;（Abstract Syntax Tree, AST）\nBabel 的功能很纯粹，它只是一个编译器。大多数编译器的工作过程可以分为三部分：\n\n解析：将代码转换成 AST\n词法分析：将代码(字符串)分割为token流，即语法单元成的数组\n语法分析：分析token流(上面生成的数组)并生成 AST\n\n\n转换：访问 AST 的节点进行变换操作生产新的 AST（将高版本语法的 AST 转换成支持低版本语法的 AST）\nTaro就是利用 babel 完成的小程序语法转换\n\n\n生成：以新的 AST 为基础生成代码（将 AST 转换成字符串形式的低版本代码）\n\n阅读原文\n结合着看\n","categories":["构建工具"],"tags":["Webpack"]},{"title":"Webpack 知识体系","url":"/2022/10/11/webpack%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/","content":"\n\n\nwebpack 中 loader 和 plugin 的区别是什么?![image-20230313215918145](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230313215918145.png)\n![image-20230314100016140](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314100016140.png)\n一、Webpack 基础1. 简单配置\n该部分需要掌握：\n\nWebpack 常规配置项有哪些？\n常用 Loader 有哪些？如何配置？\n常用插件（Plugin）有哪些？如何的配置？\nBabel 的如何配置？Babel 插件如何使用？\n\n\n1.1 安装依赖毫无疑问，先本地安装一下 webpack 以及 webpack-cli\n$ npm install webpack webpack-cli -D # 安装到本地依赖\n\n安装完成 ✅\n+ webpack-cli@4.7.2+ webpack@5.44.0\n\n\n\n1.2 工作模式webpack 在 4 以后就支持 0 配置打包，我们可以测试一下\n\n新建 ./src/index.js 文件，写一段简单的代码\n\nconst a = &#x27;Hello ITEM&#x27;console.log(a)module.exports = a;\n\n此时目录结构\nwebpack_work                  ├─ src                │  └─ index.js         └─ package.json       \n\n\n直接运行 npx webpack，启动打包\n\n![image-20230314100037131](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314100037131.png)\n打包完成，我们看到日志上面有一段提示：The &#39;mode&#39; option has not been set,...\n意思就是，我们没有配置 mode（模式），这里提醒我们配置一下\n\n模式： 供 mode 配置选项，告知 webpack 使用相应模式的内置优化，默认值为 production，另外还有 development、none，他们的区别如下\n\n![image-20230314100147865](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314100147865.png)\n怎么配置呢？很简单\n\n只需在配置对象中提供 mode 选项：\n\nmodule.exports = &#123;  mode: &#x27;development&#x27;,&#125;;\n\n\n从 CLI 参数中传递：\n\n$ webpack --mode=development\n\n\n\n1.3 配置文件虽然有 0 配置打包，但是实际工作中，我们还是需要使用配置文件的方式，来满足不同项目的需求\n\n根路径下新建一个配置文件 webpack.config.js\n新增基本配置信息\n\nconst path = require(&#x27;path&#x27;)module.exports = &#123;  mode: &#x27;development&#x27;, // 模式  entry: &#x27;./src/index.js&#x27;, // 打包入口地址  output: &#123;    filename: &#x27;bundle.js&#x27;, // 输出文件名    path: path.join(__dirname, &#x27;dist&#x27;) // 输出文件目录  &#125;&#125;\n\n\n\n\n1.4 Loader这里我们把入口改成 CSS 文件，可能打包结果会如何\n\n新增 ./src/main.css\n\n修改 entry 配置\n\n\nconst path = require(&#x27;path&#x27;)module.exports = &#123;  mode: &#x27;development&#x27;, // 模式  entry: &#x27;./src/main.css&#x27;, // 打包入口地址  output: &#123;    filename: &#x27;bundle.css&#x27;, // 输出文件名    path: path.join(__dirname, &#x27;dist&#x27;) // 输出文件目录  &#125;&#125;\n\n\n运行打包命令：npx webpack\n\n![image-20230314100827307](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314100827307.png)\n这里就报错了！\n这是因为：webpack 默认支持处理 JS 与 JSON 文件，其他类型都处理不了，这里必须借助 Loader 来对不同类型的文件的进行处理。\n\n安装 css-loader 来处理 CSS\n\nnpm install css-loader -D\n\n\n配置资源加载模块\n\nconst path = require(&#x27;path&#x27;)module.exports = &#123;  mode: &#x27;development&#x27;, // 模式  entry: &#x27;./src/main.css&#x27;, // 打包入口地址  output: &#123;    filename: &#x27;bundle.css&#x27;, // 输出文件名    path: path.join(__dirname, &#x27;dist&#x27;) // 输出文件目录  &#125;,  module: &#123;     rules: [ // 转换规则      &#123;        test: /\\.css$/, //匹配所有的 css 文件        use: &#x27;css-loader&#x27; // use: 对应的 Loader 名称      &#125;    ]  &#125;&#125;\n\n\n重新运行打包命令 npx webpack\n\n\n\n哎嘿，可以打包了 😁\ndist           └─ bundle.css  # 打包得到的结果\n\n![image-20230314101635017](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314101635017.png)\n这里这是尝试，入口文件还是需要改回 ./src/index.js\n这里我们可以得到一个结论：Loader 就是将 Webpack 不认识的内容转化为认识的内容\n1.5 插件（plugin）与 Loader 用于转换特定类型的文件不同，插件（Plugin）可以贯穿 Webpack 打包的生命周期，执行不同的任务\n下面来看一个使用的列子：\n1.新建 ./src/index.html 文件\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;ITEM&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n如果我想打包后的资源文件，例如：js 或者 css 文件可以自动引入到 Html 中，就需要使用插件 html-webpack-plugin来帮助你完成这个操作\n2.本地安装 html-webpack-plugin\nnpm install html-webpack-plugin -D\n\n3.配置插件\nconst path = require(&#x27;path&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123;  mode: &#x27;development&#x27;, // 模式  entry: &#x27;./src/index.js&#x27;, // 打包入口地址  output: &#123;    filename: &#x27;bundle.js&#x27;, // 输出文件名    path: path.join(__dirname, &#x27;dist&#x27;) // 输出文件目录  &#125;,  module: &#123;     rules: [      &#123;        test: /\\.css$/, //匹配所有的 css 文件        use: &#x27;css-loader&#x27; // use: 对应的 Loader 名称      &#125;    ]  &#125;,  plugins:[ // 配置插件    new HtmlWebpackPlugin(&#123;      template: &#x27;./src/index.html&#x27;    &#125;)  ]&#125;\n\n运行一下打包，打开 dist 目录下生成的 index.html 文件\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;ITEM&lt;/title&gt;&lt;script defer src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n可以看到它自动的引入了打包好的 bundle.js ，非常方便实用\n1.6 自动清空打包目录每次打包的时候，打包目录都会遗留上次打包的文件，为了保持打包目录的纯净，我们需要在打包前将打包目录清空\n这里我们可以使用插件 clean-webpack-plugin 来实现\n\n安装\n\n$ npm install clean-webpack-plugin -D\n\n\n配置\n\nconst path = require(&#x27;path&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)// 引入插件const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)module.exports = &#123;  // ...  plugins:[ // 配置插件    new HtmlWebpackPlugin(&#123;      template: &#x27;./src/index.html&#x27;    &#125;),    new CleanWebpackPlugin() // 引入插件  ]&#125;\n\n\n\n1.7 区分环境本地开发和部署线上，肯定是有不同的需求\n本地环境：\n\n需要更快的构建速度\n需要打印 debug 信息\n需要 live reload 或 hot reload 功能\n需要 sourcemap 方便定位问题\n\n生产环境：\n\n需要更小的包体积，代码压缩+tree-shaking\n需要进行代码分割\n需要压缩图片体积\n\n针对不同的需求，首先要做的就是做好环境的区分\n\n本地安装 cross-env [文档地址]\n\nnpm install cross-env -D\n\n\n配置启动命令\n\n打开 ./package.json\n&quot;scripts&quot;: &#123;  &quot;dev&quot;: &quot;cross-env NODE_ENV=dev webpack serve --mode development&quot;,   &quot;test&quot;: &quot;cross-env NODE_ENV=test webpack --mode production&quot;,  &quot;build&quot;: &quot;cross-env NODE_ENV=prod webpack --mode production&quot;&#125;,\n\n\n在 Webpack 配置文件中获取环境变量\n\nconst path = require(&#x27;path&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)console.log(&#x27;process.env.NODE_ENV=&#x27;, process.env.NODE_ENV) // 打印环境变量const config = &#123;  entry: &#x27;./src/index.js&#x27;, // 打包入口地址  output: &#123;    filename: &#x27;bundle.js&#x27;, // 输出文件名    path: path.join(__dirname, &#x27;dist&#x27;) // 输出文件目录  &#125;,  module: &#123;     rules: [      &#123;        test: /\\.css$/, //匹配所有的 css 文件        use: &#x27;css-loader&#x27; // use: 对应的 Loader 名称      &#125;    ]  &#125;,  plugins:[ // 配置插件    new HtmlWebpackPlugin(&#123;      template: &#x27;./src/index.html&#x27;    &#125;)  ]&#125;module.exports = (env, argv) =&gt; &#123;  console.log(&#x27;argv.mode=&#x27;,argv.mode) // 打印 mode(模式) 值  // 这里可以通过不同的模式修改 config 配置  return config;&#125;\n\n\n测试一下看看\n\n\n执行 npm run build\n\nprocess.env.NODE_ENV= prodargv.mode= production\n\n\n\n1.8 启动 devServer\n安装 webpack-dev-server\n\nnpm intall webpack-dev-server@3.11.2 -D\n\n\n⚠️注意：本文使用的 webpack-dev-server 版本是 3.11.2，当版本 version &gt;= 4.0.0 时，需要使用 devServer.static 进行配置，不再有 devServer.contentBase 配置项。\n\n\n配置本地服务\n\n// webpack.config.jsconst config = &#123;  // ...  devServer: &#123;    contentBase: path.resolve(__dirname, &#x27;public&#x27;), // 静态文件目录    compress: true, //是否启动压缩 gzip    port: 8080, // 端口号    // open:true  // 是否自动打开浏览器  &#125;, // ...&#125;module.exports = (env, argv) =&gt; &#123;  console.log(&#x27;argv.mode=&#x27;,argv.mode) // 打印 mode(模式) 值  // 这里可以通过不同的模式修改 config 配置  return config;&#125;\n\n为什么要配置 contentBase ？\n因为 webpack 在进行打包的时候，对静态文件的处理，例如图片，都是直接 copy 到 dist 目录下面。但是对于本地开发来说，这个过程太费时，也没有必要，所以在设置 contentBase 之后，就直接到对应的静态目录下面去读取文件，而不需对文件做任何移动，节省了时间和性能开销。\n\n启动本地服务\n\n$ npm run dev\n\n为了看到效果，我在 html 中添加了一段文字，并在 public 下面放入了一张图片 logo.png\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;ITEM&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;p&gt;ITEM&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\npublic       └─ logo.png  \n\n打开地址 http://localhost:8080/\n![image-20230314105304952](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314105304952.png)接着访问 http://localhost:8080/logo.png\n![image-20230314105340796](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314105340796.png)\nOK，没问题 👌\n1.9 引入 CSS上面，我们在 Loader 里面讲到了使用 css-loader 来处理 css，但是单靠 css-loader 是没有办法将样式加载到页面上。这个时候，我们需要再安装一个 style-loader 来完成这个功能\nstyle-loader 就是将处理好的 css 通过 style 标签的形式添加到页面上\n\n安装 style-loader\n\nnpm install style-loader -D\n\n\n配置 Loader\n\nconst config = &#123;  // ...  module: &#123;     rules: [      &#123;        test: /\\.css$/, //匹配所有的 css 文件        use: [&#x27;style-loader&#x27;,&#x27;css-loader&#x27;]      &#125;    ]  &#125;,  // ...&#125;\n\n\n⚠️注意： Loader 的执行顺序是固定从后往前，即按 css-loader --&gt; style-loader 的顺序执行\n\n\n引用样式文件\n\n在入口文件 ./src/index.js 引入样式文件 ./src/main.css\n// ./src/index.jsimport &#x27;./main.css&#x27;;const a = &#x27;Hello ITEM&#x27;console.log(a)module.exports = a;\n\n/* ./src/main.css */ body &#123;  margin: 10px auto;  background: cyan;  max-width: 800px;&#125;\n\n\n重启一下本地服务，访问 http://localhost:8080/\n![image-20230314110210083](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314110210083.png)\n\n\n这样样式就起作用了。\nstyle-loader 核心逻辑相当于：\nconst content = `$&#123;样式内容&#125;`const style = document.createElement(&#x27;style&#x27;);style.innerHTML = content;document.head.appendChild(style);\n\n通过动态添加 style 标签的方式，将样式引入页面\n1.10 CSS 兼容性使用 postcss-loader，自动添加 CSS3 部分属性的浏览器前缀\n上面我们用到的 transform: translateX(-50%);，需要加上不同的浏览器前缀，这个我们可以使用 postcss-loader 来帮助我们完成\nnpm install postcss postcss-loader postcss-preset-env -D\n\nconst config = &#123;  // ...  module: &#123;     rules: [      &#123;        test: /\\.css$/, //匹配所有的 css 文件        use: [&#x27;style-loader&#x27;,&#x27;css-loader&#x27;, &#x27;postcss-loader&#x27;]      &#125;    ]  &#125;,  // ...&#125;\n\n创建 postcss 配置文件 postcss.config.js\n// postcss.config.jsmodule.exports = &#123;  plugins: [require(&#x27;postcss-preset-env&#x27;)]&#125;\n\n创建 postcss-preset-env 配置文件 .browserslistrc\n# 换行相当于 andlast 2 versions # 回退两个浏览器版本&gt; 0.5% # 全球超过0.5%人使用的浏览器，可以通过 caniuse.com 查看不同浏览器不同版本占有率IE 10 # 兼容IE 10\n\n\n\n1.11 引入 Less 或者 Sass\n\n\n\n1.12 分离样式文件前面，我们都是依赖 style-loader 将样式通过 style 标签的形式添加到页面上\n但是，更多时候，我们都希望可以通过 CSS 文件的形式引入到页面上\n\n安装 mini-css-extract-plugin\n\n$ npm install mini-css-extract-plugin -D\n\n\n修改 webpack.config.js 配置\n// ...// 引入插件const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)const config = &#123;  // ...  module: &#123;     rules: [      // ...      &#123;        test: /\\.(s[ac]|c)ss$/i, //匹配所有的 sass/scss/css 文件        use: [          // &#x27;style-loader&#x27;,          MiniCssExtractPlugin.loader, // 添加 loader          &#x27;css-loader&#x27;,          &#x27;postcss-loader&#x27;,          &#x27;sass-loader&#x27;,         ]       &#125;,    ]  &#125;,  // ...  plugins:[ // 配置插件    // ...    new MiniCssExtractPlugin(&#123; // 添加插件      filename: &#x27;[name].[hash:8].css&#x27;    &#125;),    // ...  ]&#125;// ...\n\n查看打包结果\n\n\ndist                    ├─ avatar.d4d42d52.png  ├─ bundle.js            ├─ index.html           ├─ logo.56482c77.png    └─ main.3bcbae64.css # 生成的样式文件  \n\n![image-20230314140445250](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314140445250.png)\n1.13 图片和字体文件虽然上面在配置开发环境的时候，我们可以通过设置 contentBase 去直接读取图片类的静态文件，看一下下面这两种图片使用情况\n\n页面直接引入\n&lt;!-- 本地可以访问，生产环境会找不到图片 --&gt;&lt;img src=&quot;/logo.png&quot; alt=&quot;&quot;&gt;\n\n背景图引入\n&lt;div id=&quot;imgBox&quot;&gt;&lt;/div&gt;\n\n/* ./src/main.css */...#imgBox &#123;  height: 400px;  width: 400px;  background: url(&#x27;../public/logo.png&#x27;);  background-size: contain;&#125;\n\n直接会报错\n![image-20230314140633926](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314140633926.png)\n所以实际上，Webpack 无法识别图片文件，需要在打包的时候处理一下\n常用的处理图片文件的 Loader 包含：\n![image-20230314140703022](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314140703022.png)\nconst config = &#123;  //...  module: &#123;     rules: [      &#123;        test: /\\.(jpe?g|png|gif)$/i,        use:[          &#123;            loader: &#x27;file-loader&#x27;,            options: &#123;              name: &#x27;[name][hash:8].[ext]&#x27;            &#125;          &#125;,          &#123;            loader: &#x27;url-loader&#x27;,            options: &#123;              name: &#x27;[name][hash:8].[ext]&#x27;,              // 文件小于 50k 会转换为 base64，大于则拷贝文件              limit: 50 * 1024            &#125;          &#125;        ]      &#125;,      &#123;        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/i,  // 匹配字体文件        use: [          &#123;            loader: &#x27;url-loader&#x27;,            options: &#123;              name: &#x27;fonts/[name][hash:8].[ext]&#x27;, // 体积大于 10KB 打包到 fonts 目录下               limit: 10 * 1024,            &#125;           &#125;        ]      &#125;,    ]  &#125;,  // ...&#125;\n\n\n\n1.14 资源模块的使用\nwebpack5 新增资源模块(asset module)，允许使用资源文件（字体，图标等）而无需配置额外的 loader。\n\n资源模块支持以下四个配置：\n\n\nasset/resource 将资源分割为单独的文件，并导出 url，类似之前的 file-loader 的功能.\nasset/inline 将资源导出为 dataUrl 的形式，类似之前的 url-loader 的小于 limit 参数时功能.\nasset/source 将资源导出为源码（source code）. 类似的 raw-loader 功能.\nasset 会根据文件大小来选择使用哪种类型，当文件小于 8 KB（默认） 的时候会使用 asset&#x2F;inline，否则会使用 asset&#x2F;resource。\n\n\n贴一下修改后的完整代码\n// ./src/index.jsconst config = &#123;  // ...  module: &#123;     rules: [      // ...       &#123;        test: /\\.(jpe?g|png|gif)$/i,        type: &#x27;asset&#x27;,        generator: &#123;          // 输出文件位置以及文件名          // [ext] 自带 &quot;.&quot; 这个与 url-loader 配置不同          filename: &quot;[name][hash:8][ext]&quot;        &#125;,        parser: &#123;          dataUrlCondition: &#123;            maxSize: 50 * 1024 //超过50kb不转 base64          &#125;        &#125;      &#125;,      &#123;        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/i,        type: &#x27;asset&#x27;,        generator: &#123;          // 输出文件位置以及文件名          filename: &quot;[name][hash:8][ext]&quot;        &#125;,        parser: &#123;          dataUrlCondition: &#123;            maxSize: 10 * 1024 // 超过100kb不转 base64          &#125;        &#125;      &#125;,    ]  &#125;,  // ...&#125;module.exports = (env, argv) =&gt; &#123;  console.log(&#x27;argv.mode=&#x27;,argv.mode) // 打印 mode(模式) 值  // 这里可以通过不同的模式修改 config 配置  return config;&#125;\n\n\n\n1.15 JS 兼容性（Babel）在开发中我们想使用最新的 Js 特性，但是有些新特性的浏览器支持并不是很好，所以 Js 也需要做兼容处理，常见的就是将 ES6 语法转化为 ES5。\n这里将登场的“全场最靓的仔” – Babel\n\n安装依赖\n$ npm install babel-loader @babel/core @babel/preset-env -D\n\n\nbabel-loader 使用 Babel 加载 ES2015+ 代码并将其转换为 ES5\n@babel/core Babel 编译的核心包\n@babel/preset-env Babel 编译的预设，可以理解为 Babel 插件的超集\n\n\n配置 Babel 预设\n// webpack.config.jsconst config = &#123;  entry: &#x27;./src/index.js&#x27;, // 打包入口地址  output: &#123;    filename: &#x27;bundle.js&#x27;, // 输出文件名    path: path.join(__dirname, &#x27;dist&#x27;), // 输出文件目录  &#125;,  module: &#123;     rules: [      &#123;        test: /\\.js$/i,        use: [          &#123;            loader: &#x27;babel-loader&#x27;,            options: &#123;              presets: [                &#x27;@babel/preset-env&#x27;              ],            &#125;          &#125;        ]      &#125;,    ]  &#125;,&#125;\n\n尽然是做兼容处理，我们自然也可以指定到底要兼容哪些浏览器\n为了避免 webpack.config.js 太臃肿，建议将 Babel 配置文件提取出来\n根目录下新增 .babelrc.js\n// ./babelrc.jsmodule.exports = &#123;  presets: [    [      &quot;@babel/preset-env&quot;,      &#123;        // useBuiltIns: false 默认值，无视浏览器兼容配置，引入所有 polyfill        // useBuiltIns: entry 根据配置的浏览器兼容，引入浏览器不兼容的 polyfill        // useBuiltIns: usage 会根据配置的浏览器兼容，以及你代码中用到的 API 来进行 polyfill，实现了按需添加        useBuiltIns: &quot;entry&quot;,        corejs: &quot;3.9.1&quot;, // 是 core-js 版本号        targets: &#123;          chrome: &quot;58&quot;,          ie: &quot;11&quot;,        &#125;,      &#125;,    ],  ],&#125;;\n\n好了，这里一个简单的 Babel 预设就配置完了\n常见 Babel 预设还有：\n\n@babel/preset-flow\n@babel/preset-react\n@babel/preset-typescript\n\n\n配置 Babel 插件\n\n对于正在提案中，还未进入 ECMA 规范中的新特性，Babel 是无法进行处理的，必须要安装对应的插件，例如：\n// ./ index.jsimport &#x27;./main.css&#x27;;import &#x27;./sass.scss&#x27;import logo from &#x27;../public/avatar.png&#x27;import &#x27;./fonts/iconfont.css&#x27;const a = &#x27;Hello ITEM&#x27;console.log(a)const img = new Image()img.src = logodocument.getElementById(&#x27;imgBox&#x27;).appendChild(img)// 新增装饰器的使用@log(&#x27;hi&#x27;)class MyClass &#123; &#125;function log(text) &#123;  return function(target) &#123;    target.prototype.logger = () =&gt; `$&#123;text&#125;，$&#123;target.name&#125;`  &#125;&#125;const test = new MyClass()test.logger()\n\n执行一下打包\n![image-20230314142322496](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314142322496.png)\n不出所料，识别不了 🙅🏻‍♀️\n怎么才能使用呢？Babel 其实提供了对应的插件：\n\n@babel/plugin-proposal-decorators\n@babel/plugin-proposal-class-properties\n\n安装一下:\n$ npm install babel/plugin-proposal-decorators @babel/plugin-proposal-class-properties -D\n\n打开 .babelrc.js 加上插件的配置\nmodule.exports = &#123;  presets: [    [      &quot;@babel/preset-env&quot;,      &#123;        useBuiltIns: &quot;entry&quot;,        corejs: &quot;3.9.1&quot;,        targets: &#123;          chrome: &quot;58&quot;,          ie: &quot;11&quot;,        &#125;,      &#125;,    ],  ],  plugins: [        [&quot;@babel/plugin-proposal-decorators&quot;, &#123; legacy: true &#125;],    [&quot;@babel/plugin-proposal-class-properties&quot;, &#123; loose: true &#125;],  ]&#125;;\n\n这样就可以打包了，在 bundle.js 中已经转化为浏览器支持的 Js 代码\n2. SourceMap 配置选择SourceMap 是一种映射关系，当项目运行后，如果出现错误，我们可以利用 SourceMap 反向定位到源码位置\n2.1 devtool 配置const config = &#123;  entry: &#x27;./src/index.js&#x27;, // 打包入口地址  output: &#123;    filename: &#x27;bundle.js&#x27;, // 输出文件名    path: path.join(__dirname, &#x27;dist&#x27;), // 输出文件目录  &#125;,  devtool: &#x27;source-map&#x27;,  module: &#123;      // ...  &#125;  // ...\n\n执行打包后，dist 目录下会生成以 .map 结尾的 SourceMap 文件\ndist                   ├─ avatard4d42d52.png  ├─ bundle.js           ├─ bundle.js.map     └─ index.html          \n\n除了 source-map 这种类型之外，还有很多种类型可以用，例如：\n\n\n对照一下校验规则 ^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$ 分析一下关键字\n![image-20230314150330776](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314150330776.png)\n2.2 推荐配置\n本地开发：\n推荐：eval-cheap-module-source-map\n理由：\n\n本地开发首次打包慢点没关系，因为 eval 缓存的原因，rebuild 会很快\n开发中，我们每行代码不会写的太长，只需要定位到行就行，所以加上 cheap\n我们希望能够找到源代码的错误，而不是打包后的，所以需要加上 module\n\n\n生产环境：\n推荐：(none)\n理由：\n\n就是不想别人看到我的源代码\n\n\n三种 hash 值\nWebpack 文件指纹策略是将文件名后面加上 hash 值。特别在使用 CDN 的时候，缓存是它的特点与优势，但如果打包的文件名，没有 hash 后缀的话，你肯定会被缓存折磨的够呛 😂\n例如我们在基础配置中用到的：filename: &quot;[name][hash:8][ext]&quot;\n这里里面 [] 包起来的，就叫占位符，它们都是什么意思呢？请看下面这个表 👇🏻\n\n\n表格里面的 hash、chunkhash、contenthash 你可能还是不清楚差别在哪\n\nhash ：任何一个文件改动，整个项目的构建 hash 值都会改变；\nchunkhash：文件的改动只会影响其所在 chunk 的 hash 值；\ncontenthash：每个文件都有单独的 hash 值，文件的改动只会影响自身的 hash 值；\n\n二、Webpack 进阶第二部分，我们将向“能优化”的方向前进 🏃\n除了配置上的优化外，我们也要学习如何自己开发 Loader 和 Plugin\n1. 优化构建速度1.1 构建费时分析这里我们需要使用插件 speed-measure-webpack-plugin，我们参考文档配置一下\n\n首先安装一下\n\n$ npm i -D speed-measure-webpack-plugin\n\n\n修改我们的配置文件 webpack.config.js\n\n...// 费时分析const SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;);const smp = new SpeedMeasurePlugin();...const config = &#123;...&#125;module.exports = (env, argv) =&gt; &#123;  // 这里可以通过不同的模式修改 config 配置  return smp.wrap(config);&#125;\n\n\n\n\n注意：在 webpack5.x 中为了使用费时分析去对插件进行降级或者修改配置写法是非常不划算的，这里因为演示需要，我后面会继续使用，但是在平时开发中，建议还是不要使用。\n\n1.2 优化 resolve 配置1.2.1 aliasalias 用的创建 import 或 require 的别名，用来简化模块引用，项目中基本都需要进行配置。\nconst path = require(&#x27;path&#x27;)...// 路径处理方法function resolve(dir)&#123;  return path.join(__dirname, dir);&#125; const config  = &#123;  ...  resolve:&#123;    // 配置别名    alias: &#123;      &#x27;~&#x27;: resolve(&#x27;src&#x27;),      &#x27;@&#x27;: resolve(&#x27;src&#x27;),      &#x27;components&#x27;: resolve(&#x27;src/components&#x27;),    &#125;  &#125;&#125;;\n\n配置完成之后，我们在项目中就可以\n// 使用 src 别名 ~ import &#x27;~/fonts/iconfont.css&#x27;// 使用 src 别名 @ import &#x27;@/fonts/iconfont.css&#x27;// 使用 components 别名import footer from &quot;components/footer&quot;;\n\n\n\n1.2.2 extensionswebpack 默认配置\nconst config = &#123;  //...  resolve: &#123;    extensions: [&#x27;.js&#x27;, &#x27;.json&#x27;, &#x27;.wasm&#x27;],  &#125;,&#125;;\n\n如果用户引入模块时不带扩展名，例如\nimport file from &#x27;../path/to/file&#x27;;\n\n那么 webpack 就会按照 extensions 配置的数组从左到右的顺序去尝试解析模块\n需要注意的是：\n\n高频文件后缀名放前面；\n手动配置后，默认配置会被覆盖\n\n如果想保留默认配置，可以用 ... 扩展运算符代表默认配置，例如\nconst config = &#123;  //...  resolve: &#123;    extensions: [&#x27;.ts&#x27;, &#x27;...&#x27;],   &#125;,&#125;;\n\n\n\n1.2.3 modules告诉 webpack 解析模块时应该搜索的目录，常见配置如下\nconst path = require(&#x27;path&#x27;);// 路径处理方法function resolve(dir)&#123;  return path.join(__dirname, dir);&#125;const config = &#123;  //...  resolve: &#123;     modules: [resolve(&#x27;src&#x27;), &#x27;node_modules&#x27;],  &#125;,&#125;;\n\n告诉 webpack 优先 src 目录下查找需要解析的文件，会大大节省查找时间\n1.2.4 resolveLoaderresolveLoader 与上面的 resolve 对象的属性集合相同， 但仅用于解析 webpack 的 loader 包。\n一般情况下保持默认配置就可以了，但如果你有自定义的 Loader 就需要配置一下，不配可能会因为找不到 loader 报错\n\n例如：我们在 loader 文件夹下面，放着我们自己写的 loader\n\n我们就可以怎么配置\nconst path = require(&#x27;path&#x27;);// 路径处理方法function resolve(dir)&#123;  return path.join(__dirname, dir);&#125;const config = &#123;  //...  resolveLoader: &#123;    modules: [&#x27;node_modules&#x27;,resolve(&#x27;loader&#x27;)]  &#125;,&#125;;\n\n\n\n1.3 externalsexternals 配置选项提供了「从输出的 bundle 中排除依赖」的方法。此功能通常对 library 开发人员来说是最有用的，然而也会有各种各样的应用程序用到它。\n例如，从 CDN 引入 jQuery，而不是把它打包：\n\n引入链接\n\n&lt;script  src=&quot;https://code.jquery.com/jquery-3.1.0.js&quot;  integrity=&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;  crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;\n\n\n配置 externals\n\nconst config = &#123;  //...  externals: &#123;    jquery: &#x27;jQuery&#x27;,  &#125;,&#125;;\n\n\n使用 jQuery\n\nimport $ from &#x27;jquery&#x27;;$(&#x27;.my-element&#x27;).animate(/* ... */);\n\n我们可以用这样的方法来剥离不需要改动的一些依赖，大大节省打包构建的时间。\n1.4 缩小范围在配置 loader 的时候，我们需要更精确的去指定 loader 的作用目录或者需要排除的目录，通过使用 include 和 exclude 两个配置项，可以实现这个功能，常见的例如：\n\n**include**：符合条件的模块进行解析\n**exclude**：排除符合条件的模块，不解析\nexclude 优先级更高\n\n例如在配置 babel 的时候\nconst path = require(&#x27;path&#x27;);// 路径处理方法function resolve(dir)&#123;  return path.join(__dirname, dir);&#125;const config = &#123;  //...  module: &#123;     noParse: /jquery|lodash/,    rules: [      &#123;        test: /\\.js$/i,        include: resolve(&#x27;src&#x27;),        exclude: /node_modules/,        use: [          &#x27;babel-loader&#x27;,        ]      &#125;,      // ...    ]  &#125;&#125;;\n\n\n\n1.5 noParse\n不需要解析依赖的第三方大型类库等，可以通过这个字段进行配置，以提高构建速度\n使用 noParse 进行忽略的模块文件中不会解析 import、require 等语法\n\nconst config = &#123;  //...  module: &#123;     noParse: /jquery|lodash/,    rules:[...]  &#125;&#125;;\n\n\n\n1.6 IgnorePlugin防止在 import 或 require 调用时，生成以下正则表达式匹配的模块：\n\nrequestRegExp 匹配(test)资源请求路径的正则表达式。\ncontextRegExp 匹配(test)资源上下文（目录）的正则表达式。\n\nnew webpack.IgnorePlugin(&#123; resourceRegExp, contextRegExp &#125;);\n\n以下示例演示了此插件的几种用法。\n\n安装 moment 插件（时间处理库）\n\n$ npm i -S moment\n\n\n配置 IgnorePlugin\n\n// 引入 webpackconst webpack = require(&#x27;webpack&#x27;)const config = &#123;  ...  plugins:[ // 配置插件    ...    new webpack.IgnorePlugin(&#123;      resourceRegExp: /^\\.\\/locale$/,      contextRegExp: /moment$/,    &#125;),  ]  &#125;;\n\n目的是将插件中的非中文语音排除掉，这样就可以大大节省打包的体积了\n2. 优化构建结果2.1 压缩 CSS\n安装 optimize-css-assets-webpack-plugin\n\n$ npm install -D optimize-css-assets-webpack-plugin \n\n\n修改 webapck.config.js 配置\n\n// ...// 压缩cssconst OptimizeCssAssetsPlugin = require(&#x27;optimize-css-assets-webpack-plugin&#x27;)// ...const config = &#123;  // ...  optimization: &#123;    minimize: true,    minimizer: [      // 添加 css 压缩配置      new OptimizeCssAssetsPlugin(&#123;&#125;),    ]  &#125;, // ...&#125;// ...\n\n\n\n2.2 压缩 JS\n在生成环境下打包默认会开启 js 压缩，但是当我们手动配置 optimization 选项之后，就不再默认对 js 进行压缩，需要我们手动去配置。\n\n因为 webpack5 内置了terser-webpack-plugin 插件，所以我们不需重复安装，直接引用就可以了，具体配置如下\nconst TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;);const config = &#123;  // ...  optimization: &#123;    minimize: true, // 开启最小化    minimizer: [      // ...      new TerserPlugin(&#123;&#125;)    ]  &#125;,  // ...&#125;\n\n\n\n2.3 清除无用的 CSSpurgecss-webpack-plugin 会单独提取 CSS 并清除用不到的 CSS\n\n安装插件\n\n$ npm i -D purgecss-webpack-plugin\n\n\n添加配置\n\n// ...const PurgecssWebpackPlugin = require(&#x27;purgecss-webpack-plugin&#x27;)const glob = require(&#x27;glob&#x27;); // 文件匹配模式// ...function resolve(dir)&#123;  return path.join(__dirname, dir);&#125;const PATHS = &#123;  src: resolve(&#x27;src&#x27;)&#125;const config = &#123;  plugins:[ // 配置插件    // ...    new PurgecssPlugin(&#123;      paths: glob.sync(`$&#123;PATHS.src&#125;/**/*`, &#123;nodir: true&#125;)    &#125;),  ]&#125;\n\n\n\n2.4 Tree-shakingTree-shaking 作用是剔除没有使用的代码，以降低包的体积\n\nwebpack 默认支持，需要在 .bablerc 里面设置 model：false，即可在生产环境下默认开启\n\nmodule.exports = &#123;  presets: [    [      &quot;@babel/preset-env&quot;,      &#123;        module: false,        useBuiltIns: &quot;entry&quot;,        corejs: &quot;3.9.1&quot;,        targets: &#123;          chrome: &quot;58&quot;,          ie: &quot;11&quot;,        &#125;,      &#125;,    ],  ],  plugins: [        [&quot;@babel/plugin-proposal-decorators&quot;, &#123; legacy: true &#125;],    [&quot;@babel/plugin-proposal-class-properties&quot;, &#123; loose: true &#125;],  ]&#125;;\n\n\n\n3. 优化运行时体验运行时优化的核心就是提升首屏的加载速度，主要的方式就是\n\n降低首屏加载文件体积，首屏不需要的文件进行预加载或者按需加载\n\n3.1 入口点分割配置多个打包入口，多页打包，这里不过多介绍\n3.2 splitChunks 分包配置optimization.splitChunks 是基于 SplitChunksPlugin 插件实现的\n默认情况下，它只会影响到按需加载的 chunks，因为修改 initial chunks 会影响到项目的 HTML 文件中的脚本标签。\nwebpack 将根据以下条件自动拆分 chunks：\n\n新的 chunk 可以被共享，或者模块来自于 node_modules 文件夹\n新的 chunk 体积大于 20kb（在进行 min+gz 之前的体积）\n当按需加载 chunks 时，并行请求的最大数量小于或等于 30\n当加载初始化页面时，并发请求的最大数量小于或等于 30\n\n\n默认配置介绍\n\nmodule.exports = &#123;  //...  optimization: &#123;    splitChunks: &#123;      chunks: &#x27;async&#x27;, // 有效值为 `all`，`async` 和 `initial`      minSize: 20000, // 生成 chunk 的最小体积（≈ 20kb)      minRemainingSize: 0, // 确保拆分后剩余的最小 chunk 体积超过限制来避免大小为零的模块      minChunks: 1, // 拆分前必须共享模块的最小 chunks 数。      maxAsyncRequests: 30, // 最大的按需(异步)加载次数      maxInitialRequests: 30, // 打包后的入口文件加载时，还能同时加载js文件的数量（包括入口文件）      enforceSizeThreshold: 50000,      cacheGroups: &#123; // 配置提取模块的方案        defaultVendors: &#123;          test: /[\\/]node_modules[\\/]/,          priority: -10,          reuseExistingChunk: true,        &#125;,        default: &#123;          minChunks: 2,          priority: -20,          reuseExistingChunk: true,        &#125;,      &#125;,    &#125;,  &#125;,&#125;;\n\n\n项目中的使用\n\nconst config = &#123;  //...  optimization: &#123;    splitChunks: &#123;      cacheGroups: &#123; // 配置提取模块的方案        default: false,        styles: &#123;            name: &#x27;styles&#x27;,            test: /\\.(s?css|less|sass)$/,            chunks: &#x27;all&#x27;,            enforce: true,            priority: 10,          &#125;,          common: &#123;            name: &#x27;chunk-common&#x27;,            chunks: &#x27;all&#x27;,            minChunks: 2,            maxInitialRequests: 5,            minSize: 0,            priority: 1,            enforce: true,            reuseExistingChunk: true,          &#125;,          vendors: &#123;            name: &#x27;chunk-vendors&#x27;,            test: /[\\\\/]node_modules[\\\\/]/,            chunks: &#x27;all&#x27;,            priority: 2,            enforce: true,            reuseExistingChunk: true,          &#125;,         // ... 根据不同项目再细化拆分内容      &#125;,    &#125;,  &#125;,&#125;\n\n3.3 代码懒加载针对首屏加载不太需要的一些资源，我们可以通过懒加载的方式去实现，下面看一个小🌰\n\n需求：点击图片给图片加一个描述\n\n1. 新建图片描述信息\nconst ele = document.createElement(&#x27;div&#x27;)ele.innerHTML = &#x27;我是图片描述&#x27;module.exports = ele\n\n2. 点击图片引入描述\nimport &#x27;./main.css&#x27;;import &#x27;./sass.scss&#x27;import logo from &#x27;../public/avatar.png&#x27;import &#x27;@/fonts/iconfont.css&#x27;const a = &#x27;Hello ITEM&#x27;console.log(a)const img = new Image()img.src = logodocument.getElementById(&#x27;imgBox&#x27;).appendChild(img)// 按需加载img.addEventListener(&#x27;click&#x27;, () =&gt; &#123;  import(&#x27;./desc&#x27;).then((&#123; default: element &#125;) =&gt; &#123;    console.log(element)    document.body.appendChild(element)  &#125;)&#125;)\n\n\n\n3.4 prefetch 与 preload上面我们使用异步加载的方式引入图片的描述，但是如果需要异步加载的文件比较大时，在点击的时候去加载也会影响到我们的体验，这个时候我们就可以考虑使用 prefetch 来进行预拉取\n3.4.1 prefetch\nprefetch (预获取)：浏览器空闲的时候进行资源的拉取\n\n改造一下上面的代码\n// 按需加载img.addEventListener(&#x27;click&#x27;, () =&gt; &#123;  import( /* webpackPrefetch: true */ &#x27;./desc&#x27;).then((&#123; default: element &#125;) =&gt; &#123;    console.log(element)    document.body.appendChild(element)  &#125;)&#125;)\n\n3.4.2 preload\npreload (预加载)：提前加载后面会用到的关键资源\n⚠️ 因为会提前拉取资源，如果不是特殊需要，谨慎使用\n\n网示例：\nimport(/* webpackPreload: true */ &#x27;ChartingLibrary&#x27;);\n\n","categories":["构建工具"],"tags":["Webpack"]},{"title":"Sass 和 Less","url":"/2022/10/11/sass%E5%92%8Cless/","content":"\n\nSassSass是一种动态样式语言，Sass语法属于缩排语法，比css比多出好些功能(如&#x3D;&#x3D;变量、嵌套、运算、混入(Mixin)、继承、颜色处理，函数&#x3D;&#x3D;等)，更容易阅读。\nSass与Scss是什么关系?\nSass的缩排语法，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此&#x3D;&#x3D;sass语法进行了改良，Sass 3就变成了Scss(sassy css)&#x3D;&#x3D;。与原来的语法兼容，只是用{}取代了原来的缩进。\nLessLess也是一种动态样式语言. 受Sass影响较大,对CSS赋予了动态语言的特性，如变量，继承，运算， 函数。&#x3D;&#x3D;Less 既可以在客户端上运行，也可在服务端运行&#x3D;&#x3D; (借助 Node.js)。\nSass&#x2F;Scss与Less区别1 编译环境不一样\nSass的安装需要Ruby环境，是在服务端处理的；\nLess是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中\n\n2 变量符不一样Scss是$，而Less是@\nscss-作用域$color: #00c; /* 蓝色 */#header &#123;    $color: #c00; /* red */    border: 1px solid $color; /* 红色边框 */&#125;#footer &#123;    border: 1px solid $color; /* 蓝色边框 */&#125;Less-作用域@color: #00c; /* 蓝色 */#header &#123;        @color: #c00; /* red */    border: 1px solid @color; /* 红色边框 */&#125;#footer &#123;    border: 1px solid @color; /* 蓝色边框 */&#125;Less-作用域编译后#header&#123;    border:1px solid #cc0000;&#125;\n\n\n\n3 输出设置Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded，stylus不知。\n输出样式的风格可以有四种选择，默认为nested\n\nnested：嵌套缩进的css代码\nexpanded：展开的多行css代码\ncompact：简洁格式的css代码\ncompressed：压缩后的css代码\n\n4 处理条件语句Sass支持条件语句，可以使用if{}else{}，for{}循环等等。\nLess的条件语句使用有些另类，他不是我们常见的关键词if和else if之类，而其实现方式是利用关键词“when”\n5 引用外部CSS文件scss引用的外部文件命名必须以_开头\nLess引用外部文件和css中的@import没什么差异。\n// 源代码：@import &quot;_test1.scss&quot;;@import &quot;_test2.scss&quot;;// 编译后：h1 &#123;    font-size: 17px;&#125;h2 &#123;    font-size: 17px;&#125;\n\n","categories":["CSS"],"tags":["Sass","Lessss"]},{"title":"理解 Git 工作流","url":"/2022/09/22/Git/","content":"\n\n\nGit 的工作区域和流程![image-20230502160822523](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230502160822523.png)\nWorkspace：工作区，就是平时进行开发改动的地方，是当前看到最新的内容，在开发的过程也就是对工作区的操作\nIndex：暂存区，当执行 git add 的命令后，工作区的文件就会被移入暂存区，暂存区标记了当前工作区中那些内容是被 Git 管理的，当完成某个需求或者功能后需要提交代码，第一步就是通过 git add 先提交到暂存区。\nRepository：本地仓库，位于自己的电脑上，通过 git commit 提交暂存区的内容，会进入本地仓库。\nRemote：远程仓库，用来托管代码的服务器，远程仓库的内容能够被分布在多个地点的处于协作关系的本地仓库修改，本地仓库修改完代码后通过 git push 命令同步代码到远程仓库。\nGit 基本操作git add添加文件到暂存区\n# 添加某个文件到暂存区，后面可以跟多个文件，以空格区分git add xxx# 添加当前更改的所有文件到暂存区。git add .\n\ngit commit# 提交暂存的更改，会新开编辑器进行编辑git commit # 提交暂存的更改，并记录下备注git commit -m &quot;you message&quot;# 等同于 git add . &amp;&amp; git commit -mgit commit -am# 对最近一次的提交的信息进行修改,此操作会修改commit的hash值git commit --amend\n\ngit pull# 从远程仓库拉取代码并合并到本地，可简写为 git pull 等同于 git fetch &amp;&amp; git merge git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;# 使用rebase的模式进行合并git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;\n\ngit fetch与 git pull 不同的是 git fetch 操作仅仅&#x3D;&#x3D;只会拉取远程的更改，不会自动进行 merge 操作&#x3D;&#x3D;。对你当前的代码没有影响\n# 获取远程仓库特定分支的更新git fetch &lt;远程主机名&gt; &lt;分支名&gt;# 获取远程仓库所有分支的更新git fetch --all\n\ngit branch# 新建本地分支，但不切换git branch &lt;branch-name&gt; # 查看本地分支git branch# 查看远程分支git branch -r# 查看本地和远程分支git branch -a# 删除本地分支git branch -D &lt;branch-nane&gt;# 重新命名分支git branch -m &lt;old-branch-name&gt; &lt;new-branch-name&gt;\n\n\n\n\n\n工作中使用 Git 解决问题的场景git rebase 让你的提交记录更加清晰可读git rebase 的使用rebase 翻译为变基，他的作用和 merge 很相似，&#x3D;&#x3D;用于把一个分支的修改合并到当前分支上&#x3D;&#x3D;。\n如下图所示，下图介绍了经过 rebase 后提交历史的变化情况。\n![image-20230502161455774](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230502161455774.png)\n\n假设我们现在有2条分支，一个为 master，一个为 feature&#x2F;1，他们都基于初始的一个提交 add readme 进行检出分支；\n之后，master 分支增加了 3.js 和 4.js 的文件，分别进行了2次提交；\nfeature&#x2F;1 也增加了 1.js 和 2.js 的文件，分别对应以下2条提交记录。\n\n\n\n大部分情况下，rebase 的过程中会产生冲突的，此时，就需要手动解决冲突，然后使用依次 git add  、git rebase --continue  的方式来处理冲突，完成 rebase 的过程，如果不想要某次 rebase 的结果，那么需要使用 git rebase --skip  来跳过这次 rebase 操作。\ngit merge 和 git rebase 的区别不同于 git rebase 的是，&#x3D;&#x3D;git merge 会产生一条额外的合并记录&#x3D;&#x3D;，类似 Merge branch &#39;xxx&#39; into &#39;xxx&#39; 的一条提交信息。\n![image-20230502162315413](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230502162315413.png)\n另外，在解决冲突的时候，&#x3D;&#x3D;用 merge 只需要解决一次冲突即可&#x3D;&#x3D;，简单粗暴，而&#x3D;&#x3D;用 rebase 的时候 ，需要依次解决每次的冲突&#x3D;&#x3D;，才可以提·交。\n总结：- \n\ngit merge 会让2个分支的提交按照提交时间进行排序，并且会把最新的2个commit合并成一个commit。最后的分支树呈现&#x3D;&#x3D;非线性&#x3D;&#x3D;的结构\ngit reabse 将dev的当前提交复制到master的最新提交之后，会形成一个&#x3D;&#x3D;线性的分支树&#x3D;&#x3D;\n\ngit merge --squash  #在merge分支的时候把分支上的所有commit合并为一个commit后,再merge到目标分支。\n\n\n\n使用 git cherry-pick 获取指定的 commitgit cherry-pick 可以理解为”挑拣”提交，和 merge 合并一个分支的所有提交不同的是，它会获取某一个分支的单笔提交，并作为一个新的提交引入到你当前分支上。\n当我们需要在本地合入其他分支的提交时，如果我们不想对整个分支进行合并，而是只想将某一次提交合入到本地当前分支上，那么就要使用 git cherry-pick 了。\n使用 git revert 回滚某次的提交想象这么一个场景，你的项目最近有2个版本要上线，这两个版本还伴随着之前遗留的 bug 的修复，一开始的时候，你将 bug 修复在了第一个版本的 release 分支上，突然在发版前一天，测试那边反馈，需要把第一个版本修复 bug 的内容改在第二个版本上，这个时候，第一个版本的集成分支的提交应该包括了第一个版本的功能内容，遗留 bug 修复的提交和其他同事提交的内容，想要通过 reset 的方式粗暴摘除之前的关于 bug 修复的 commit 肯定是不行的，同时，这种做法比较危险，此时，我们既不想破坏之前的提交记录，又想撤回我们遗留 bug 的 commit 记录应该怎么做呢？git revert 就派上了用场。\n\ngit revert 撤销某次操作，此操作不会修改原本的提交记录，而是会新增一条提交记录来抵消某次操作。\n\n语法： \ngit revert &lt;commit-id&gt;  \t\t#针对普通 commitgit revert &lt;commit-id&gt; -m  \t#针对 merge 的 commit\n\n![image-20230502163330171](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230502163330171.png)\ngit revert 1121932\n\n![image-20230502163352737](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230502163352737.png)\n会新建一条 commit 信息，来撤回之前的修改。\ngit revert VS git reset回滚我们的提交有二种方式，一种是上文提到的git revert命令外，还可以使用 git reset 命令，那么它们两者有什么区别呢？\n\ngit revert 会新建一条 commit 信息，来撤回之前的修改。\ngit reset 会直接将提交记录退回到指定的 commit 上。\n\n&#x3D;&#x3D;对于个人的 feature 分支而言，可以使用 git reset 来回退历史记录&#x3D;&#x3D;，之后使用 git push --force 进行推送到远程，但是如果是在多人&#x3D;&#x3D;协作的集成分支上，不推荐直接使用 git reset 命令，而是使用更加安全的 git revert 命令进行撤回提交&#x3D;&#x3D;。这样，提交的历史记录不会被抹去，可以安全的进行撤回。\n使用 git stash 来暂存文件会有这么一个场景，现在你正在用你的 feature 分支上开发新功能。这时，生产环境上出现了一个 bug 需要紧急修复，但是你这部分代码还没开发完，不想提交，怎么办？这个时候可以用 git stash 命令先把工作区已经修改的文件暂存起来，然后切换到 hotfix 分支上进行 bug 的修复，修复完成后，切换回 feature 分支，从堆栈中恢复刚刚保存的内容。\n基本命令如下：\ngit stash # 把本地的改动暂存起来git stash save &quot;message&quot; # 执行存储时，添加备注，方便查找。git stash pop # 应用最近一次暂存的修改，并删除暂存的记录git stash apply  # 应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即 stash@&#123;0&#125;，如果要使用其他个，git stash apply stash@&#123;$num&#125; 。git stash list # 查看 stash 有哪些存储git stash clear # 删除所有缓存的 stash\n\n\n\n\n\n对GitFlow的理解?GitFlow重点解决的是由于源代码在开发过程中的各种冲突导致开发活动混乱的问题。重点是对各个分支的理解。\n\nmaster：主分支。\ndevelop：主开发分支，平行于master分支。\nfeature：功能分支，必须从develop分支建立，开发完成后合并到develop分支。\nrelease：发布分支，发布的时候用，一般测试时候发现的 bug 在该分支进行修复。从develop分支建立，完成后合并回develop与master分支。\nhotfix：紧急修复线上bug使用，必须从master分支建立，完成后合并回develop与master分支。\n\n阅读原文\n","categories":["Git"],"tags":["Git"]}]