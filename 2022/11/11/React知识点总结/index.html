<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="知识在世界的某个角落等你">
    <meta name="author" content="Chao">
    
    <title>
        
            React 知识点总结 |
        
        XChao&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/avatar.jpg">
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"xiongcao.github.io","root":"/","language":"en","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/avatar.jpg","favicon":"/images/avatar.jpg","avatar":"/images/avatar.jpg","font_size":null,"font_family":null,"hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"黄色的森林分出两条路，我选择人迹更少的那一条，从此决定我一生的道路。","font_color":null,"hitokoto":true},"scroll":{"progress_bar":true,"percent":true}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"mac"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":true,"use":"waline","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":"https://bear-blog-comment-8yis8zzwo-xiongcao.vercel.app","reaction":true,"version":2}},"post":{"author_label":{"enable":true,"auto":false,"custom_label_list":["Trainee","Engineer","Architect","实习生","工程师","架构师","程序鼓励师"]},"word_count":{"enable":true,"wordcount":true,"min2read":true},"img_align":"left","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original article title","author":"Original article author","link":"Original article link"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/avatar.jpg">
                </a>
            
            <a class="logo-title" href="/">
               XChao&#39;s Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                LINKS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">LINKS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">React 知识点总结</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.jpg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Chao</span>
                            
                                <span class="author-label">工程师</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2022-11-11 13:15:00</span>
        <span class="mobile">2022-11-11 13:15</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2023-07-20 16:04:30</span>
    </span>
    
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/React/">React</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/React/">React</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>8k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>30 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <span id="more"></span>

<p>![image-20230422145757216](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230422145757216.png)</p>
<p><strong>React 副作用</strong>：是在组件渲染期间发生的任何操作，这些操作不仅仅是更新 DOM。副作用可能包括网络请求、访问本地存储、添加或删除事件监听器等。副作用是与 React 的声明式编程模型相对的</p>
<h2 id="什么是React"><a href="#什么是React" class="headerlink" title="什么是React"></a>什么是React</h2><ol>
<li><code>React</code> 是一个网页UI框架，通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。</li>
<li>它的核心设计思路有三点，分别是声明式、组件化与通用性。</li>
<li><strong>声明式</strong>的优势在于直观与组合。</li>
<li><strong>组件化</strong>的优势在于视图的拆分与模块复用，可以更容易做到高内聚低耦合。</li>
<li><strong>通用性</strong>在于一次学习，随处编写。比如 <code>React Native</code>，<code>React 360</code> 等，这里主要靠虚拟 <code>DOM</code> 来保证实现。</li>
<li>这使得 <code>React</code> 的适用范围变得足够广，无论是 <code>Web</code>、<code>Native</code>、<code>VR</code>，甚至 <code>Shell</code> 应用都可以进行开发。这也是 <code>React</code> 的优势。</li>
<li>但作为一个视图层的框架，<code>React</code> 的劣势也十分明显。它并没有提供完整的一揽子解决方案，在开发大型前端应用时，需要向社区寻找并整合解决方案。虽然一定程度上促进了社区的繁荣，但也为开发者在技术选型和学习适用上造成了一定的成本。</li>
</ol>
<h2 id="什么是JSX"><a href="#什么是JSX" class="headerlink" title="什么是JSX"></a>什么是JSX</h2><h5 id="React本身并不强制使用JSX："><a href="#React本身并不强制使用JSX：" class="headerlink" title="React本身并不强制使用JSX："></a><code>React</code>本身并不强制使用<code>JSX</code>：</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">    	<span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      <span class="string">`hello <span class="subst">$&#123;<span class="variable language_">this</span>.props.toWhat&#125;</span>`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">	<span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="title class_">Hello</span>, &#123;toWhat, <span class="string">&#x27;World&#x27;</span>&#125;, <span class="literal">null</span>),</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>React 需要将组件转化为虚拟 DOM 树；</p>
<p><strong>XML</strong>在树结构的描述上天生具有可读性强的优势。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;this.props.toWath&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">toWhat</span>=<span class="string">&quot;world&quot;</span>/&gt;</span></span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>以<code>AngularJS</code> 为例</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line">&lt;htmlng-app=&quot;docsBindExample&quot;&gt;</span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://code.angularjs.org/1.2.25/angular.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;scriptjs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>&quot;<span class="attr">Ctrl1</span>&quot;</span></span><br><span class="line"><span class="tag">    <span class="attr">Hello</span> &lt;<span class="attr">input</span> <span class="attr">ng-model</span>=<span class="string">&#x27;name&#x27;</span>&gt;</span> <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">ng-bind</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">ng:bind</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">htmlgn-app</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = jsx<span class="string">`</span></span><br><span class="line"><span class="string">	&lt;<span class="subst">$&#123;Box&#125;</span>&gt;</span></span><br><span class="line"><span class="string">	<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">		shouldShowAnswer(user) ?</span></span></span><br><span class="line"><span class="subst"><span class="string">    jsx<span class="string">`&lt;<span class="subst">$&#123;Answer&#125;</span>&gt;&lt;/<span class="subst">$&#123;Answer&#125;</span>&gt;`</span> :</span></span></span><br><span class="line"><span class="subst"><span class="string">		jsx<span class="string">`&lt;<span class="subst">$&#123;Box.Comment&#125;</span>&gt;Text Content&lt;/<span class="subst">$&#123;Box.Comment&#125;</span>&gt;`</span></span></span></span><br><span class="line"><span class="subst"><span class="string">	&#125;</span></span></span><br><span class="line"><span class="string">	&lt;/<span class="subst">$&#123;Box&#125;</span>&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><img  
                     lazyload
                     alt="image"
                     data-src="/Users/xiongchao/Library/Application Support/typora-user-images/image-20230422151324886.png"
                      alt="image-20230422151324886" style="zoom:33%;" 
                >

<ol>
<li><p><code>JSX</code> 是一个 <code>JavaScript</code> 的语法扩展，结构类似于<code>XML</code>。</p>
</li>
<li><p><code>JSX</code>主要用来声明<code>React</code>元素，但React并取强制要求是用<code>JSX</code>，即使使用了<code>JSX</code>，也会在构建的过程中通过<code>babel</code>插件转化为<code>React.CreateElement</code>，所以<code>JSX</code>更像是<code>React.CreateElement</code>的语法糖，可以看出<code>React</code>团队并不想引入<code>JavaScript</code>本身以外的开发体系，而是通过合理的关注点分离保持组件开发的纯粹性。</p>
</li>
<li><p>对比</p>
<ol>
<li>模板：引入模板语法和模板指令等概念是一种不佳的实现方案；</li>
<li>模板字符串：造成多次嵌套，使整个结构变的复杂，并且优化代码提示也会变的困难重重</li>
<li><code>JXON</code>：同样因为语法提示问题被<code>React</code>放弃</li>
</ol>
</li>
</ol>
<p>最后选用了<code>JSX</code>，因为<code>JSX</code>与其设计思想贴合，不需要引入过多新的概念，对代码编辑器的提示也极为友好。</p>
<h2 id="如何避免生命周期的坑"><a href="#如何避免生命周期的坑" class="headerlink" title="如何避免生命周期的坑"></a>如何避免生命周期的坑</h2><ul>
<li>在不恰当的时机调用了不合适的代码</li>
<li>在需要调用时，却忘记了调用</li>
</ul>
<h4 id="建立时机与操作的对应关系"><a href="#建立时机与操作的对应关系" class="headerlink" title="建立时机与操作的对应关系"></a>建立时机与操作的对应关系</h4><img  
                     lazyload
                     alt="image"
                     data-src="/Users/xiongchao/Library/Application Support/typora-user-images/image-20230422160931659.png"
                      alt="image-20230422160931659" style="zoom:33%;" 
                >



<img  
                     lazyload
                     alt="image"
                     data-src="/Users/xiongchao/Library/Application Support/typora-user-images/image-20230422154005672.png"
                      alt="image-20230422154005672" style="zoom:33%;" 
                >



<h4 id="社区中去除-constructor-的原因"><a href="#社区中去除-constructor-的原因" class="headerlink" title="社区中去除 constructor 的原因"></a>社区中去除 constructor 的原因</h4><ul>
<li><code>constructor</code> 中并不推荐去处理初始化以外的逻辑；</li>
<li><code>constructor</code> 不属于 <code>React</code> 的生命周期，只是 <code>Class</code> 的初始化函数；</li>
<li>通过移除 <code>constructor</code>，代码也会变得更简洁；</li>
</ul>
<h4 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h4><h5 id="getDerivedStateFromPorps"><a href="#getDerivedStateFromPorps" class="headerlink" title="getDerivedStateFromPorps"></a><code>getDerivedStateFromPorps</code></h5><p>本函数的作用是使组件在 <code>props</code> 变化时更新 <code>state</code>。</p>
<p>触发时机：（只要父级组件重新渲染时就会被调用）</p>
<ul>
<li>当 <code>props</code> 被传入时；</li>
<li><code>state</code> 发生改变时；</li>
<li><code>forceUpdate</code> 被调用时；</li>
</ul>
<p>&#x3D;&#x3D;你可能不需要使用派生state&#x3D;&#x3D;。两种反模式使用方式：</p>
<ul>
<li>直接复制 <code>props</code> 到 <code>state</code></li>
<li>在 <code>props</code> 变化后修改 <code>state</code></li>
</ul>
<p>这两种写法，&#x3D;&#x3D;除了增加代码的维护成本外，没有任何好处&#x3D;&#x3D;。</p>
<h5 id="UNSAFE-componentWillMount"><a href="#UNSAFE-componentWillMount" class="headerlink" title="UNSAFE_componentWillMount"></a><code>UNSAFE_componentWillMount</code></h5><p>用于组件将加载前做某些操作，但目前被标记为弃用。因在 React 异步渲染机制下，该方法&#x3D;&#x3D;可能被多次调用&#x3D;&#x3D;。</p>
<p>常见的错误是：和服务器端同构渲染的时候，如果在该函数里面发起网络请求，会在服务端和客户端分别执行一次。</p>
<h5 id="render"><a href="#render" class="headerlink" title="render"></a><code>render</code></h5><p><code>render</code> 函数返回的 <code>JSX</code> 结构，用于描述具体的渲染内容。</p>
<p>不应该在<code>render</code> 函数里面产生任何副作用，比如使用<code>setState</code>或者<code>绑定事件</code>。</p>
<p>render函数在每次渲染时都会被调用，而<code>setState</code>会触发渲染，会造成死循环。绑定事件会被频繁调用注册。</p>
<h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><p>指外部 <code>props</code> 传入，或 <code>state</code> 发生变化时的阶段。</p>
<img  
                     lazyload
                     alt="image"
                     data-src="/Users/xiongchao/Library/Application Support/typora-user-images/image-20230422162105242.png"
                      alt="image-20230422162105242" style="zoom: 50%;" 
                >



<p><code>UNSAFE_componentWillReceiveProps</code>：在<code>getDerivedStateFromPorps</code>存在时，不会被调用。</p>
<p><code>UNSAFE_componentWillUpdate</code>：因为在后续的React异步渲染设置中，可能会&#x3D;&#x3D;出现暂停更新渲染&#x3D;&#x3D;的情况；</p>
<p><code>getSnapshotBeforeUpdate</code>： 返回值会作为 <code>componentDidUpdate</code> 的第三个参数使用。</p>
<h4 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h4><p><code>componentWillUnmount</code></p>
<p>主要用于执行清理工作。一定要在该阶段解除事件绑定，取消定时器。</p>
<p>不然会导致定时器在组件销毁后一直在不停地执行；</p>
<h4 id="职责："><a href="#职责：" class="headerlink" title="职责："></a>职责：</h4><ul>
<li>什么情况下会触发重新渲染？</li>
<li>渲染中发生报错后会怎样? 该如何处理?</li>
</ul>
<h5 id="函数组件："><a href="#函数组件：" class="headerlink" title="函数组件："></a>函数组件：</h5><p>任何情况下都会重新渲染，没有生命周期，官方提供<code>React.memo</code>优化手段。</p>
<p><code>React.memo</code>并不是阻断渲染，而是&#x3D;&#x3D;跳过渲染组件的操作，并直接复用最后一次渲染的结果&#x3D;&#x3D;</p>
<h5 id="React-Component："><a href="#React-Component：" class="headerlink" title="React.Component："></a><code>React.Component</code>：</h5><p>不实现 <code>shouldComponentUpdate</code> 函数，有两种情况触发重新渲染</p>
<ol>
<li>当 state 发生变化时</li>
<li>当父级组件的 Props 传入时</li>
</ol>
<h5 id="React-PureComponent："><a href="#React-PureComponent：" class="headerlink" title="React.PureComponent："></a><code>React.PureComponent</code>：</h5><p>默认实现了 <code>shouldComponentUpdate</code> 函数<br>仅在 <code>props</code> 与 <code>state</code> 进行浅比较后，确认有变更时才会触发重新渲染。</p>
<h4 id="错误边界："><a href="#错误边界：" class="headerlink" title="错误边界："></a>错误边界：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">		<span class="comment">// 更新state使下一次渲染能够显示降级后的UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">	<span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">    <span class="comment">// Display fallback UI</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">// You can also log the error to an error reporting service</span></span><br><span class="line">    <span class="title function_">logErrorToMyService</span>(error, info);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>componentDidCatch</code>：捕获报错的具体类型，并将错误类型上传到服务端去。</p>
<p>用户执行某个操作时，触发了bug，引发了崩溃，页面会突然白屏，但渲染时的报错，只能通过 <code>componentDidCatch</code> 捕获。这是在做线上错误监控时，极其容易忽略的点。</p>
<h2 id="React-的请求应该放在哪里，为什么？"><a href="#React-的请求应该放在哪里，为什么？" class="headerlink" title="React 的请求应该放在哪里，为什么？"></a>React 的请求应该放在哪里，为什么？</h2><p>对于异步请求，应放在 <code>componentDidMount</code> 中操作从时间顺序看，除 <code>componentDidMount</code> 还可以有以下选择：</p>
<ul>
<li><code>constructor</code>：可放，从设计言不推荐，主要用于初始化 <code>state</code> 与函数绑定，不承载业务逻辑且随着类属性流行，<code>constructor</code> 已很少用</li>
<li><code>componentWillMount</code>：已被标记废弃，在新的异步渲染架构下会触发多次渲染，易引发 Bug，不利未来 React 升级后的代码维护</li>
</ul>
<h2 id="类组件和函数组件的区别？"><a href="#类组件和函数组件的区别？" class="headerlink" title="类组件和函数组件的区别？"></a>类组件和函数组件的区别？</h2><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><p>函数组件和类组件&#x3D;&#x3D;使用方式&#x3D;&#x3D;和&#x3D;&#x3D;最终呈现效果&#x3D;&#x3D;上是完全一致的。</p>
<p>很难从使用体验上区分两者，而且现代浏览器，闭包和类的性能是在极端场景下才会有区别。所以基本认为两者作为组件是完全一致的。</p>
<h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><p><strong>基础认知</strong>：本质上代表两种&#x3D;&#x3D;不同设计思想&#x3D;&#x3D;与心智模式</p>
<ul>
<li>类组件的根基是 <code>OOP</code>，面向对象编程；</li>
<li>函数组件的根基是 <code>FP</code>，也就是函数式编程；</li>
</ul>
<p>函数式编程：假定输入和输出，存在某种特定的映射关系时，那么输入一定的情况下，输出必然是确定的。</p>
<p>本质上，最大的不同：&#x3D;&#x3D;相较于类组件，函数组件更纯粹、简单、易测试&#x3D;&#x3D;。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>在不使用 Recompose 或者 <code>Hooks</code> 的情况下如需使用生命周期，就用类组件，限定场景是固定的。</li>
<li>在 recompose 或 <code>Hooks</code> 的加持下，类组件与函数组件的能力边界完全相同，都可使用类似生命周期等能力</li>
</ul>
<p><strong>设计模式：</strong></p>
<ul>
<li>类组件可以实现继承</li>
<li>函数组件缺少继承能力</li>
</ul>
<p><code>React</code>不推荐使用继承，组合由于继承</p>
<p><strong>未来趋势：</strong></p>
<p>&#x3D;&#x3D;函数组件&#x3D;&#x3D;成为了社区未来主推的方案。</p>
<p>类组件不能适应未来趋势的原因：</p>
<ul>
<li><code>this</code> 的模糊性</li>
<li>业务逻辑散落在生命周期中</li>
<li>React组件，代码缺少标准的拆分方式</li>
</ul>
<p>使用<code>Hooks</code>函数组件可以提供比原生更细腻的逻辑组织与复用，而且能更好的适应时间切片与并发模式。</p>
<h2 id="如何设计React组件"><a href="#如何设计React组件" class="headerlink" title="如何设计React组件"></a>如何设计React组件</h2><ul>
<li>把只作展示、独立运行、不额外增加功能的组件，称为哑组件或无状态组件、&#x3D;&#x3D;展示组件&#x3D;&#x3D;；</li>
<li>把处理业务逻辑与数据状态的组件称为有状态组件、&#x3D;&#x3D;灵巧组件&#x3D;&#x3D;。灵巧组件一定包含至少一个灵巧组件或展示组件。</li>
</ul>
<h4 id="展示组件"><a href="#展示组件" class="headerlink" title="展示组件"></a>展示组件</h4><p>展示组件受制于外部的 props 控制，具有极强的通用性，复用率很高</p>
<p><strong>代理组件</strong>：常用于封装常用属性，减少重复代码。</p>
<p>即对UI库的二次封装，对于常用属性给默认值，如果需要修改属性，直接传入props覆盖默认值即可。</p>
<p>虽然这样的封装看起来多此一举，但是切断了外部组件的强依赖性。</p>
<p>两个问题：</p>
<ul>
<li>如果当前组件库不能使用，是否能实现业务上的无痛切换；</li>
<li>如需批量修改基础组件的字段，如何解决?</li>
</ul>
<p>&#x3D;&#x3D;代理组件的设计模式&#x3D;&#x3D;很好地解决了以上问题业务上看，代理组件隔绝 <code>Antd</code>，仅是一个组件 <code>Props API</code> 层的交互</p>
<p><strong>样式组件</strong>：也是一种代理组件，只是又细分了处理样式领域，将当前的关注点分离到当前组件内</p>
<img  
                     lazyload
                     alt="image"
                     data-src="/Users/xiongchao/Library/Application Support/typora-user-images/image-20230422212924455.png"
                      alt="image-20230422212924455" style="zoom: 33%;" 
                >

<p>复杂的样式管理对于Button是没有意义的，如果直接使用Button在属性上进行修改，对于工程代码而言，这是编写大量的面条代码。StyleButton的思路就是，样式判断逻辑附令到自身上来，面向未来改动的时候会更加友好。</p>
<p><strong>布局组件</strong>基本设计与样式组件完全一样，基于自身特性做了一个小小的优化</p>
<h3 id="灵巧组件"><a href="#灵巧组件" class="headerlink" title="灵巧组件"></a>灵巧组件</h3><p>灵巧组件面向业务，功能更丰富、复杂性更高，复用度更低；</p>
<p>展示组件专注于组件本身特性，灵巧组件专注于组合组件。</p>
<h4 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h4><p>几乎没有复用性，主要用在<strong>拉取数据</strong>与组合组件两个方面。（没有冗余的样式和逻辑处理）</p>
<h4 id="高阶组件："><a href="#高阶组件：" class="headerlink" title="高阶组件："></a><strong>高阶组件</strong>：</h4><p>React 中复用组件逻辑的高级技术，是基于 React 的组合特性形成的设计模式；</p>
<p>高阶组件的参数是组件，返回值为新组件的函数。</p>
<p>作用：</p>
<ul>
<li>逻辑复用</li>
<li>链式调用</li>
<li>渲染劫持</li>
</ul>
<p>例子：登录态的判断。【数据埋点】</p>
<img  
                     lazyload
                     alt="image"
                     data-src="/Users/xiongchao/Library/Application Support/typora-user-images/image-20230422214100912.png"
                      alt="image-20230422214100912" style="zoom:33%;" 
                >



<p>例子：渲染劫持</p>
<p>通过控制 <code>render</code> 函数修改输出内容，常见的场景是显示加载元素</p>
<img  
                     lazyload
                     alt="image"
                     data-src="/Users/xiongchao/Library/Application Support/typora-user-images/image-20230422214742426.png"
                      alt="image-20230422214742426" style="zoom:33%;" 
                >



<h5 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h5><ul>
<li>丢失静态函数</li>
<li>refs属性不能透传</li>
</ul>
<p>使用Storybook工具对basic组件进行组件管理</p>
<h2 id="setState-是同步更新还是异步更新"><a href="#setState-是同步更新还是异步更新" class="headerlink" title="setState 是同步更新还是异步更新"></a>setState 是同步更新还是异步更新</h2><h4 id="合成事件："><a href="#合成事件：" class="headerlink" title="合成事件："></a>合成事件：</h4><ol>
<li>React 给 document 挂上事件监听</li>
<li>DOM 事件触发后冒泡到 document</li>
<li>React 找到对应的组件造出一个合成事件出来</li>
<li>并按组件树模拟一遍事件冒泡</li>
</ol>
<h5 id="React-17-之前的事件冒泡流程图："><a href="#React-17-之前的事件冒泡流程图：" class="headerlink" title="React 17 之前的事件冒泡流程图："></a>React 17 之前的事件冒泡流程图：</h5><p>事件委托挂载在document上</p>
<img  
                     lazyload
                     alt="image"
                     data-src="/Users/xiongchao/Library/Application Support/typora-user-images/image-20230509160751578.png"
                      alt="image-20230509160751578" style="zoom:50%;" align="left"
                >

<h5 id="React-17-之后的事件冒泡流程图："><a href="#React-17-之后的事件冒泡流程图：" class="headerlink" title="React 17 之后的事件冒泡流程图："></a>React 17 之后的事件冒泡流程图：</h5><p>事件委托不再挂载在document上，而是挂载在DOM容器上</p>
<img  
                     lazyload
                     alt="image"
                     data-src="/Users/xiongchao/Library/Application Support/typora-user-images/image-20230509160859820.png"
                      alt="image-20230509160859820"  style="zoom:50%;" align="left"
                >



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coun</span> t <span class="keyword">extends</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  	</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">    &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// 1</span></span><br><span class="line">    &#125;)</span><br><span class="line">	</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">    &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// 1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">preState</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: preState.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">    &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// 1</span></span><br><span class="line">    &#125;)</span><br><span class="line">	</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">preState</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: preState.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">    &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// 2</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>是否觉得 React 的 setState 执行像是一个队列?</strong><br>React 根据队列逐一执行，合并 state 数据完成后执行回调，根据结果更新虚拟 DOM触发渲染。</p>
<p><strong>异步更新（非真异步）</strong>——原因：</p>
<ul>
<li>保持内部的一致性（如果把setState改成同步了，但是props不是）</li>
<li>启用并发更新</li>
</ul>
<p>在源码中，通过<code>isBatchingUpdates</code>判断<code>setStates</code>是先存进队列还是直接更新。true：执行异步操作，false：直接更新。</p>
<p>在 React 的生命周期事件和合成事件中可拿到<code>isBatchingUpdates</code> 控制权将状态放进队列，控制执行节奏。</p>
<h4 id="setState-之后发生了什么"><a href="#setState-之后发生了什么" class="headerlink" title="setState 之后发生了什么"></a>setState 之后发生了什么</h4><p><code>React</code> 利用状态队列机制实现了 <code>setState</code> 的“异步”更新，避免频繁的重复更新 <code>state</code>。</p>
<p>首先将新的 <code>state</code> 合并到状态更新队列中，然后根据更新队列和 <code>shouldComponentUpdate</code> 的状态来判断是否需要更新组件。</p>
<p>在“异步”中，</p>
<p>如果对同一个值进行多次<code>setState</code>，<code>setState</code>的批量更新策略会对其进行覆盖，取最后一次的执行；</p>
<p>如果是同时<code>setState</code>多个不同的值，在更新时会对其进行合并批量更新。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">number</span>: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleAdd = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="number">2</span> &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="number">3</span> &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">number</span>: <span class="number">100</span>&#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">number</span>: <span class="number">200</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count, number &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count, number); <span class="comment">// 点击之后，只会打印一次</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        count: &#123;count&#125; - number: &#123;number&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleAdd&#125;</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setState</code> 本身代码的执行肯定是同步的，这里的异步是指是多个 state 会合成到一起进行批量更新。 同步还是异步取决于它被调用的环境。</p>
<ul>
<li>如果 <code>setState</code> 在 React 能够控制的范围被调用，它就是<strong>异步</strong>的；</li>
<li>如果 <code>setState</code> 在原生 JavaScript 控制的范围被调用，它就是<strong>同步</strong>的；</li>
</ul>
<p>1.异步情况：在<code>合成事件处理函数</code>，<code>生命周期函数</code></p>
<p>2.同步情况：在<code>原生事件处理函数</code>，<code>定时器回调函数</code>，<code>Ajax 回调函数</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setTimeout事件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>,&#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Count</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">            <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//自定义dom事件，也是同步修改</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#btn&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">                <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>); <span class="comment">// 1</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   btnAction = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">				<span class="comment">// 如果在这里执行setState，则是异步的；</span></span><br><span class="line">    		    </span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	          <span class="comment">// 这里则是同步的</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">                <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>); <span class="comment">// 1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>count:&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.btnAction&#125;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">								<span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>绑定点击事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Count</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>笔试题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Count</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  	</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;) <span class="comment">// this.state.count是0</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// 0</span></span><br><span class="line">	</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;) <span class="comment">// 这里的 this.state.count 还是0</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;) <span class="comment">// 这里的 this.state.count 是 1</span></span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// 2</span></span><br><span class="line">      </span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;)</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// 3</span></span><br><span class="line">	</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="如果面向组件跨层通信"><a href="#如果面向组件跨层通信" class="headerlink" title="如果面向组件跨层通信"></a>如果面向组件跨层通信</h2><img  
                     lazyload
                     alt="image"
                     data-src="/Users/xiongchao/Library/Application Support/typora-user-images/image-20230422222202723.png"
                      alt="image-20230422222202723" style="zoom:38%;" 
                >



<p><code>Context</code> 存储的变量难以追溯数据源以及确认变动点。当组件依赖<code>Context</code>时，会提升组件耦合度，不利于组件的复用与测试。</p>
<h2 id="Virtual-DOM的工作原理是什么"><a href="#Virtual-DOM的工作原理是什么" class="headerlink" title="Virtual DOM的工作原理是什么"></a>Virtual DOM的工作原理是什么</h2><p>Fackbook的初衷</p>
<ul>
<li>简化前端开发</li>
<li>防止XSS。</li>
</ul>
<p>&#x3D;&#x3D;通过虚拟DOM来规避风险&#x3D;&#x3D;。因为直接操作DOM会带来XSS的风险，也可能因为技术水平的限制，带来性能的问题。（如果你心爱的东西不喜欢有人去触碰，最好的办法是把它封起来，与使用者相隔离，因此有了我们今天看到的虚拟DOM）</p>
<ol>
<li><code>JSX</code> 所描述的结构，会转译成 <code>React.createElement</code> 函数：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX描述</span></span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span>/&gt;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Babel转义后</span></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;input&#x27;</span>, &#123; <span class="attr">type</span>: <span class="string">&#x27;button &#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>React 会持有一颗虚拟 DOM 树。在状态变更后，会触发虚拟 DOM 树的修改，再以此为基础修改真实 DOM</li>
</ol>
<p><code>React.createElement</code> 返回的结果应是一个 <code>JavaScript</code> <code>obiect</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">		<span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">children</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>diff 函数</strong>，去计算状态变更前后的虚拟 DOM 树差异；</p>
<p><strong>渲染函数</strong>，渲染整个虚拟 DOM 树或者处理差异点；</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>性能优越</li>
<li>规避XSS</li>
<li>可跨平台（RN，小程序）</li>
</ul>
<h4 id="边界："><a href="#边界：" class="headerlink" title="边界："></a>边界：</h4><p>大量的直接操作 DOM 容易引起网页性能下降。这时 React 基于虚拟 DOM 的 diff 处理与批处理操作，可降低 DOM 的操作范围与频次，提升页面性能</p>
<p><strong>什么时候虚拟DOM慢呢？</strong></p>
<p>首次渲染或者微量操作的时候，虚拟DOM就会比真实的DOM更慢。</p>
<p><strong>虚拟 DOM 一定可以规避 XSS 吗?</strong></p>
<p>虚拟 DOM 内部确保字符转义，确实可做到这点，但 React 存在风险，因为 React 留有 <code>dangerouslySetlnnerHTML</code> API 绕过转义。</p>
<p><strong>跨平台的成本更低</strong></p>
<p>在 React Native 后，前端社区从虚拟 DOM 中体会到跨平台的无限前景，所以在后续发展中，都借鉴虚拟 DOM。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>内存占用较高</li>
<li>无法进行极致优化</li>
</ul>
<p>因为当前网页的虚拟DOM包含真实DOM的完整信息，而且由于是Object，内存占用肯定会有所上升。</p>
<p>虽然虚拟DOM足以应对绝大部分应用的性能要求，但在一些性能要求高的应用中无法进行针对性的优化。</p>
<h2 id="与其他框架相比，React的diff有何不同"><a href="#与其他框架相比，React的diff有何不同" class="headerlink" title="与其他框架相比，React的diff有何不同"></a>与其他框架相比，React的diff有何不同</h2><p>diff算法是指，生成更新补丁的方式。主要应用于虚拟DOM树变化，更新真实DOM。</p>
<ol>
<li>真实的 DOM 首先会映射为虚拟 DOM；</li>
<li>当虚拟 DOM 变化后，会根据差异计算生成 patch。patch 是结构化的数据，包含增加、更新、移除等；</li>
<li>根据 patch 去更新真实的DOM，反馈到用户界面上</li>
</ol>
<p>![image-20230423111726301](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230423111726301.png)</p>
<p>diff算法：</p>
<ul>
<li>更新时机——触发更新、进行差异对比的时机。（setState，hooks调用之后，此时树的节点发生变化，开始比对）</li>
<li>遍历算法——深度优先遍历</li>
<li>优化策略</li>
</ul>
<blockquote>
<p>深度优先遍历——从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止然后回溯前一个节点，进行右子树节点遍历，直到遍历完所有可达节点</p>
</blockquote>
<p>虽然<code>深度优先遍历</code>保证了组件的生命周期时序不错乱，但传统的 diff 算法带来一个严重的性能瓶颈，复杂程度为 O(n3)，其中 n 表示树的节点总数。</p>
<p>React 用了一个非常经典的手法将复杂度降低为 O(n)就是分治，即通过<code>“分而治之”</code>这一巧妙的思想分解问题。</p>
<p>将单一节点比对，转化为了三种类型节点比对。React从&#x3D;&#x3D;树、组件、元素&#x3D;&#x3D;三个方面进行了优化。</p>
<h5 id="策略一：忽略节点跨层级操作场景，提升比对效率；"><a href="#策略一：忽略节点跨层级操作场景，提升比对效率；" class="headerlink" title="策略一：忽略节点跨层级操作场景，提升比对效率；"></a>策略一：忽略节点跨层级操作场景，提升比对效率；</h5><p>需进行&#x3D;&#x3D;树比对&#x3D;&#x3D;，即对树进行分层比较两棵树&#x3D;&#x3D;只对同一层次节点进行比较&#x3D;&#x3D;，如发现节点已不存在则该节点及其子节点会被完全删除，不会用于进一步比较提升了比对效率</p>
<h5 id="策略二：如果组件的-class-一致，则默认为相似的树结构，否则默认为不同的树结构"><a href="#策略二：如果组件的-class-一致，则默认为相似的树结构，否则默认为不同的树结构" class="headerlink" title="策略二：如果组件的 class 一致，则默认为相似的树结构，否则默认为不同的树结构"></a>策略二：如果组件的 class 一致，则默认为相似的树结构，否则默认为不同的树结构</h5><p>如果组件是同一类型则进行树比对，如果不是则直接放入补丁中。</p>
<p>只要父组件类型不同，就会被重新渲染，这就是<code>shouldComponentUpdate</code>&#x2F;<code>PureComponent</code>&#x2F;<code>React.memo</code>可以提高性能的原因</p>
<h5 id="策略三：同一层级子节点，可通过标记-key-的方式进行列表对比。"><a href="#策略三：同一层级子节点，可通过标记-key-的方式进行列表对比。" class="headerlink" title="策略三：同一层级子节点，可通过标记 key 的方式进行列表对比。"></a>策略三：同一层级子节点，可通过标记 key 的方式进行列表对比。</h5><p>元素比对主要发生在同层级中，通过标记节点操作生成补丁。</p>
<p>节点操作包含了插入、移动、删除等。</p>
<p>其中节点排序，同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要的作用。</p>
<p>通过标记 key 的方式，React 可以直接移动 DOM 节点，降低内耗</p>
<h4 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h4><p>react16引入了fiber机制，进行了优化。</p>
<p>1、Fiber 机制下节点与树分别采用 FiberNode 与 FiberTree 进行重构</p>
<ul>
<li>FiberNode使用了双链表的结构，可以直接找到兄弟节点和子节点，使得整个更行过程可以随时暂停、恢复。</li>
<li>FiberTree是通过FiberNode构成的树。</li>
</ul>
<p>2、Fiber 机制下整个更新过程由 current 与 worklnProgress 两株树，双缓冲完成</p>
<ul>
<li>当worklnProgress更新完成后，通过修改current的相关指针指向的节点，直接抛弃老树。虽然非常简单粗暴，却非常合理。</li>
</ul>
<h4 id="其他框架"><a href="#其他框架" class="headerlink" title="其他框架"></a>其他框架</h4><p>PReact  diff 算法相较于React，整体设计思路相似。</p>
<p>最层次的元素采用真实DOM对比操作，并没有采用Fiber的设计。</p>
<p>Vue 2.0 使用了 <strong>snabbdom</strong>，整体思路与 React 相同。</p>
<p>但在元素对比时，如果新旧两元素是同一元素，且没有设置 key 时，snabbdom 在 diff 子元素中会一次性对比&#x3D;&#x3D;旧节点&#x3D;&#x3D;、&#x3D;&#x3D;新节点&#x3D;&#x3D;及它们的&#x3D;&#x3D;首尾元素&#x3D;&#x3D;四个节点，以及&#x3D;&#x3D;验证列表&#x3D;&#x3D;是否有变化。</p>
<p>Vue3.0 整体变化不大。</p>
<p>最后</p>
<p>React拥有完整的diff算法策略，且拥有随时中断更新的时间切片能力。在大批量更新的极端情况下，拥有更友好的交互体验。</p>
<p>PReact可以在一些对性能要求不高，仅需要渲染的简单场景下使用。</p>
<p>Vue的diff策略整体与React对齐，虽然缺乏时间切片能力，但并不意味这Vue的性能更差，因为在Vue3初期引入过，后来因为收益不高移除掉了。除了高帧率动画、其他场景几乎都可以防抖节流去提高乡音性能。</p>
<h5 id="如何根据React-diff算法原理优化代码？"><a href="#如何根据React-diff算法原理优化代码？" class="headerlink" title="如何根据React diff算法原理优化代码？"></a>如何根据React diff算法原理优化代码？</h5><ul>
<li>根据 diff 算法的设计原则，应尽量避免跨层级节点移动，</li>
<li>通过设置唯一 key 进行优化，尽量减少组件层级深度，因为过深的层级会加深遍历深度，带来性能问题</li>
<li>设置 shouldComponentUpdate 或者 React.pureComponet 减少 diff 次数</li>
</ul>
<h2 id="React的渲染异常会造成什么后果"><a href="#React的渲染异常会造成什么后果" class="headerlink" title="React的渲染异常会造成什么后果"></a>React的渲染异常会造成什么后果</h2><p>“错误边界” 相关内容：如果渲染异常，在没有任何降级保护措施的情况下，页面会直接显示白屏。</p>
<p>通用方案：<code>getDerivedStateFromError</code>&#x2F;<code>componentDidCatch</code></p>
<p><code>getDerviedStateFromError</code>和<code>componentDidCatch</code>的区别是前者展示降级UI，后者记录具体的错误信息，它只能用于class组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>=&#123;</span><br><span class="line">      <span class="attr">hasError</span>:<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  staic <span class="title function_">getDerivedStateFromError</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>:<span class="literal">true</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">err,info</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err,info)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Oops,err<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;错误边界无法捕获自身的错误，也无法捕获事件处理、异步代码(setTimeout、requestAnimationFrame)、服务端渲染的错误&#x3D;&#x3D;</p>
<h4 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h4><p>在渲染层，render 中 return 后的 JSX，都是在进行数据的拼装与转换</p>
<ul>
<li>如果在拼装的过程中出现错误，那直接会导致编译的失败</li>
<li>但如果在转换的过程中出现错误，就很不容易被发现</li>
</ul>
<p>前端数据基本上都是通过后端业务接口获取，那么是数据否可靠，就成为了一个至关重要的问题。</p>
<p>这个问题被称为<code>null-safety</code>，也就是<code>空安全</code>，目前对于这个问题比较成熟的解决方案是使用<code>idx</code></p>
<p><code>idx</code> 在使用时需要配置 <code>Babel</code> 插件，再引入<code>idx</code> 库。然后通过 <code>idx</code> 函数包裹需要使用的 <code>object</code>，再在回调函数中取需要的值。</p>
<p>idx的代码既不优雅，也不简洁，还需要引入babel插件，所以使用者寥寥无几。</p>
<h5 id="优雅的解决方案："><a href="#优雅的解决方案：" class="headerlink" title="优雅的解决方案："></a>优雅的解决方案：</h5><p>Es202，可选链操作符</p>
<h4 id="兜底"><a href="#兜底" class="headerlink" title="兜底"></a>兜底</h4><p>应该限制崩溃的层级。错误边界加到哪里，崩溃就止步于哪里，其他组件还可正常使用；</p>
<p>所以只需给关键的 UI 组件添加错误边界，那就可应用&#x3D;&#x3D;高阶组件（或者自定义hooks）&#x3D;&#x3D;</p>
<p>需保障方案在项目中的覆盖量，统计兜底页面成功兜底次数，最后兜底页面展示时能及时完成线上报警。</p>
<p>每个公司至少会接入统计工具，如百度统计、Google 统计完成业务分析，只需在代码中，添加一行统计代码</p>
<h2 id="如何提升React代码的可维护性"><a href="#如何提升React代码的可维护性" class="headerlink" title="如何提升React代码的可维护性"></a>如何提升React代码的可维护性</h2><h3 id="1、预防与兜底"><a href="#1、预防与兜底" class="headerlink" title="1、预防与兜底"></a>1、预防与兜底</h3><p>预防：从上线前开始可对代码做哪些措施防止出现线上问题<br>兜底：上线后又可以做哪些方案加快线上故障的定位速度</p>
<h4 id="预防-1"><a href="#预防-1" class="headerlink" title="预防"></a>预防</h4><p>通过使用人工或者工具审查的方式去实现。</p>
<p><strong>人工审查</strong>代码的方式，标准称谓是 <strong>Code Review</strong>基于React 写法的易错点，团队内部会总结出一些实践准则。</p>
<p><strong>工具审查</strong>的方式，标准称谓是<strong>静态代码检查工具</strong>（<code>ESLint</code>）</p>
<h4 id="兜底-1"><a href="#兜底-1" class="headerlink" title="兜底"></a>兜底</h4><p>在线环境的代码通常是经过 <code>UglifyJS</code> &#x2F; <code>terser</code>混淆并压缩的，所以直接看报错信息不能得知对应的源码是什么样的，不利于排查问题。</p>
<p>最理想的情况莫过于改造编译流水线，在发布过程中上传 sourcemap 到报错收集平台。</p>
<p>在 Webpack 中添加 sourcemap 相关插件就可在编译过程，直接上传 sourcemap 到 Sentry 的报错平台</p>
<img  
                     lazyload
                     alt="image"
                     data-src="/Users/xiongchao/Library/Application Support/typora-user-images/image-20230423171320325.png"
                      alt="image-20230423171320325" style="zoom:33%;" 
                >

<p>在使用 Sentry 捕获报错时，就能够直接查看对应的源码了：</p>
<img  
                     lazyload
                     alt="image"
                     data-src="/Users/xiongchao/Library/Application Support/typora-user-images/image-20230423171409595.png"
                      alt="image-20230423171409595" style="zoom:33%;" 
                >

<p>使用 Mozilla 开源的工具 sourcemap，直接恢复对应的源代码信息。</p>
<h3 id="2、可改变性"><a href="#2、可改变性" class="headerlink" title="2、可改变性"></a>2、可改变性</h3><p>从代码层面来讲，可变性代表了<strong>代码的可拓展能力</strong>。</p>
<p>两个思路提升代码的可拓展性：</p>
<ul>
<li>从组件的角度出发，通过分离容器组件与展示组件的方式分离模块。其中推荐了 Storybook 来沉淀展示组件。</li>
<li>框架状态管理框架中有相对成熟的设计模式，比如 Redux 中的action、reducer 等，它的边界很清楚很容易明白业务逻辑该如何拆解、如何放入模块中。</li>
</ul>
<h3 id="3、稳定性"><a href="#3、稳定性" class="headerlink" title="3、稳定性"></a>3、稳定性</h3><p>在前端项目中，无论是单元测试还是集成测试，整体覆盖比例都很低。常常通过人工测试“点点点”的方式保证稳定性。</p>
<p>前端测试并不好写。针对 UI 层不好写：</p>
<p>国内业务迭代模式都非常快，快到 UI层难以有稳定的测试代码，所以通常不会花太多时间去写组件的测试。基于实际情况，有条件写测试的话，也是尽量给<strong>核心业务写测试</strong>，更利于整体项目的稳定性。</p>
<h3 id="4、依从性"><a href="#4、依从性" class="headerlink" title="4、依从性"></a>4、依从性</h3><p>遵循约定，提升代码可读性、减少人为因素，加强工具干预：</p>
<ul>
<li>针对样式的Stylelint</li>
<li>针对JS的ESLint</li>
<li>针对代码提交的commitlint</li>
<li>针对编辑器风格的Editorconfig</li>
<li>针对代码风格的Prettier</li>
</ul>
<h2 id="React-Hooks使用限制有哪些？"><a href="#React-Hooks使用限制有哪些？" class="headerlink" title="React Hooks使用限制有哪些？"></a>React Hooks使用限制有哪些？</h2><h4 id="为什么使用Hooks"><a href="#为什么使用Hooks" class="headerlink" title="为什么使用Hooks"></a>为什么使用Hooks</h4><h5 id="1、组件之间难以复用状态逻辑"><a href="#1、组件之间难以复用状态逻辑" class="headerlink" title="1、组件之间难以复用状态逻辑"></a>1、组件之间难以复用状态逻辑</h5><p>如果涉及场景更复杂，多级组件需共享状态，就需使用 Redux 或 Mobx 来解决了。</p>
<p>既然是每个人都遇到的问题，最好考虑从 React 层提供 API 来解决。（高阶组件）</p>
<h5 id="2、复杂的组件变得难以理解"><a href="#2、复杂的组件变得难以理解" class="headerlink" title="2、复杂的组件变得难以理解"></a>2、复杂的组件变得难以理解</h5><p>主要指出生命周期函数没能提供最佳的代码编程实践范式</p>
<p>如 <code>componentDidMount</code>，在这里设置页面标题、拉取用户信息、拉取按钮权限信息。<code>ComponentDidMount</code> 函数内部逻辑随意堆砌，内容杂乱，缺乏专注性，往往还会对上下文产生依赖。</p>
<p>在componentDidMount中使用事件注册、订阅消息等，都需要在componentWillUnmount中去取消它。订阅与取消订阅并没有直接关联在一起，而是通过生命周期函数去使用这非常的反模式，也就导致组件难以分解，且到处都是状态逻辑。</p>
<h5 id="3、人和机器都容易混淆类"><a href="#3、人和机器都容易混淆类" class="headerlink" title="3、人和机器都容易混淆类"></a>3、人和机器都容易混淆类</h5><ul>
<li><code>this</code> 首当其冲，值捕获的问题。</li>
<li>还有一个与 <code>this</code> 相关的问题，就是用 <code>bind</code> 函数包一下来绑定事件。虽然现在通过了类属性方案，也可使用Babel 插件提前开发，但整个提案仍是草案阶段。</li>
<li>在类中难以做编译优化，<code>React</code> 团队一直在做前端编译层的优化工作，如常数折叠、内联展开及死码删除。</li>
</ul>
<h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><ul>
<li>不要在 React 的循环、条件或嵌套函数中调用 Hook。</li>
<li>在React函数组件中调用Hook</li>
</ul>
<h4 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h4><p>因 React 的内在设计原理，所以不可能绕过限制规则，但可在代码中禁止错误的使用方式。</p>
<p>工程化的东西最终应落地到工具上，其实只需在 ESLint 中引入 eslint-plugin-react-hooks 完成自动化检查就可以了在处理代码编写方式问题时，应优先想到从 Lint 工具入手</p>
<h2 id="useEffect-与-useLayoutEffect的区别"><a href="#useEffect-与-useLayoutEffect的区别" class="headerlink" title="useEffect 与 useLayoutEffect的区别"></a>useEffect 与 useLayoutEffect的区别</h2><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><h5 id="使用方式上："><a href="#使用方式上：" class="headerlink" title="使用方式上："></a>使用方式上：</h5><p>useLayoutEffect 的函数签名与 useEffect 相同，使用方式完全一致，甚至在一定程度上可以相互替换。</p>
<h5 id="运行效果："><a href="#运行效果：" class="headerlink" title="运行效果："></a>运行效果：</h5><p>useEffect 与 useLayoutEffect 两者都是用于处理副作用。这些副作用包括改变 DOM、设置订阅、操作定时器等</p>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><h5 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h5><p>大多数场景下可直接使用 useEffect，但代码引起页面闪烁，就推荐使用useLayoutEffect 处理</p>
<p>如有直接操作 DOM 样式或引起 DOM 样式更新的场景，更推荐使用 useLayoutEffect</p>
<h5 id="独有能力："><a href="#独有能力：" class="headerlink" title="独有能力："></a>独有能力：</h5><ul>
<li>Effect：异步处理副作用；</li>
<li>LayoutEffect：同步处理副作用；</li>
</ul>
<h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><p>标记为 HookLayout 的 effect 会在所有的 DOM 变更之后同步调用，所以可以使用它来读取 DOM 布局并同步触发重渲染。</p>
<p>计算量较大的耗时任务必然会造成阻塞，所以就需根据实际情况酌情考虑。如果非必要情况下，使用标准的 useEffect 可以避免阻塞</p>
<h3 id="useEffect-依赖为空数组与-componentDidMount-区别"><a href="#useEffect-依赖为空数组与-componentDidMount-区别" class="headerlink" title="useEffect 依赖为空数组与 componentDidMount 区别"></a>useEffect 依赖为空数组与 componentDidMount 区别</h3><p>在 <code>render</code> 执行之后，<code>componentDidMount</code> 会执行，如果在这个生命周期中再一次 <code>setState</code> ，会导致再次 <code>render</code> ，返回了新的值，浏览器只会渲染第二次 <code>render</code> 返回的值，这样可以避免闪屏。</p>
<p>但是 <code>useEffect</code> 是在真实的 DOM 渲染之后才会去执行，这会造成两次 <code>render</code> ，有可能会闪屏。</p>
<p>实际上 <code>useLayoutEffect</code> 会更接近 <code>componentDidMount</code> 的表现，它们都同步执行且会阻碍真实的 DOM 渲染的。</p>

            </div>

            
                <div class="post-copyright-info">
                    
<div class="article-copyright-info-container">
    <ul class="copyright-info-content">
        <li class="post-title">
            <span class="type">Post title</span>: <span class="content">React 知识点总结</span>
        </li>
        <li class="post-author">
            <span class="type">Post author</span>: <span class="content">Chao</span>
        </li>
        <li class="post-time">
            <span class="type">Create time</span>: <span class="content">2022-11-11 13:15:00</span>
        </li>
        <li class="post-link">
            <span class="type">Post link</span>: <span class="content">2022/11/11/React知识点总结/</span>
        </li>
        <li class="post-license">
            <span class="type">Copyright notice</span>: <span class="content">All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.</span>
        </li>
    </ul>
    <div class="copy-copyright-info flex-center tooltip" data-content="Copy copyright info" data-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/React/">#React</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2022/10/29/webpack%E6%80%BB%E7%BB%93/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Webpack 总结</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
                <div class="comment-container">
                    
<div class="comments-container">
    <div id="comments-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments"></i>&nbsp;Comments
    </div>
    
        
            

    <div class="waline-comment-container">
        <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@waline/client@v2/dist/waline.css"/>
        <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@waline/client@v2/dist/waline-meta.css"/>
        <script data-pjax src="//cdn.jsdelivr.net/npm/@waline/client@v2/dist/waline.js"></script>
        <div id="waline-comment"></div>
        <script data-pjax>
          function loadWaline() {
            Waline.init({
              el: '#waline-comment',
              serverURL: 'https://bear-blog-comment-8yis8zzwo-xiongcao.vercel.app',
              lang: 'en' || 'zh-CN',
              comment: '.post-comments-count',
              reaction: 'true' === 'true'
            })
          }

          if ('true' === 'true') {
            setTimeout(() => {
              loadWaline()
            }, 1000)
          } else {
            window.addEventListener('DOMContentLoaded', loadWaline)
          }
        </script>
    </div>



        
    
</div>

                </div>
            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFReact"><span class="nav-number">1.</span> <span class="nav-text">什么是React</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJSX"><span class="nav-number">2.</span> <span class="nav-text">什么是JSX</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#React%E6%9C%AC%E8%BA%AB%E5%B9%B6%E4%B8%8D%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8JSX%EF%BC%9A"><span class="nav-number">2.0.0.1.</span> <span class="nav-text">React本身并不强制使用JSX：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF"><span class="nav-number">2.0.1.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.0.2.</span> <span class="nav-text">模板字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.0.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%9D%91"><span class="nav-number">3.</span> <span class="nav-text">如何避免生命周期的坑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E6%97%B6%E6%9C%BA%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="nav-number">3.0.1.</span> <span class="nav-text">建立时机与操作的对应关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BE%E5%8C%BA%E4%B8%AD%E5%8E%BB%E9%99%A4-constructor-%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">3.0.2.</span> <span class="nav-text">社区中去除 constructor 的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="nav-number">3.0.3.</span> <span class="nav-text">挂载阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#getDerivedStateFromPorps"><span class="nav-number">3.0.3.1.</span> <span class="nav-text">getDerivedStateFromPorps</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UNSAFE-componentWillMount"><span class="nav-number">3.0.3.2.</span> <span class="nav-text">UNSAFE_componentWillMount</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#render"><span class="nav-number">3.0.3.3.</span> <span class="nav-text">render</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5"><span class="nav-number">3.0.4.</span> <span class="nav-text">更新阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%B8%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="nav-number">3.0.5.</span> <span class="nav-text">卸载阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%8C%E8%B4%A3%EF%BC%9A"><span class="nav-number">3.0.6.</span> <span class="nav-text">职责：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%EF%BC%9A"><span class="nav-number">3.0.6.1.</span> <span class="nav-text">函数组件：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#React-Component%EF%BC%9A"><span class="nav-number">3.0.6.2.</span> <span class="nav-text">React.Component：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#React-PureComponent%EF%BC%9A"><span class="nav-number">3.0.6.3.</span> <span class="nav-text">React.PureComponent：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C%EF%BC%9A"><span class="nav-number">3.0.7.</span> <span class="nav-text">错误边界：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-%E7%9A%84%E8%AF%B7%E6%B1%82%E5%BA%94%E8%AF%A5%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">React 的请求应该放在哪里，为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">类组件和函数组件的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="nav-number">5.0.1.</span> <span class="nav-text">相同点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="nav-number">5.0.2.</span> <span class="nav-text">不同点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1React%E7%BB%84%E4%BB%B6"><span class="nav-number">6.</span> <span class="nav-text">如何设计React组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6"><span class="nav-number">6.0.1.</span> <span class="nav-text">展示组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%81%B5%E5%B7%A7%E7%BB%84%E4%BB%B6"><span class="nav-number">6.1.</span> <span class="nav-text">灵巧组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6"><span class="nav-number">6.1.1.</span> <span class="nav-text">容器组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%EF%BC%9A"><span class="nav-number">6.1.2.</span> <span class="nav-text">高阶组件：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E9%99%B7%EF%BC%9A"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">缺陷：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setState-%E6%98%AF%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0"><span class="nav-number">7.</span> <span class="nav-text">setState 是同步更新还是异步更新</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%EF%BC%9A"><span class="nav-number">7.0.1.</span> <span class="nav-text">合成事件：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#React-17-%E4%B9%8B%E5%89%8D%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%9A"><span class="nav-number">7.0.1.1.</span> <span class="nav-text">React 17 之前的事件冒泡流程图：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#React-17-%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%9A"><span class="nav-number">7.0.1.2.</span> <span class="nav-text">React 17 之后的事件冒泡流程图：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setState-%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">7.0.2.</span> <span class="nav-text">setState 之后发生了什么</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E8%B7%A8%E5%B1%82%E9%80%9A%E4%BF%A1"><span class="nav-number">8.</span> <span class="nav-text">如果面向组件跨层通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Virtual-DOM%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">9.</span> <span class="nav-text">Virtual DOM的工作原理是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF"><span class="nav-number">9.1.</span> <span class="nav-text">优势</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%EF%BC%9A"><span class="nav-number">9.1.1.</span> <span class="nav-text">边界：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">9.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6%E7%9B%B8%E6%AF%94%EF%BC%8CReact%E7%9A%84diff%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="nav-number">10.</span> <span class="nav-text">与其他框架相比，React的diff有何不同</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E4%B8%80%EF%BC%9A%E5%BF%BD%E7%95%A5%E8%8A%82%E7%82%B9%E8%B7%A8%E5%B1%82%E7%BA%A7%E6%93%8D%E4%BD%9C%E5%9C%BA%E6%99%AF%EF%BC%8C%E6%8F%90%E5%8D%87%E6%AF%94%E5%AF%B9%E6%95%88%E7%8E%87%EF%BC%9B"><span class="nav-number">10.0.0.1.</span> <span class="nav-text">策略一：忽略节点跨层级操作场景，提升比对效率；</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E4%BA%8C%EF%BC%9A%E5%A6%82%E6%9E%9C%E7%BB%84%E4%BB%B6%E7%9A%84-class-%E4%B8%80%E8%87%B4%EF%BC%8C%E5%88%99%E9%BB%98%E8%AE%A4%E4%B8%BA%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91%E7%BB%93%E6%9E%84%EF%BC%8C%E5%90%A6%E5%88%99%E9%BB%98%E8%AE%A4%E4%B8%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A0%91%E7%BB%93%E6%9E%84"><span class="nav-number">10.0.0.2.</span> <span class="nav-text">策略二：如果组件的 class 一致，则默认为相似的树结构，否则默认为不同的树结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E4%B8%89%EF%BC%9A%E5%90%8C%E4%B8%80%E5%B1%82%E7%BA%A7%E5%AD%90%E8%8A%82%E7%82%B9%EF%BC%8C%E5%8F%AF%E9%80%9A%E8%BF%87%E6%A0%87%E8%AE%B0-key-%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%88%97%E8%A1%A8%E5%AF%B9%E6%AF%94%E3%80%82"><span class="nav-number">10.0.0.3.</span> <span class="nav-text">策略三：同一层级子节点，可通过标记 key 的方式进行列表对比。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fiber"><span class="nav-number">10.0.1.</span> <span class="nav-text">Fiber</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6"><span class="nav-number">10.0.2.</span> <span class="nav-text">其他框架</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AEReact-diff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="nav-number">10.0.2.1.</span> <span class="nav-text">如何根据React diff算法原理优化代码？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React%E7%9A%84%E6%B8%B2%E6%9F%93%E5%BC%82%E5%B8%B8%E4%BC%9A%E9%80%A0%E6%88%90%E4%BB%80%E4%B9%88%E5%90%8E%E6%9E%9C"><span class="nav-number">11.</span> <span class="nav-text">React的渲染异常会造成什么后果</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E9%98%B2"><span class="nav-number">11.0.1.</span> <span class="nav-text">预防</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E9%9B%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="nav-number">11.0.1.1.</span> <span class="nav-text">优雅的解决方案：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%9C%E5%BA%95"><span class="nav-number">11.0.2.</span> <span class="nav-text">兜底</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87React%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7"><span class="nav-number">12.</span> <span class="nav-text">如何提升React代码的可维护性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E9%A2%84%E9%98%B2%E4%B8%8E%E5%85%9C%E5%BA%95"><span class="nav-number">12.1.</span> <span class="nav-text">1、预防与兜底</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E9%98%B2-1"><span class="nav-number">12.1.1.</span> <span class="nav-text">预防</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%9C%E5%BA%95-1"><span class="nav-number">12.1.2.</span> <span class="nav-text">兜底</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%8F%AF%E6%94%B9%E5%8F%98%E6%80%A7"><span class="nav-number">12.2.</span> <span class="nav-text">2、可改变性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="nav-number">12.3.</span> <span class="nav-text">3、稳定性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E4%BE%9D%E4%BB%8E%E6%80%A7"><span class="nav-number">12.4.</span> <span class="nav-text">4、依从性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-Hooks%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">React Hooks使用限制有哪些？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Hooks"><span class="nav-number">13.0.1.</span> <span class="nav-text">为什么使用Hooks</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E9%9A%BE%E4%BB%A5%E5%A4%8D%E7%94%A8%E7%8A%B6%E6%80%81%E9%80%BB%E8%BE%91"><span class="nav-number">13.0.1.1.</span> <span class="nav-text">1、组件之间难以复用状态逻辑</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E5%A4%8D%E6%9D%82%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8F%98%E5%BE%97%E9%9A%BE%E4%BB%A5%E7%90%86%E8%A7%A3"><span class="nav-number">13.0.1.2.</span> <span class="nav-text">2、复杂的组件变得难以理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E4%BA%BA%E5%92%8C%E6%9C%BA%E5%99%A8%E9%83%BD%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%B1%BB"><span class="nav-number">13.0.1.3.</span> <span class="nav-text">3、人和机器都容易混淆类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="nav-number">13.0.2.</span> <span class="nav-text">方案：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD"><span class="nav-number">13.0.3.</span> <span class="nav-text">防范措施</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#useEffect-%E4%B8%8E-useLayoutEffect%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">useEffect 与 useLayoutEffect的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="nav-number">14.0.1.</span> <span class="nav-text">相同点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E4%B8%8A%EF%BC%9A"><span class="nav-number">14.0.1.1.</span> <span class="nav-text">使用方式上：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C%EF%BC%9A"><span class="nav-number">14.0.1.2.</span> <span class="nav-text">运行效果：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="nav-number">14.0.2.</span> <span class="nav-text">不同点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="nav-number">14.0.2.1.</span> <span class="nav-text">使用场景：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8B%AC%E6%9C%89%E8%83%BD%E5%8A%9B%EF%BC%9A"><span class="nav-number">14.0.2.2.</span> <span class="nav-text">独有能力：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="nav-number">14.0.3.</span> <span class="nav-text">设计原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#useEffect-%E4%BE%9D%E8%B5%96%E4%B8%BA%E7%A9%BA%E6%95%B0%E7%BB%84%E4%B8%8E-componentDidMount-%E5%8C%BA%E5%88%AB"><span class="nav-number">14.1.</span> <span class="nav-text">useEffect 依赖为空数组与 componentDidMount 区别</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2017</span> -
            
            2023
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">Chao</a>
            
        </div>
        
            <script async data-pjax
                    src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                
                
                    Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
            <div class="icp-info info-item">
                <a target="_blank" rel="nofollow"
                   href="https://beian.miit.gov.cn"
                >
                    鄂ICP证000000001号
                </a>
            </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        $tools-item-width = 2.2rem
$tools-item-font-size = 1.1rem
$tools-item-border-radius = 0.1rem


.side-tools-container {
  position relative

  .tools-item {
    width $tools-item-width
    height $tools-item-width
    margin-bottom 0.2rem
    color var(--text-color-3)
    font-size $tools-item-font-size
    background var(--background-color-1)
    border-right none
    border-radius $tools-item-border-radius
    box-shadow 0.1rem 0.1rem 0.2rem var(--shadow-color)
    cursor pointer

    i {
      color var(--text-color-3)
    }

    &:hover {
      color var(--background-color-1)
      background var(--primary-color)
      box-shadow 0.2rem 0.2rem 0.4rem var(--shadow-color)

      i {
        color var(--background-color-1)
      }
    }

    +keep-tablet() {
      width $tools-item-width * 0.9
      height $tools-item-width * 0.9
      margin-bottom 0.2rem
      font-size $tools-item-font-size * 0.9
    }

    &.rss {

      a {
        width 100%
        height 100%
        border-radius $tools-item-border-radius

        &:hover {
          color var(--background-color-1)
          background var(--primary-color)
          box-shadow 0.2rem 0.2rem 0.4rem var(--shadow-color)
        }
      }
    }
  }


  .side-tools-list {
    transform translateX(100%)
    opacity 0
    transition-t("transform, opacity", "0, 0", "0.2, 0.2", "linear, linear")

    &.show {
      transform translateX(0)
      opacity 1
    }
  }


  .exposed-tools-list {

    if (hexo-config('style.scroll.percent') == true) {
      .tool-scroll-to-top {
        display none

        &.show {
          display flex
        }

        &:hover {

          .percent {
            display none
          }

          .arrow-up {
            display flex
          }
        }

        .arrow-up {
          display none
        }

        .percent {
          display flex
          font-size 1rem
        }
      }
    }
  }
}

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        $icon-size = 1.2rem
$search-header-height = 3rem

.search-pop-overlay {
  position fixed
  top 0
  left 0
  z-index $z-index-8
  display flex
  width 100%
  height 100%
  background rgba(0, 0, 0, 0)
  visibility hidden
  transition-t("visibility, background", "0, 0", "0.3, 0.3", "ease, ease")

  &.active {
    background rgba(0, 0, 0, 0.35)
    visibility visible

    .search-popup {
      transform scale(1)
    }
  }


  .search-popup {
    z-index $z-index-6
    width 70%
    height 80%
    margin auto
    background var(--background-color-1)
    border-radius 0.4rem
    transform scale(0)
    transition-t("transform", "0", "0.3", "ease")

    +keep-tablet() {
      width 80%
    }

    +keep-mobile() {
      width 90%
    }

    .search-header {
      display flex
      align-items center
      height $search-header-height
      padding 0 1rem
      background var(--text-color-6)
      border-top-left-radius 0.2rem
      border-top-right-radius 0.2rem

      .search-input-field-pre {
        margin-right 0.2rem
        color var(--text-color-3)
        font-size 1.3rem
        cursor pointer
      }

      .search-input-container {
        flex-grow 1
        padding 0.2rem

        .search-input {
          width 100%
          color var(--text-color-3)
          font-size 1.2rem
          background transparent
          border 0
          outline 0

          &::-webkit-search-cancel-button {
            display none
          }

          &::-webkit-input-placeholder {
            color var(--text-color-4)
            font-size 1rem
          }
        }
      }


      .close-popup-btn {
        color var(--text-color-3)
        font-size $icon-size
        cursor pointer

        &:hover {
          color var(--text-color-1)
        }
      }
    }


    #search-result {
      position relative
      display flex
      box-sizing border-box
      height 'calc(100% - %s)' % $search-header-height
      padding 0.3rem 1.5rem
      overflow auto

      .search-result-list {
        width 100%
        height 100%
        font-size 1rem

        li {
          box-sizing border-box
          margin 0.8rem 0
          padding 0.8rem 0
          border-bottom 0.1rem dashed var(--border-color)

          &:last-child {
            border-bottom none
          }


          .search-result-title {
            position relative
            display flex
            align-items center
            margin-bottom 0.8rem
            padding-left 1rem
            font-weight bold

            &::after {
              position absolute
              top 50%
              left 0
              width 0.4rem
              height 0.4rem
              background var(--text-color-3)
              border-radius 50%
              transform translateY(-50%)
              content ''
            }
          }


          .search-result {
            margin 0
            padding-left 1rem
            line-height 2rem
            word-wrap break-word
          }

          a {
            &:hover {
              color var(--text-color-3)
            }
          }

          .search-keyword {
            color var(--primary-color)
            font-weight bold
            border-bottom 0.1rem dashed var(--primary-color)
          }
        }
      }


      #no-result {
        margin auto
        color var(--text-color-4)
      }
    }
  }
}


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>





    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-block.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts pjax">
    
        
<script src="/js/post-helper.js"></script>

        
            
<script src="/js/libs/anime.min.js"></script>

        
        
            
<script src="/js/toc.js"></script>

        
    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
