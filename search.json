[{"title":"Ajax跨域的几种解决方案","url":"/2018/08/14/Ajax%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":" \n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个前后端分离越来越流行的时代，跨域请求对于我们来说已经非常常见了。关于跨域，有N种类型，本文只专注于ajax请求跨域。\n何为跨域请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。\n几种常见跨域请求\n\n\n请求地址\n服务器地址\n结果\n\n\n\nhttp://www.123.com\nhttp://www.abc.com\n(主域名不同，跨域)\n\n\nhttp://123.xiongchao.com\nhttp://abc.xiongchao.com\n(子域名不同，跨域)\n\n\nhttp://www.xiongchao.com:8080\nhttp://www.xiongchao.com:8081\n(端口不同，跨域)\n\n\nhttp://www.xiongchao.com\nhttps://www.xiongchao.com\n(协议不同，跨域)\n\n\n注意：localhost 和 localhost:8080、localhost 和 127.0.0.1 也属于跨域\n\n\n\n\n跨域情形请求代码：\nvar requestApi = &quot;http://localhost:8080/springmvc_hibernate_maven/&quot;;$.ajax(&#123;    type:&#x27;get&#x27;,    url:requestApi + &quot;test/userInfo&quot;,    dataType:&#x27;json&#x27;,    success:function(data)&#123;        console.log(data);    &#125;,    error:function(err)&#123;        console.log(err);    &#125;&#125;);\n\n服务器端java代码\n@Controller@RequestMapping(&quot;/test&quot;)public class Test &#123;\t@ResponseBody\t@RequestMapping(value = &quot;/userInfo&quot;,method = RequestMethod.GET)\tpublic String getUserInfo(HttpServletResponse httpServletResponse)&#123;\t\tUser user = new User();\t\tuser.setId(1);\t\tuser.setName(&quot;java&quot;);\t\tuser.setPassword(&quot;123456&quot;);\t\tuser.setLoginDate(&quot;2018-08-14&quot;);\t\tSystem.out.println(JSON.toJSONString(user));\t\treturn JSON.toJSONString(user);\t&#125;&#125;\n\n浏览器中访问（将html部署到nginx）结果:\n虽然请求成功并且返回了状态码200，但是并没有返回内容，并且控制台还打印了报错信息\n常见几种解决方案jsonp方式处理（基本被淘汰了）先看看json和jsonp数据格式的区别：\njson格式&#123;  &quot;id&quot;:&quot;1&quot;,  &quot;name&quot;:&quot;java&quot;,  &quot;password&quot;:&quot;123456&quot;,  &quot;loginDate&quot;:&quot;2018-08-14&quot;&#125;\n\njsonp格式callback(&#123;  &quot;id&quot;:&quot;1&quot;,  &quot;name&quot;:&quot;java&quot;,  &quot;password&quot;:&quot;123456&quot;,  &quot;loginDate&quot;:&quot;2018-08-14&quot;&#125;)\njsonp比json外面有多了一层，callback()。\n我们在请求的url后面拼接一个callback参数，用于返回jsonp格式数据\n$.ajax(&#123;    type:&#x27;get&#x27;,    url:requestApi + &quot;test/userInfo?callback=&quot;,    dataType:&#x27;jsonp&#x27;,    success:function(data)&#123;        console.log(data);    &#125;,    error:function(err)&#123;        console.log(err);    &#125;&#125;)\n\n服务器端处理：\n@Controller@RequestMapping(&quot;/test&quot;)public class Test &#123;\t@ResponseBody\t@RequestMapping(value = &quot;/userInfo&quot;,method = RequestMethod.GET)\tpublic String getUserInfo(HttpServletRequest request)&#123;                String callback = request.getParameter(&quot;callback&quot;);\t\tUser user = new User();\t\tuser.setId(1);\t\tuser.setName(&quot;java&quot;);\t\tuser.setPassword(&quot;123456&quot;);\t\tuser.setLoginDate(&quot;2018-08-14&quot;);\t\tSystem.out.println(JSON.toJSONString(user));\t\treturn callback+&quot;(&quot; + JSONObject.toJSONString(user) + &quot;)&quot;;\t&#125;&#125;\n\n我们看一下后台获取的callback的值\n修改请求代码再看一下后台获取的callback的值\n$.ajax(&#123;    type:&#x27;get&#x27;,    url:requestApi + &quot;test/userInfo&quot;,    dataType:&#x27;jsonp&#x27;,    jsonpCallback:&#x27;testCallback&#x27;,    success:function(data)&#123;        console.log(data);    &#125;,    error:function(err)&#123;        console.log(err);    &#125;&#125;)\n正是我们自定义的callback的值\n最后查看请求结果，控制台成功打印获取获取的数据\n需要注意的是jsonp是不支持post方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。另外可以使用jquer-jsonp插件实现跨域请求，服务器端无需做任何处理。java服务器端添加允许跨域请求的响应头ajax请求不用改，只需要添加响应头部Access-Control-Allow-Origin允许所有请求来源就可以了（所有服务器端处理都类似，对java不是很熟练，所以简单略过）\n@Controller@RequestMapping(&quot;/test&quot;)public class Test &#123;\t@ResponseBody\t@RequestMapping(value = &quot;/userInfo&quot;,method = RequestMethod.GET)\tpublic String getUserInfo(HttpServletResponse httpServletResponse)&#123;                httpServletResponse.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\t\tUser user = new User();\t\tuser.setId(1);\t\tuser.setName(&quot;java&quot;);\t\tuser.setPassword(&quot;123456&quot;);\t\tuser.setLoginDate(&quot;2018-08-14&quot;);\t\tSystem.out.println(JSON.toJSONString(user));\t\treturn JSON.toJSONString(user);\t&#125;&#125;\n\n结果：成功请求！\n比jsonp更强大的CORS方式解决跨域基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。\n这里介绍的是java后端应该如何配置以解决问题\n第一步：1.非maven项目：获取依赖jar包下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下2.mavne项目：添加如下依赖到pom.xml中\n&lt;dependency&gt;  &lt;groupId&gt;com.thetransactioncompany&lt;/groupId&gt;  &lt;artifactId&gt;cors-filter&lt;/artifactId&gt;  &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;\n\n第二步:添加CORS配置到项目的Web.xml中(&#x2F;WEB-INF&#x2F;web.xml)\n&lt;!-- 跨域配置 --&gt;&lt;filter&gt;  &lt;!-- The CORS filter with parameters --&gt;  &lt;filter-name&gt;CORS&lt;/filter-name&gt;  &lt;filter-class&gt;com.thetransactioncompany.cors.CORSFilter&lt;/filter-class&gt;  &lt;!-- Note: All parameters are options, if omitted the CORS Filter will     fall back to the respective default values. --&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.allowGenericHttpRequests&lt;/param-name&gt;    &lt;param-value&gt;true&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.allowOrigin&lt;/param-name&gt;    &lt;param-value&gt;*&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.allowSubdomains&lt;/param-name&gt;    &lt;param-value&gt;false&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.supportedMethods&lt;/param-name&gt;    &lt;param-value&gt;GET, HEAD, POST,PUT,DELETE OPTIONS&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.supportedHeaders&lt;/param-name&gt;    &lt;param-value&gt;Accept, Origin, X-Requested-With, Content-Type, Last-Modified&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.exposedHeaders&lt;/param-name&gt;    &lt;!--这里可以添加一些自己的暴露Headers --&gt;    &lt;param-value&gt;X-Test-1, X-Test-2&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.supportsCredentials&lt;/param-name&gt;    &lt;param-value&gt;true&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.maxAge&lt;/param-name&gt;    &lt;param-value&gt;3600&lt;/param-value&gt;  &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;  &lt;!-- CORS Filter mapping --&gt;  &lt;filter-name&gt;CORS&lt;/filter-name&gt;  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;\n请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的)\n除了上述配置，我们无需添加其他任何代码就可以尽情的使用GET,POST,PUT,DELETE等等这个方法了，是不是比jsonp强大多了\n现在我们再来正常请求和处理请求试一下\n$.ajax(&#123;    type:&#x27;delete&#x27;,    url:requestApi + &quot;test/userInfo&quot;,    dataType:&#x27;json&#x27;,    success:function(data)&#123;        console.log(data);    &#125;,    error:function(err,textStatus)&#123;        console.log(&quot;err&quot;,err);    &#125;&#125;)\n\n@Controller@RequestMapping(&quot;/test&quot;)public class Test &#123;\t@ResponseBody\t@RequestMapping(value = &quot;/userInfo&quot;,method = RequestMethod.DELETE)\tpublic String getUserInfo(HttpServletRequest request,HttpServletResponse response)&#123;\t\tUser user = new User();\t\tuser.setId(1);\t\tuser.setName(&quot;java&quot;);\t\tuser.setPassword(&quot;123456&quot;);\t\tuser.setLoginDate(&quot;2018-08-14&quot;);\t\treturn JSONObject.toJSONString(user); \t&#125;&#125;\n\n请求结果：可以看到有OPTIONS请求了\n","categories":["Ajax"],"tags":["ajax","跨域"]},{"title":"JavaScript封装XMLHttpRequest请求","url":"/2018/08/16/JavaScript%E5%B0%81%E8%A3%85XMLHttpRequest%E8%AF%B7%E6%B1%82/","content":"\n\n什么是 XMLHttpRequest 对象XMLHttpRequest 对象用于在后台与服务器交换数据。XMLHttpRequest 对象是开发者的梦想，因为您能够：\n\n在不重新加载页面的情况下更新网页\n在页面已加载后从服务器请求数据\n在页面已加载后从服务器接收数据\n在后台向服务器发送数据\n\n所有现代的浏览器都支持 XMLHttpRequest 对象，XMLHttpRequest在 Ajax 编程中被大量使用。\n原生javascript（ES5）封装XMLHttpRequest对象1.创建ajax.js\nfunction Ajax()&#123;&#125;Ajax.prototype.ajax = function(obj)&#123;    //创建xmlhttprequest对象    var xhr;    try&#123;        xhr = new XMLHttpRequest();    &#125;catch(e)&#123;        xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);    &#125;    xhr.timeout = 5000;    xhr.ontimeout = function (event) &#123;        console.log(&quot;请求超时&quot;);    &#125;    xhr.responseType = obj.dataType;    xhr.open(obj.type,obj.url,obj.async||true);        if(obj.headers&amp;&amp;obj.headers[&quot;Content-Type&quot;])&#123;        xhr.setRequestHeader(&quot;Content-Type&quot;,obj.headers[&quot;Content-Type&quot;]);    &#125;else&#123;        xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);    &#125;    xhr.onreadystatechange = function() &#123;        //xhr.readyState 4:完成，XMLHttpRequest对象读取服务器响应结束        if(xhr.readyState == 4)&#123;             //xhr.status HTTP状态码 2XX表示有效响应 304意味着是从缓存读取            if(xhr.status &gt;= 200 &amp;&amp; (xhr.status &lt; 300 || xhr.status == 304))&#123;                  obj.success(xhr.response)            &#125;else&#123;                obj.error(xhr.status)            &#125;        &#125;    &#125;    if(obj.data)&#123;        var params = [];        for (const key in obj.data) &#123;            if (obj.data.hasOwnProperty(key)) &#123;                params.push(encodeURIComponent(key) + &quot;=&quot; + encodeURIComponent(obj.data[key]))                        &#125;        &#125;        var postData = params.join(&#x27;&amp;&#x27;);        xhr.send(postData);    &#125;else&#123;        xhr.send();    &#125;&#125;\n\n2.引用ajax.js\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;./ajax.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;  var $$ = new Ajax();  var requestApi = &quot;http://localhost:8080/springmvc_hibernate_maven/&quot;;  window.onload = function()&#123;    $$.ajax(&#123;        type:&#x27;get&#x27;,        url:requestApi + &quot;test/userInfo&quot;,        dataType:&#x27;json&#x27;,        success:function(data)&#123;            console.log(data,&quot;get&quot;);        &#125;,        error:function(err)&#123;            console.log(err);        &#125;    &#125;)    $$.ajax(&#123;        type:&#x27;post&#x27;,        url:requestApi + &quot;test/userInfo&quot;,        data:&#123;            name:&quot;xiongchao&quot;,            password:&#x27;xiongchao&#x27;,            status:1        &#125;,        dataType:&#x27;json&#x27;,        success:function(data)&#123;            console.log(data,&quot;post&quot;);        &#125;,        error:function(err)&#123;            console.log(err);        &#125;    &#125;)    $$.ajax(&#123;        type:&#x27;put&#x27;,        url:requestApi + &quot;test/userInfo/4/1&quot;,        dataType:&#x27;json&#x27;,        success:function(data)&#123;            console.log(data,&#x27;put&#x27;);        &#125;,        error:function(err)&#123;            console.log(err);        &#125;    &#125;)    $$.ajax(&#123;        type:&#x27;delete&#x27;,        url:requestApi + &quot;test/userInfo/4&quot;,        dataType:&#x27;json&#x27;,        success:function(data)&#123;            console.log(data,&#x27;delete&#x27;);        &#125;,        error:function(err)&#123;            console.log(err);        &#125;    &#125;)&#125;&lt;/script&gt;\n\n3.顺带看下后端写法（哈哈,虽然不需要前端开发人员操心）\n4.最后看下四种请求的结果\nES6 封装XMLHttpRequest对象同样ajax.js 文件\nconst ajax = function(obj)&#123;  return new Promise((resolve,reject)=&gt;&#123;      //创建xmlhttprequest对象      var xhr;      try&#123;          xhr = new XMLHttpRequest();      &#125;catch(e)&#123;          xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);      &#125;      xhr.timeout = 5000;      xhr.ontimeout = function (event) &#123;          console.log(&quot;请求超时&quot;);      &#125;      xhr.responseType = obj.dataType;      xhr.open(obj.type,obj.url,obj.async||true);            if(obj.headers&amp;&amp;obj.headers[&quot;Content-Type&quot;])&#123;          xhr.setRequestHeader(&quot;Content-Type&quot;,obj.headers[&quot;Content-Type&quot;]);      &#125;else&#123;          xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);      &#125;      xhr.onreadystatechange = function() &#123;          //xhr.readyState 4:完成，XMLHttpRequest对象读取服务器响应结束          if(xhr.readyState == 4)&#123;               //xhr.status HTTP状态码 2XX表示有效响应 304意味着是从缓存读取              if(xhr.status &gt;= 200 &amp;&amp; (xhr.status &lt; 300 || xhr.status == 304))&#123;                    resolve(xhr.response);              &#125;else&#123;                  reject(xhr.response);              &#125;          &#125;      &#125;      if(obj.data)&#123;          var params = [];          for (const key in obj.data) &#123;              if (obj.data.hasOwnProperty(key)) &#123;                  params.push(encodeURIComponent(key) + &quot;=&quot; + encodeURIComponent(obj.data[key]))                          &#125;          &#125;          var postData = params.join(&#x27;&amp;&#x27;);          xhr.send(postData);      &#125;else&#123;          xhr.send();      &#125;  &#125;)&#125;export default ajax;\n\n引用ajax.js\n&lt;script type=&quot;module&quot;&gt;  import ajax from &#x27;./ajax.js&#x27;  var requestApi = &quot;http://localhost:8080/springmvc_hibernate_maven/&quot;;  window.onload = function()&#123;      ajax(&#123;          type:&#x27;get&#x27;,          url:requestApi + &quot;test/userInfo&quot;,          dataType:&#x27;json&#x27;      &#125;).then((data)=&gt;&#123;          console.log(data,&quot;get&quot;);      &#125;).catch((err)=&gt;&#123;          console.log(err);      &#125;)      ajax(&#123;          type:&#x27;post&#x27;,          data:&#123;              name:&quot;xiongchao&quot;,              password:&#x27;xiongchao&#x27;,              status:1          &#125;,          url:requestApi + &quot;test/userInfo&quot;,          dataType:&#x27;json&#x27;      &#125;).then((data)=&gt;&#123;          console.log(data,&quot;post&quot;);      &#125;).catch((err)=&gt;&#123;          console.log(err);      &#125;)      ajax(&#123;          type:&#x27;put&#x27;,          url:requestApi + &quot;test/userInfo/4/1&quot;,          dataType:&#x27;json&#x27;      &#125;).then((data)=&gt;&#123;          console.log(data,&quot;put&quot;);      &#125;).catch((err)=&gt;&#123;          console.log(err);      &#125;)      ajax(&#123;          type:&#x27;delete&#x27;,          url:requestApi + &quot;test/userInfo/4&quot;,          dataType:&#x27;json&#x27;      &#125;).then((data)=&gt;&#123;          console.log(data,&quot;delete&quot;);      &#125;).catch((err)=&gt;&#123;          console.log(err);      &#125;)  &#125;&lt;/script&gt;\n","categories":["Ajax"],"tags":["ajax"]},{"title":"Jquery Dom元素Index()方法的使用","url":"/2017/06/10/Jquery-Dom%E5%85%83%E7%B4%A0Index-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"\n\n\n前言作为一个做后端java开发的被强行拉到前端组的菜鸟，前端知识略懂皮毛的我对于jquery很多常用方法都有误区，比如我现在要说的jquery DOM元素的index()方法。\njquery获取元素索引值index()方法使用误区由于对index()方法理解不是很深，所以在做项目时就遇到了有的页面获取的索引是正常的有的页面获取的索引总是大了2个，然后为了让最后的结果正常我就直接减2，并在后面注释”&#x2F;&#x2F;这里不知道为什么总是多了2，但其他页面又是正常的”，结果组长偶然一次机会看到了我这个注释就批评我说“哪有人这么写代码的”。唉，糗事就不多说了，以后写代码再也不敢这样了。\njquery获取元素索引值index()方法作用用法一：$(select).index();\n\n示例一：\n\n\n# html代码:&lt;div class=&quot;main&quot;&gt;  &lt;div class=&quot;box&quot;&gt;Milk&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;Tea&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;Coffee&lt;/div&gt; &lt;/div&gt;\n# js代码：$(&quot;.box&quot;).on(&quot;click&quot;,function()&#123;  $(this).index();//结果：如果点击的Milk则返回 0&#125;);\n\n\n\n这个示例看起来是获取的自己在与自己相同元素中的位置，那么看实例二\n\n\n示例二：\n\n\n# html代码:&lt;div class=&quot;main&quot;&gt;  &lt;p&gt;Soda&lt;/p&gt;  &lt;div class=&quot;box&quot;&gt;Milk&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;Tea&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;Coffee&lt;/div&gt; &lt;/div&gt; \n# js代码：$(&quot;.box&quot;).on(&quot;click&quot;,function()&#123;  $(this).index();//结果：如果点击的Milk则返回 1&#125;);\n从以上两个示例可以看出$(select).index()即使在没有参数的情况下也是相对用法，这个相对用法是相对其父元素中的位置，而不是获取自己在相同元素中的位置\n用法二：$(select1).index(select2);\n\n示例：\n\n\n# html代码:&lt;p class=&quot;box&quot;&gt;Tea&lt;/p&gt;&lt;div class=&quot;main&quot;&gt;  &lt;p&gt;Soda&lt;/p&gt;  &lt;div class=&quot;box&quot;&gt;Milk&lt;/div&gt;  &lt;div class=&quot;box&quot; id=&quot;box2&quot;&gt;Tea&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;Coffee&lt;/div&gt;&lt;/div&gt;\n# js代码:$(&quot;.box&quot;).index($(&quot;#box2&quot;));//结果: 2\n\n通过这个示例可以看出**$(select1).index(select2)的用法是选择器select2相对于选择器select1**的位置索引，跟同辈元素和其父辈元素都无关。\n总结虽然index()的用法比较简单，但是理解不深的话在项目中运用出了问题还是麻烦的，特别是对于我这个前端菜鸟出现果过这种尴尬的事情还是记录下来比较好，以免以后再跳进同一个坑。\n","categories":["javascript"],"tags":["jquery"]},{"title":"Markdown","url":"/2017/06/09/Markdown/","content":"\n\n我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：\n\n\n整理知识，学习笔记\n发布日记，杂文，所见所想\n撰写发布技术文稿（代码支持）\n撰写发布学术论文（LaTeX 公式支持）\n\n\n\n除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：\nWindows&#x2F;Mac&#x2F;Linux 全平台客户端\n请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的  新文稿 或者使用快捷键 Ctrl+Alt+N。\n\n\n什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以\n1. 制作一份待办事宜 Todo 列表\n 支持以 PDF 格式导出文稿\n 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n 新增 Todo 列表功能\n 修复 LaTex 公式渲染问题\n 新增 LaTex 公式编号功能\n\n2. 书写一个质能守恒公式[^LaTeX]$$E&#x3D;mc^2$$\n3. 高亮一段代码[^code]@requires_authorizationclass SomeClass:    passif __name__ == &#x27;__main__&#x27;:    # A comment    print &#x27;hello world&#x27;\n\n4. 高效绘制 流程图st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op\n\n5. 高效绘制 序列图Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!\n\n6. 高效绘制 甘特图title 项目开发流程section 项目确定    需求分析       :a1, 2016-06-22, 3d    可行性报告     :after a1, 5d    概念验证       : 5dsection 项目实施    概要设计      :2016-07-05  , 5d    详细设计      :2016-07-08, 10d    编码          :2016-07-15, 10d    测试          :2016-07-22, 5dsection 发布验收    发布: 2d    验收: 3d\n\n7. 绘制表格\n\n\n项目\n价格\n数量\n\n\n\n计算机\n$1600\n5\n\n\n手机\n$12\n12\n\n\n管线\n$1\n234\n\n\n8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。\n总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。\n\n什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑&#x2F;发布&#x2F;阅读 Markdown 的在线平台——您可以在任何地方，任何系统&#x2F;设备上管理这里的文字。\n1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！\n2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。\n\n3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！\n4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。\n5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。\n6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏：\n\n通过管理工具栏可以：\n 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通&#x2F;Vim&#x2F;Emacs 编辑模式\n7. 阅读工具栏\n通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。\n工具栏上的五个图标依次为：\n 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境\n8. 阅读模式在 阅读工具栏 点击  或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。\n9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档：\n标签： 未分类\n标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：\n\n10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击  (Ctrl+Alt+P) 发布这份文档给好友吧！\n\n再一次感谢您花费时间阅读这份欢迎稿，点击  (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！\n作者 @ghosert2016 年 07月 07日    \n[^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i&#x3D;1}^n a_i&#x3D;0$， 访问 MathJax 参考更多使用方法。\n[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。\n","categories":["Markdown"],"tags":["Markdown"]},{"title":"Qiniu-image-tool-实现图片一键上传七牛云","url":"/2018/07/02/Qiniu-image-tool-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%80%E9%94%AE%E4%B8%8A%E4%BC%A0%E4%B8%83%E7%89%9B%E4%BA%91/","content":"\n\n&ensp;&ensp;&ensp;&ensp;写博客当然少不了云储存了，那为什么推荐使用七牛云呢，当然是因为七牛云储存提供10G的免费空间,以及每月10G的流量，存放个人博客外链图片最好不过了，七牛云储存还有各种图形处理功能、缩略图、视频存放速度也给力。&ensp;&ensp;&ensp;&ensp;qiniu-image-tool是一个提升 markdown 贴图体验的实用小工具，支持windows 及 mac。其中 qiniu-image-tool-win 为windows版本，基于AutoHotkey和qshell实现，一键上传图片或截图至七牛云，获取图片的markdown引用至剪贴板，并自动粘贴到当前编辑器。\n用法\n复制本地图片、视频、js等文件至剪贴板（ctrl+c）or 使用喜欢的截图工具截图 or 直接复制网络图片.\n切换到编辑器，ctrl+alt+v便可以看到图片链接自动粘贴到当前编辑器的光标处（同时链接也会保存在粘贴板里）\n\n预览效果图：\n本地图片文件上传\n\n截图上传\n\n其它文件上传\n\n\n安装首先从 github 下载release版本（有两个版本：2.0 正式版和1.0 正式版，推荐使用2.0 正式版）并解压到任意目录\n目录结构应如下：\n其中dump-clipboard-png.ps1是保存截图的powershell脚本，qiniu-image-upload.ahk 即完成文件上传的AutoHotkey脚本。\n配置脚本打开settings.ini文件，右键选择编辑脚本使脚本在编辑器中打开，找到下面这段代码:\n\n修改这里的五个配置项的值，其中前四个配置项都与七牛账号相关：\nACCESS_KEY &amp; SECRET_KEY这是qshell操作个人账号的账号凭证，登陆七牛账号后在个人面板-&gt;密钥管理中查看，或者直接访问查看。\nBUCKET_NAME &amp; BUCKET_DOMAIN在对象存储-&gt;存储空间列表中选择或新建一个存储空间即bucket，点击该bucket在右边看到一个测试域名，该域名即bucketDomain是图片上传后的访问域名。这里要特别注意域名不要少了前面的 ***http头 *** 和最后的那个 斜杠。\n运行脚本配置完成以后以管理员身份运行qImage.exe，这时便可以使用ctrl+alt+v尝试上传图片了。\n调试如果以上操作完成后没有按照预期达到图片上传的效果，感兴趣的筒子可以先自己调试找一下原因，一般报错信息会打印在cmd命令行中，但是cmd窗口一闪而过可能看不清楚，这时候将可选参数DEBUG_MODE &#x3D; false 改为DEBUG_MODE &#x3D; true打开调试模式，再次尝试，这时候cmd窗口不会自动关闭，便可以看到具体的报错信息从而对症下药解决问题。\n","categories":["云储存"],"tags":["upload"]},{"title":"css常用奇淫技巧(不定期更新)","url":"/2018/08/30/css%E5%B8%B8%E7%94%A8%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7-%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0/","content":"\n一、常用技巧清除浮动\n添加新的元素 、应用 clear：both; \n父级定义 overflow: auto;\n父元素也设置浮动;\n使用br标签和其自身的html属性:《br clear&#x3D;”all”&#x2F;》 clear&#x3D;”all | left | right | none”;\n最高大上的方法，强烈推荐 parentDom:after{content: “ “;display: block;clear: both;}\n\n垂直居中&lt;div class=&quot;box box1&quot;&gt;  &lt;span&gt;垂直居中&lt;/span&gt;&lt;/div&gt;\n.box &#123;  width: 200px;  height: 200px;  background: red;&#125; \n\n方法1：table-cell.box1 &#123;  display: table-cell;  vertical-align: middle;  text-align: center;&#125;\n方法2：display:flex（部分低版本浏览器不兼容）.box2 &#123;  display: flex;  justify-content:center;  align-items:Center;&#125;\n\n方法3：绝对定位和负边距(已知元素高度).box3 &#123;position:relative;&#125;.box3 span &#123;    position: absolute;    width:100px;    height: 50px;    top:50%;    left:50%;    margin-left:-50px;    margin-top:-25px;    text-align: center;&#125;\n\n方法4：绝对定位和0(已知元素高度).box &#123;position:relative;&#125;.box4 span &#123;  width: 50%;   height: 50%;   background: #000;  overflow: auto;   margin: auto;   position: absolute;   top: 0; left: 0; bottom: 0; right: 0; &#125;\n\n方法5：display:flex和margin:auto.box5 &#123;    display: flex;    text-align: center;&#125;.box5 span &#123;margin: auto;&#125;\n\n文本超出部分隐藏单行文本超出部分隐藏#ellipsis &#123;  overflow: hidden;   /*超出的文本隐藏*/  text-overflow: ellipsis;    /*溢出用省略号显示*/  white-space: nowrap;    /*溢出不换行*/&#125;\n\n多行文本超出部分隐藏#ellipsis &#123;  overflow: hidden;   display: -webkit-box;   /*作为弹性伸缩盒子模型显示*/  -webkit-box-orient: vertical;   /*设置伸缩盒子的子元素排列方式--从上到下垂直排列*/  -webkit-line-clamp: 2;   /*显示的行*/&#125;\n\n二、形状技巧三角形#triangle1 &#123;  width: 0;  height: 0;  border-top: 50px solid red;  border-right: 50px solid orange;  border-bottom: 50px solid yellow;  border-left: 50px solid green;&#125;#triangle2 &#123;  width: 0;  height: 0;  border-top: 50px solid red;  border-right: 50px solid transparent;  border-bottom: 50px solid transparent;  border-left: 50px solid transparent;&#125;\n\n未读数量#superscript &#123;    width: 50px;    height: 50px;    background: red;    padding:0 20px;    border-radius: 20px;&#125;\n\n字体边框同色#app&#123;    width: 100px;    height: 100px;    color: red;    font-size: 30px;    /*方案一    CSS3 currentColor 表示当前的文字颜色*/    /* border: 10px solid currentColor; */        /*方案二    border 的默认值 (initial) 就是 currentColor*/    border: 10px solid;  &#125;\n\n放大镜#div5&#123;    width: 50px;    height: 50px;    border: 5px solid #000000;    border-radius: 50%;    position: relative;&#125;#div5::after&#123;    content: &#x27; &#x27;;    display: block;    width: 8px;    height: 60px;    border-radius: 5px;    background: #000000;    position: absolute;    right: -22px;        top: 38px;    transform: rotate(-45deg);&#125;\n\n","categories":["前端"],"tags":["CSS"]},{"title":"sessionStorage和localStorage解释及区别","url":"/2018/08/07/essionStorage%E5%92%8ClocalStorage%E8%A7%A3%E9%87%8A%E5%8F%8A%E5%8C%BA%E5%88%AB/","content":"\n\nHTML5的本地存储HTML5中与本地存储相关的两个重要内容：Web Storage与本地数据库。其中，Web Storage存储机制是对HTML4中cookie存储机制的一个改善。由于cookie存储机制有很多缺点，HTML5不再使用它，转而使用改良后的Web Storage存储机制。本地数据库是HTML5中新增的一个功能，使用它可以在客户端本地建立一个数据库，原本必须保存在服务器端数据库中的内容现在可以直接保存在客户端本地了，这大大减轻了服务器端的负担，同时也加快了访问数据的速度。\n本文主要来讲解Web Storage我们知道，在HTML4中可以使用cookie在客户端保存诸如用户名等简单的用户信息，但是，通过长期的使用，你会发现，用cookie存储永久数据存在以下几个问题：\n1.大小：cookie的大小被限制在4KB。\n2.带宽：cookie是随HTTP事务一起被发送的，因此会浪费一部分发送cookie时使用的带宽。\n3.复杂性：要正确的操纵cookie是很困难的。\n针对这些问题，在HTML5中，重新提供了一种在客户端本地保存数据的功能，它就是Web Storage。\n具体来说，Web Storage又分为两种：1.sessionStorage：将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据。\n2.localStorage：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。\n这两者的区别在于，sessionStorage为临时保存，而localStorage为永久保存。\n到目前为止，Firefox3.6以上、Chrome6以上、Safari 5以上、Pera10.50以上、IE8以上版本的浏览器支持sessionStorage与localStorage的使用。WebStorage的目的是克服由cookie所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。\nWebStorage两个主要目标：（1）提供一种在cookie之外存储会话数据的路径。（2）提供一种存储大量可以跨会话存在的数据的机制。\nHTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage（会话存储）。1、生命周期：localStorage:localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。　　sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。\n2、存储大小：localStorage和sessionStorage的存储数据大小一般都是：5MB\n3、存储位置：localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。\n4、存储内容类型：localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理\n5、获取方式：localStorage：window.localStorage;；sessionStorage：window.sessionStorage;\n6、应用场景：localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录；\nWebStorage的优点：（1）存储空间更大：cookie为4KB，而WebStorage是5MB；\n（2）节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样每次请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量；\n（3）对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便；\n（4）快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快；\n（5）安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题；\nWebStorage提供了一些方法，数据操作比cookie方便；\nsetItem（key, value） ——  保存数据，以键值对的方式储存信息。\n\ngetItem（key） ——  获取数据，将键值传入，即可获取到对应的value值。\n\nremoveItem（key） ——  删除单个数据，根据键值移除对应的信息。\n\nclear（） ——  删除所有的数据\n\nkey（index） —— 获取某个索引的key\n\n\ncookie 、sessionStorage与localStorage的区别特性cookiesessionStoragelocalStorage数据生命期生成时就会被指定一个maxAge值，这就是cookie的生存周期，在这个周期内cookie有效，默认关闭浏览器失效页面会话期间可用除非数据被清除，否则一直存在存放数据大小4K左右（因为每次http请求都会携带cookie）一般5M或更大详细看这(需科学上网)与服务器通信由对服务器的请求来传递，每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题数据不是由每个服务器请求传递的，而是只有在请求时使用数据，不参与和服务器的通信易用性cookie需要自己封装setCookie，getCookie可以用源生接口，也可再次封装来对Object和Array有更好的支持共同点都是保存在浏览器端，和服务器端的session机制不同（这里有一篇很好的介绍cookie和session的文章）\n\n示例：（1） 新建两个文件：\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;a href=&quot;./test.html&quot; target=&quot;_blank&quot;&gt;跳到test.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    localStorage.setItem(&quot;xiongchao&quot;,123);    sessionStorage.setItem(&quot;xiongchao&quot;,456);&lt;/script&gt;\n\n（2） 部署服务（推荐使用nignx做反向代理,比tomcat简单粗暴，也可以不用这一步，只是为了模拟真实网站会话）\n（3） 打开index.html,并使用链接打开test.html\n两个页面的结果是一样的，这是一次会话，sessionStorage储存的内容被保存下来。\n（4） 单独打开test.html,会发现sessionStorage是空的。\n","categories":["javascript"],"tags":["sessionStorage","localStorage"]},{"title":"git常用命令","url":"/2018/07/08/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"\ngit的工作原理图解：\n将指定文件添加到暂存区(stage)\n\n将暂存区的所有内容提交到当前分支\n\n分支的创建与合并\n\n\ngit的使用步骤：基本使用git add . //如果有删除的文件则：git add -Agit commit -m&quot;first commit&quot;//这一步可能会进入一个奇怪的窗口，需执行 ESC :wqgit pull --rebase origin master//如果有冲突则解决冲突，然后执行第一步，最后执行以下命令git rebase --continuegit push origin master//push时有可能会提示没有change-id//复制提示中的&quot;gitdir=$(git rev-parse --git-dir); scp -p -P 29418 //xiongchao@192.168.1.192:hooks/commit-msg $&#123;gitdir&#125;/hooks/&quot;git commit -amend\n\n如果你正在完成某一个功能不能提交代码，然后又需要用到远程仓库中同事刚提交的代码，则只需要执行以下命令git stashgit pullgit stash pop //可能有冲突，改冲突，可直接运行项目\n\ncherry-pick用法（A分支的内容添加到B分支,此操作是在B分支上）git reflog//复制要cherry-pick的commit id（有说明的那一行）git cherry-pick commitidgit push origin master\n\ngit的常用命令解释：$ git status查看工作区状态；\n$ git add readme.txt将指定文件添加到暂存区(stage);反复多次使用，添加多个文件；\n$ git add .将所有文件添加到Git仓库暂存区；\n$ git commit -m “wrote a readme file”将暂存区的所有内容提交到当前分支；\n$ git checkout – readme.txt”把** readme.txt 文件在工作区的修改全部撤销，这里有两种情况：一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt**已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。\n$ rm test.txt”从版本库暂存区中删除该文件；\n$ git push origin master把当前分支master的内容推送到远程库；\n$ git pull –rebase origin master拉取远程库master分支的内容到本地仓库；\n$ git reset HEAD~将前版本回退到上一个版本；上上一个版本就是HEAD~~，上100个版本写成HEAD~100；\n$ git reset –hard 1094a将前版本回退到指定版本；\n$ git stash将你当前未提交（包括暂存的和非暂存的）到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的,需要说明一点，stash是本地的，不会通过git push命令上传到git server上；\n$ git stash pop将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下；\n$ git stash list查看现有stash；\n$ git stash drop移除stash；或者使用git stash clear命令，删除所有缓存的stash；\n$ git branch dev创建dev分支；\n$ git checkout dev切换到dev分支；\n$ git branch查看当前分支；\n$ git merge dev把dev分支的工作成果合并到master分支上；\n$ git branch -d dev删除dev分支；\n$ git clone将远程仓库克隆到本地；\n$ git log查看提交日志；\n$ git reflog记录你的每一次命令；\n","categories":["工具"],"tags":["git"]},{"title":"js Date对象的详细使用","url":"/2018/07/19/js%20Date%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/","content":"\n\n前言：&ensp;&ensp;&ensp;&ensp;最近发现Date对象在项目中真的是无处不在，几乎做过的所有项目中都有Date的各种用法，然而每次要使用的时候都是各种百度，自己既没有掌握Date的详细用法，也使得每次做项目都浪费很多时间，所以特此研究一下记录下来。\n一：Date()对象基本方法示例：//Date()：返回当日的日期和时间。var date = new Date();//Thu Jul 19 2018 10:46:06 GMT+0800// getDay()：从 Date 对象返回一周中的某一天 (0 ~ 6)。date.getDay();\t\t//4 今天是星期四// getFullYear()：从 Date 对象以四位数字返回年份。date.getFullYear();\t\t//2018// getMonth()：从 Date 对象返回月份 (0 ~ 11)。date.getMonth();\t\t//6// getDate()：从 Date 对象返回一个月中的某一天 (1 ~ 31)。date.getDate();\t\t//19// getHours()：返回 Date 对象的小时 (0 ~ 23)。date.getHours();\t\t//10// getMinutes()：返回 Date 对象的分钟 (0 ~ 59)。date.getMinutes();\t\t//53// getSeconds()：返回 Date 对象的秒数 (0 ~ 59)。date.getSeconds();\t\t//5// getMilliseconds()：返回 Date 对象的毫秒(0 ~ 999)。date.getMilliseconds();\t\t//522// getTime()：返回 1970 年 1 月 1 日至今的毫秒数。date.getTime();\t\t//1531968785522// setFullYear()：设置 Date 对象中的年份（四位数字）。date.setFullYear(1995); //1531968785522// setMonth()：设置 Date 对象中月份 (0 ~ 11)。date.setMonth(8); //Wed Sep 19 2018 11:51:48 GMT+0800 (中国标准时间)// setDate()：设置 Date 对象中月的某一天 (1 ~ 31)。date.setDate(25); //Wed Jul 25 2018 11:52:15 GMT+0800 (中国标准时间)// setTime()：以毫秒设置 Date 对象。date.setTime(77771564221); console.log(date) //Mon Jun 19 1972 11:12:44 GMT+0800 (中国标准时间)// toTimeString()：把 Date 对象的时间部分转换为字符串。console.log(date.toTimeString()); =&gt; 11:58:45 GMT+0800 (中国标准时间)// toDateString()：把 Date 对象的日期部分转换为字符串。console.log(date.toDateString()); =&gt; Thu Jul 19 2018\n\n\n二：Date()对象组合高级用法：//将毫秒转换为yyyy-MM-dd HH:mm:ss日期格式function dateFormat(seconds) &#123;    let date = new Date(seconds),        year = date.getFullYear(),        month = date.getMonth() + 1,        day = date.getDate(),        hour = date.getHours(),        min = date.getMinutes(),        s = date.getSeconds();    return `$&#123;year&#125;-$&#123;formatNum(month)&#125;-$&#123;formatNum(day)&#125; $&#123;formatNum(hour)&#125;:$&#123;formatNum(min)&#125;:$&#123;formatNum(s)&#125;`;&#125;//转换为yyyy-MM-dd日期格式function dateFormatShort(date) &#123;    let year = date.getFullYear(),    month = date.getMonth() + 1,    day = date.getDate();    return `$&#123;year&#125;-$&#123;formatNum(month)&#125;-$&#123;formatNum(day)&#125;`;&#125;//将yyyy-MM-dd HH:mm:ss转化为毫秒数function formatMilliseconds(str)&#123;    // str = &#x27;2018-7-19 15:14:30&#x27;;    str = str.replace(/-/g,&#x27;/&#x27;);//由于部分浏览器以及一些低版本浏览器不兼容new Date(yyyy-MM-dd HH:mm:ss)    let date = new Date(str);    return date.getTime();&#125;//获取两个时间的秒数差function SecondsDiff(startDate,endDate)&#123;    startDate = &quot;2018-7-18 10:56:23&quot;,endDate = &quot;2018-7-19 12:00:00&quot;;    let startTime = formatMilliseconds(startDate),//获得毫秒数        endTime = formatMilliseconds(endDate),        milliseconds = endTime - startTime;//毫秒数之差    return parseInt(milliseconds/1000);&#125;//根据剩余秒数获取剩余HH:mm:ss（应用在活动倒计时或物品过期还有多久&#x27;dd天HH小时&#x27;）function secondsFormat(seconds)&#123;    seconds = SecondsDiff();    let day = Math.floor(seconds / 3600 / 24),        hour = Math.floor((seconds % 86400) / 3600),        min = Math.floor((seconds % 86400 % 3600) / 60 ),        second = Math.floor(seconds % 86400 % 3600 % 60);        hour += day * 24;    return `$&#123;formatNum(hour)&#125;:$&#123;formatNum(min)&#125;:$&#123;formatNum(second)&#125;`;//为什么只计算天数,因为一般活动只在相邻几天&#125;    //获得某月的天数　　 function getMonthDays(year, month) &#123;    let nowDate = new Date(year,month,0),        days = nowDate.getDate();    return days;&#125;//补0操作function formatNum(e) &#123;    return e &gt;= 10 ? e : `0$&#123;e&#125;`;&#125;\t\n\n\n三：对当前时间的判定：//判断时间是否是今天function isToday(str)&#123;    str = new Date(str.replace(/-/g,&quot;/&quot;));    if (str.toDateString() === new Date().toDateString()) &#123;//今天        return true;    &#125; else if (new Date(str) &gt; new Date())&#123;        return false;    &#125;&#125;/*** 判断某个时间是前天、昨天、今天、明天、后天* @now:当前服务器时间*/function daysText(str,now)&#123;    let date = str.substring(0,str.indexOf(&quot;-&quot;)+6);    now = new Date(now.replace(/-/g,&#x27;/&#x27;));    now = new Date(now.getFullYear(), now.getMonth(), now.getDate());    str = new Date(str.replace(/-/g,&#x27;/&#x27;));    str = new Date(str.getFullYear(), str.getMonth(), str.getDate());    let diff = (str - now) / 1000 / 60 / 60 / 24;    if (diff &lt; -1) &#123;        return &quot;前天&quot;;    &#125; else if (diff &lt; -0) &#123;        return &quot;昨天&quot;    &#125; else if (diff == 0) &#123;        return &quot;今天&quot;;    &#125; else if (diff &lt; 2) &#123;        return &quot;明日&quot;;    &#125; else if (diff &lt; 3) &#123;        return &quot;后天&quot;;    &#125; else &#123;        return date;    &#125;&#125;//判断是否超过48小时function overTime(seconds) &#123;    let diffSeconds = Math.floor((new Date().getTime() - seconds)/1000),        days = Math.floor(diffSeconds / 86400),        hour = Math.floor(diffSeconds % 86400 / 3600),        min = Math.floor((diffSeconds % 86400 % 3600) / 60 )        second = Math.floor(diffSeconds % 86400 % 3600 % 60);    if(days&gt;2)&#123;//超过两天超时        return 0;    &#125;else if(days==2)&#123; //刚好两天判断时分秒        if(hour==0)&#123;             if(min==0)&#123;                if(second==0)&#123;                    return 1;                &#125;else&#123; //有多余秒数，超时                    return 0;                &#125;            &#125;else&#123; //有多余分钟，超时                return 0;            &#125;        &#125;else&#123; //还有多余小时，超时            return 0;        &#125;    &#125;else &#123; //小于两天则没有超时        return 1;    &#125;&#125;/** * 判断某个时间相对于现在过了多久 * seconds:毫秒数 */function pastTimes(seconds)&#123;    //得到时间    let dateTime;    //传入时间    let starDate = new Date(seconds),        starYear = starDate.getFullYear(), //年        starMonth = starDate.getMonth() + 1, //月        starDay = starDate.getDate(),     //日        starHour = starDate.getHours(),   //时        starMin = starDate.getMinutes(),  //分        starSen = starDate.getSeconds(); //秒    //当前时间    let nowDate = new Date(),        nowYear = nowDate.getFullYear(), //年        nowMonth = nowDate.getMonth() + 1, //月        nowDay = nowDate.getDate(),     //日        nowHour = nowDate.getHours(),   //时        nowMin = nowDate.getMinutes(),  //分        nowSen = nowDate.getSeconds();  //秒    //判断是否在同一年    if (starYear == nowYear) &#123;        //判断是否是同一个月        if (starMonth == nowMonth) &#123;             //判断在今天昨天或者前天            let diffDay = nowDay - starDay;            if (diffDay == 0) &#123;//今天                //判断小时数                let diffHours = nowHour - starHour;                let diffMinutes = nowMin - starMin;                if (diffHours == 0) &#123;                    if (diffMinutes &gt;= 0 &amp;&amp; diffMinutes &lt; 2) &#123;                        dateTime = &quot;刚刚&quot;;                    &#125; else if (diffMinutes &gt;= 2) &#123;                        dateTime = diffMinutes + &quot;分钟前&quot;;                    &#125;                &#125;else if (diffHours == 1) &#123;                    if (diffMinutes &lt; 0) &#123;                        let minute = (60 - starMin) + (nowMin - 0);                        dateTime = minute + &quot;分钟前&quot;;                    &#125; else if (diffMinutes &gt; 0) &#123;                        dateTime = &quot;1个小时前&quot;;                    &#125;                &#125;else if (diffHours == 2) &#123;                     if (diffMinutes &lt; 0) &#123;                        dateTime = &quot;1个小时前&quot;;                    &#125; else if (diffMinutes &gt; 0) &#123;                        dateTime = &quot;2个小时前&quot;;                    &#125;                &#125;else&#123;                    dateTime = formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);                &#125;            &#125;else if(diffDay == 1) &#123;//昨天                dateTime = &#x27;昨天&#x27; + formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);            &#125;else if (diffDay == 2) &#123;//前天                dateTime = &#x27;前天&#x27; + formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);            &#125;else&#123;                dateTime = formatNum(starMonth) + &#x27;-&#x27; + formatNum(starDay) + &#x27; &#x27; + formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);            &#125;        &#125;else&#123;            //不在同一个月且在同一年的不显示年份            dateTime = formatNum(starMonth) + &#x27;-&#x27; + formatNum(starDay) + &#x27; &#x27; + formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);        &#125;    &#125;else&#123;        //不在同一年的显示年月日时分        dateTime = starYear + &#x27;-&#x27; + formatNum(starMonth) + &#x27;-&#x27; + formatNum(starDay) + &#x27; &#x27; + formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);    &#125;    return dateTime    &#125;","categories":["javascript"],"tags":["js","date"]},{"title":"js 将对象数组中具有相同值的对象取出组成新的数组","url":"/2018/07/26/js-%E5%B0%86%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E5%80%BC%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%96%E5%87%BA%E7%BB%84%E6%88%90%E6%96%B0%E7%9A%84%E6%95%B0%E7%BB%84/","content":"\n\n实现方法：let arr = [  &#123;    &quot;id&quot;: 577,    &quot;name&quot;: &quot;艾杜纱 毛孔洁净洗面奶&quot;,    &quot;skuName&quot;: &quot;125mL&quot;,    &quot;image&quot;: &quot;commodityImage/haZW5gLF.jpg&quot;,    &quot;price&quot;: 122.32,    &quot;store&quot;: 327,    &quot;status&quot;: 1,    &quot;brandId&quot;: 18,    &quot;categoryId&quot;: 32  &#125;, &#123;    &quot;id&quot;: 536,    &quot;name&quot;: &quot;心机彩妆 星魅霓光唇膏&quot;,    &quot;skuName&quot;: &quot;BE300&quot;,    &quot;image&quot;: &quot;commodityImage/ibg54OOx.jpg&quot;,    &quot;price&quot;: 273.65,    &quot;store&quot;: 50,    &quot;status&quot;: 1,    &quot;brandId&quot;: 17,    &quot;categoryId&quot;: 33  &#125;, &#123;    &quot;id&quot;: 546,    &quot;name&quot;: &quot;心机彩妆 炫眉膏&quot;,    &quot;skuName&quot;: &quot;77&quot;,    &quot;image&quot;: &quot;commodityImage/356LBmxe.jpg&quot;,    &quot;price&quot;: 160.68,    &quot;store&quot;: 20,    &quot;status&quot;: 1,    &quot;brandId&quot;: 17,    &quot;categoryId&quot;: 20  &#125;]console.log(arr,&#x27;原始数组&#x27;);console.log(sortArr(arr, &#x27;brandId&#x27;),&#x27;转化后的数组&#x27;);/*** arr 要转化的数组* key 根据某一键转化*/function sortArr(arr, key) &#123;  let newArr = [],      tempArr = [],      temp;  // 按照特定的参数将数组排序，将具有相同值的排在一起  arr = arr.sort(function(a, b) &#123;      let s = a[key],          t = b[key];      return s &lt; t ? -1 : 1;  &#125;);  console.log(arr,&quot;排序之后的数组&quot;);  if ( arr.length )&#123;      temp = arr[0][key];  &#125;  // 将相同类别的对象添加到统一个数组  for (let i in arr) &#123;      if ( arr[i][key] === temp )&#123;          tempArr.push( arr[i] );      &#125; else &#123;          temp = arr[i][key];          newArr.push(tempArr);          tempArr = [arr[i]];      &#125;  &#125;  // 将最后的内容推出新数组  newArr.push(tempArr);  return newArr;&#125;\n结果：\n","categories":["javascript"],"tags":["js","Array"]},{"title":"js经典排序算法","url":"/2018/07/27/js%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/","content":"\n\n1.冒泡排序（Bubble Sort）冒泡排序动图演示：\n定义： 比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个 数据交换。对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。N=N-1，如果N不为0就重复前面二步，否则排序完成。\nfunction bubbleSort(arr)&#123;    var len = arr.length;    for(var i = 0;i &lt; len;i++)&#123;        for(var j = 0;j &lt; len - 1 - i;j++)&#123;            if(arr[j]&gt;arr[j+1])&#123;                var temp = arr[j];                arr[j+1] = arr[j];                arr[j] = temp;            &#125;        &#125;    &#125;&#125;\n2.选择排序（Selection Sort）选择排序动图演示：\n/*** 比如在一个长度为N的无序数组中，在第一趟遍历N个数据，找出其中最小的数值与* 第一个元素交换，第二趟遍历剩下的N-1个数据，找出其中最小的数值与第二个元* 素交换……第N-1趟遍历剩下的2个数据，找出其中最小的数值与第N-1个元素交换，* 至此选择排序完成。*/function selectSort(arr)&#123;    var min,temp;    for(var i=0;i&lt;arr.length-1;i++)&#123;        min=i;        for(var j=i+1;j&lt;arr.length;j++)&#123;            if(arr[j]&lt;arr[min])&#123;                min = j;            &#125;        &#125;        temp=arr[i];        arr[i]=arr[min];        arr[min]=temp;    &#125;    return arr;&#125;\n\n3.插入排序（Insertion Sort）插入排序动图演示：\n从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。\nfunction insertionSort(arr) &#123;    var len = arr.length;    var preIndex, current;    for (var i = 1; i &lt; len; i++) &#123;        preIndex = i - 1;        current = arr[i];        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;            arr[preIndex+1] = arr[preIndex];            preIndex--;        &#125;        arr[preIndex+1] = current;    &#125;    return arr;&#125;\n\n4.快速排序（Quick Sort）快速排序动图演示：\n先从数列中取出一个数作为基准数。分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。再对左右区间重复第二步，直到各区间只有一个数。\n\nfunction quickSort(arr)&#123;    if(arr.length&lt;2)&#123;        return arr    &#125;    var left=[],right=[],mid=arr.splice(Math.floor(arr.length/2),1);    for(var i=0;i&lt;arr.length;i++)&#123;            if(arr[i]&lt;mid)&#123;                left.push(arr[i]);            &#125;else &#123;                right.push(arr[i])            &#125;    &#125;    return bubbleSort(left).concat(mid,bubbleSort(right))  &#125;","categories":["算法"],"tags":["Array","sort"]},{"title":"js跳出循环总结","url":"/2018/07/31/js%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF%E6%80%BB%E7%BB%93/","content":"\n\n一.跳出一层循环var arr = [&quot;a&quot;, &quot;b&quot;,&#x27;c&#x27;,&#x27;d&#x27;];\n结束for循环for(var i=0;i&lt;arr.length;i++)&#123;  if(i==2)&#123;      break;  &#125;  console.log(arr[i],i);&#125;console.log(&#x27;循环外&#x27;);\n注意：return 虽说可以结束循环，但是循环体后面的内容也无法执行了\n结束forEach循环try &#123;    arr.forEach((o,i) =&gt; &#123;        if(i==2)&#123;            throw new Error(&quot;EndIterative&quot;);        &#125;        console.log(o,i);    &#125;);&#125; catch (e) &#123;    if(e.message!=&#x27;EndIterative&#x27;)&#123;        throw e;    &#125;&#125;console.log(&#x27;循环体外&#x27;);\n\n注意：return 只能结束本次循环，并不能终止整个循环\n结束for…in循环for (var i in arr) &#123;    if(i==2)&#123;        break;    &#125;    console.log(arr[i],i);&#125;console.log(&#x27;循环体外&#x27;);\n注意：return 虽说可以结束循环，但是循环体后面的内容也无法执行了\n结果：\n二.跳出多层循环var arr = [[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;],[&quot;小红&quot;, &quot;小明&quot;, &quot;小亮&quot;]];\n正常多层for循环for (var i = 0; i &lt; arr.length; i++) &#123;    for (var j = 0; j &lt; arr[i].length; j++) &#123;        console.log(arr[i][j], &#x27;内层&#x27;);    &#125;    console.log(arr[i], &quot;外层&quot;);&#125;console.log(&quot;循环体外&quot;);\n#####结果：\n使用breakfor (var i = 0; i &lt; arr.length; i++) &#123;    for (var j = 0; j &lt; arr[i].length; j++) &#123;      if(j==i)&#123;          break;      &#125;      console.log(arr[i][j], &#x27;内层&#x27;);    &#125;    console.log(arr[i], &quot;外层&quot;);&#125;\n结果： 只跳出了一层循环\n\n我们可以使用以下方法跳出多层for循环var flag = false;for (var i = 0; i &lt; arr.length; i++) &#123;    for (var j = 0; j &lt; arr[i].length; j++) &#123;      if(j==1)&#123;          flag = true;          break;      &#125;      console.log(arr[i][j], &#x27;内层&#x27;);    &#125;    if(flag)&#123;        break;    &#125;    console.log(arr[i], &quot;外层&quot;);&#125;\n结果： 只执行了一次j&#x3D;0就结束了循环\n使用returnfor (var i = 0; i &lt; arr.length; i++) &#123;    for (var j = 0; j &lt; arr[i].length; j++) &#123;      if(j==1)&#123;          return;      &#125;      console.log(arr[i][j], &#x27;内层&#x27;);    &#125;    console.log(arr[i], &quot;外层&quot;);&#125;console.log(&#x27;我在循环体外&#x27;);\n结果： 虽然跳出了多层循环，但是循环体后面的内容都没有被执行\n\n跳出多层forEach循环try &#123;    arr.forEach((newArr,i) =&gt; &#123;        newArr.forEach((o,j)=&gt;&#123;            if(j==1)&#123;                throw new Error(&quot;EndIterative&quot;);            &#125;            console.log(o,&#x27;内层&#x27;)        &#125;);        console.log(newArr,&#x27;外层&#x27;);    &#125;);&#125; catch (e) &#123;    if(e.message!=&quot;EndIterative&quot;)&#123;        throw e;    &#125;&#125;console.log(&#x27;循环体外&#x27;);\n结果： 正确跳出了多层循环\n最后总结：\nbreak只能在for、for…in循环中使用不能再forEach里面使用，并且break只能跳出单层循环；\nreturn 虽然可以终止循环，但是也终止了return之后的所有语句，特别注意：return 不能终止forEach循环，只能结束当前循环。\n\n","categories":["javascript"],"tags":["Array","循环"]},{"title":"使用gulp插件快速开发项目","url":"/2017/07/16/%E4%BD%BF%E7%94%A8gulp%E6%8F%92%E4%BB%B6%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE/","content":"\n\n\n简介：&ensp;&ensp;&ensp;&ensp;gulp有着丰富的插件库，她能自动化地完成javascript、coffee、sass、less、html、image、css 等文件的的测试、检查、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤，能快速提高我们项目的开发效率。\n1.gulpfile.js基本配置示例：&ensp;&ensp;&ensp;&ensp;通过此配置示例可以让我们快速编写js,css代码并打包压缩文件，减少文件资源大小。\n//导入工具包 require(&#x27;node_modules里对应模块&#x27;)var gulp = require(&#x27;gulp&#x27;); //本地安装gulp所用到的地方var sass = require(&#x27;gulp-sass&#x27;);//将scss文件编译成浏览器可识别的cssvar minifycss = require(&#x27;gulp-minify-css&#x27;);//压缩css文件，减小文件大小，并给引用url添加版本号避免缓存var cleancss = require(&#x27;gulp-clean-css&#x27;);//压缩css文件，减小文件大小，并给引用url添加版本号避免缓存var livereload = require(&#x27;gulp-livereload&#x27;);//监听文件发生变化时，浏览器自动刷新页面var babel = require(&#x27;gulp-babel&#x27;);//将ES6编译成ES5var uglify = require(&#x27;gulp-uglify&#x27;);//压缩jsvar autoprefixer = require(&#x27;gulp-autoprefixer&#x27;);//根据设置浏览器版本自动处理浏览器前缀//定义一个sass任务（自定义任务名称）gulp.task(&#x27;sass&#x27;, function () &#123;    gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件        .pipe(sass()) //该任务调用的模块        .pipe(cleancss(&#123;            advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]            compatibility: &#x27;ie7&#x27;,//保留ie7及以下兼容写法 类型：String 默认：&#x27;&#x27;or&#x27;*&#x27; [启用兼容模式； &#x27;ie7&#x27;：IE7兼容模式，&#x27;ie8&#x27;：IE8兼容模式，&#x27;*&#x27;：IE9+兼容模式]            keepBreaks: true,//类型：Boolean 默认：false [是否保留换行]            keepSpecialComments: &#x27;*&#x27;            //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀        &#125;))        .pipe(autoprefixer(&#123;            browsers: [&#x27;last 2 versions&#x27;, &#x27;Android &gt;= 4.0&#x27;],            cascade: true, //是否美化属性值 默认：true             remove:true //是否去掉不必要的前缀 默认：true         &#125;))        .pipe(gulp.dest(&#x27;./css&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）        .pipe(livereload());//监听文件发生变化时，浏览器自动刷新页面&#125;);//定义一个babel任务（自定义任务名称）编译jsgulp.task(&#x27;babel&#x27;, function () &#123;    gulp.src(&#x27;./src/**/*.js&#x27;) //该任务针对的文件        .pipe(babel(&#123;            presets: [&#x27;es2015&#x27;]        &#125;)) //该任务调用的模块        .pipe(livereload())//监听文件发生变化时，浏览器自动刷新页面        .pipe(uglify(&#123; //压缩js            // mangle: false,//类型：Boolean 默认：true 是否修改变量名            // compress: true//类型：Boolean 默认：true 是否完全压缩        &#125;))        .pipe(gulp.dest(&#x27;./js&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);gulp.task(&#x27;auto&#x27;, function () &#123;    gulp.watch(&#x27;./sass/**/*.scss&#x27;, [&#x27;sass&#x27;]);    gulp.watch(&#x27;./src/**/*.js&#x27;, [&#x27;babel&#x27;]);    // livereload.listen();&#125;); gulp.task(&#x27;default&#x27;,[&#x27;sass&#x27;,&#x27;auto&#x27;,&#x27;babel&#x27;]); //定义默认任务// 通配符路径匹配示例：// “src/a.js”：指定具体文件；// “*”：匹配所有文件    例：src/*.js(包含src下的所有js文件)；// “**”：匹配0个或多个子文件夹    例：src/**/*.js(包含src的0个或多个子文件夹下的js文件)；// “&#123;&#125;”：匹配多个属性    例：src/&#123;a,b&#125;.js(包含a.js和b.js文件)  src/*.&#123;jpg,png,gif&#125;(src下的所有jpg/png/gif文件)；// “!”：排除文件    例：!src/a.js(不包含src下的a.js文件)；//gulp.task(name[, deps], fn) 定义任务  name：任务名称 deps：依赖任务名称 fn：回调函数//gulp.src(globs[, options]) 执行任务处理的文件  globs：处理的文件路径(字符串或者字符串数组) //gulp.dest(path[, options]) 处理完后文件生成路径\n\n配置文件详解：执行一个任务分三步走：1.导入工具包 require(‘node_modules里对应模块’)  \nvar gulp = require(&#x27;gulp&#x27;); //本地安装gulp所用到的地方\n\n2.定义一个任务（自定义任务名称）  \ngulp.task(&#x27;test&#x27;, function () &#123;  gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件      .pipe(test())      .pipe(gulp.dest(&#x27;./css&#x27;)) //将会在css文件夹下生成.css文件（复制文件目录及文件）&#125;)\n3.执行任务：cmd命令提示符 \ngulp test\n如果只是简单的配置了上面部分，每当我们修改了代码都需要重新执行命令gulp test,而且如果有多个任务就要执行多个命令，为了避免这么繁琐的操作可以加上如下配置：gulp.task(&#x27;auto&#x27;, function () &#123;    gulp.watch(&#x27;./src/**/*.js&#x27;, [&#x27;test&#x27;]);&#125;);gulp.task(&#x27;default&#x27;,[&#x27;auto&#x27;,&#x27;test&#x27;]); //定义默认任务\n这样我们只需要输入一次命令gulp,就可以监听到每次代码的修改，自动帮我们编译，减少了很多繁琐的操作。\n2.使用gulp编译css1.gulp-sass的使用：1.简介：SASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。2.本地安转：npm install gulp-less –save-dev3.配置gulpfile.js1.配置：\n//导入sass工具包var sass = require(&#x27;gulp-sass&#x27;);//定义一个sass任务（自定义任务名称）gulp.task(&#x27;sass&#x27;, function () &#123;    gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件        .pipe(sass(&#123;        outputStyle: &#x27;compact&#x27;  //代码风格      // nested：嵌套缩进的css代码，它是默认值。      // expanded：没有缩进的、扩展的css代码。      // compact：简洁格式的css代码。      // compressed：压缩后的css代码。        &#125;)) //该任务调用的模块        .pipe(gulp.dest(&#x27;./css&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);\n\n2.sass使用示例：\n$blue : #1875e7;　.class &#123;    font-size: 12px;&#125;.main&#123;    color:$blue;    @if 1 + 1 == 2 &#123;         border: 1px solid red;    &#125;@if 5 &lt; 3 &#123;         border: 2px dotted blue;     &#125;    .parent&#123;        margin-left:10px + 20px;        &amp;:hover&#123;            cursor: pointer;            @extend .class;        &#125;    &#125;&#125;\n\n4.执行任务：命令提示符：gulp sass\n5.编译结果：\n2.gulp-minify-css的使用：1.插件介绍：压缩css文件，减小文件大小，并给引用url添加版本号避免缓存2.本地安转：npm install gulp-minify-css –save-dev。3.配置gulpfile.js1.配置\nvar minifycss = require(&#x27;gulp-minify-css&#x27;);//定义一个sass任务（自定义任务名称）gulp.task(&#x27;sass&#x27;, function () &#123;    gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件        .pipe(sass(&#123;            outputStyle: &#x27;compact&#x27;  //代码风格        // nested：嵌套缩进的css代码，它是默认值。        // expanded：没有缩进的、扩展的css代码。        // compact：简洁格式的css代码。        // compressed：压缩后的css代码。        &#125;)) //该任务调用的模块        .pipe(minifycss(&#123;            advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]            compatibility: &#x27;ie7&#x27;,//保留ie7及以下兼容写法 类型：String 默认：&#x27;&#x27;or&#x27;*&#x27; [启用兼容模式； &#x27;ie7&#x27;：IE7兼容模式，&#x27;ie8&#x27;：IE8兼容模式，&#x27;*&#x27;：IE9+兼容模式]            keepBreaks: true,//类型：Boolean 默认：false [是否保留换行]            keepSpecialComments: &#x27;*&#x27;            //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀        &#125;))        .pipe(gulp.dest(&#x27;./css&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);\n2.使用示例：\n4.执行任务：命令提示符：gulp sass\n5.编译结果：编译之后的css文件被压缩了\n3.gulp-autoprefixer：1.插件介绍：根据设置浏览器版本自动处理浏览器前缀2.本地安转：npm install gulp-autoprefixer –save-dev。3.配置gulpfile.js1.配置\nvar autoprefixer = require(&#x27;gulp-autoprefixer&#x27;);//定义一个sass任务（自定义任务名称）gulp.task(&#x27;sass&#x27;, function () &#123;    gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件        .pipe(sass(&#123;            outputStyle: &#x27;compact&#x27;  //代码风格        // nested：嵌套缩进的css代码，它是默认值。        // expanded：没有缩进的、扩展的css代码。        // compact：简洁格式的css代码。        // compressed：压缩后的css代码。        &#125;)) //该任务调用的模块        .pipe(autoprefixer(&#123;            browsers: [&#x27;last 2 versions&#x27;, &#x27;Android &gt;= 4.0&#x27;],            cascade: true, //是否美化属性值 默认：true             remove:true //是否去掉不必要的前缀 默认：true         &#125;))        .pipe(gulp.dest(&#x27;./css&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);\n2.使用示例：\n4.执行任务：命令提示符：gulp sass\n5.编译结果：浏览器中的编译结果：\n3.使用gulp编译js1.gulp-babel的使用：1.介绍：gulp-babel是可以将ES6编译成大多数浏览器可识别的ES5规范2.本地安转：1.npm install gulp-babel –save-dev2.npm install babel-preset-es2015 –save-dev\n3.配置gulpfile.js1.配置：\n//导入babel工具包var less = require(&#x27;gulp-babel&#x27;);//定义一个babel任务（自定义任务名称）//定义一个babel任务（自定义任务名称）编译jsgulp.task(&#x27;babel&#x27;, function () &#123;    gulp.src(&#x27;./src/**/*.js&#x27;) //该任务针对的文件        .pipe(babel(&#123;            presets: [&#x27;es2015&#x27;]        &#125;)) //该任务调用的模块        .pipe(gulp.dest(&#x27;./js&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);\n\n2.ES6使用示例：\n\n4.执行任务：命令提示符：gulp babel\n5.编译结果：\n2.gulp-uglify的使用：1.介绍：压缩js代码2.本地安转： npm install gulp-uglify –save-dev3.配置gulpfile.js1.配置：\n//导入uglify工具包var uglify = require(&#x27;gulp-uglify&#x27;);//定义一个babel任务（自定义任务名称）编译jsgulp.task(&#x27;babel&#x27;, function () &#123;    gulp.src(&#x27;./src/**/*.js&#x27;) //该任务针对的文件        .pipe(babel(&#123;            presets: [&#x27;es2015&#x27;]        &#125;)) //该任务调用的模块        .pipe(uglify(&#123; //压缩js         // mangle: false,//类型：Boolean 默认：true 是否修改变量名         // compress: true//类型：Boolean 默认：true 是否完全压缩        &#125;))        .pipe(gulp.dest(&#x27;./js&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);\n\n2.ES6使用示例：\n\n4.执行任务：命令提示符：gulp babel\n5.编译结果：\ngulp插件库还有其他很多优秀的插件，可以根据自己的需要引入。此dome在我的github上，可以下载自行查看https://github.com/xiongcao/project-gule\n","categories":["工具"],"tags":["gulp"]},{"title":"css3伪类选择器nth-child和nth-of-type的区别","url":"/2017/06/10/ss3%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8nth-child%E5%92%8Cnth-of-type%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"\n\n\n\n使用误区之前在做项目时一直是:nth-child和:nth-of-type混着用，第一个不行就用第二个，当时就觉得能实现效果就行，后来这样的情况遇到多了，每次用的时候就感觉效果是试出来的，特别浪费时间，现在就来研究一下这两个用法的区别。\n1.用法效果相同的情况示例一：# HTML代码&lt;div class=&quot;main&quot;&gt;  &lt;p&gt;one&lt;/p&gt;  &lt;p&gt;two&lt;/p&gt;  &lt;p&gt;three&lt;/p&gt;&lt;/div&gt;\n\n要实现的效果：将two变红\n\n\nnth-child()的方式:\n\n\n# CSSp:nth-child(2)&#123;color:red;&#125;\n\n\n\nnth-of-type()的方式:\n\n\n# CSSp:nth-of-type(2)&#123;color:red;&#125;\n\n效果：\n在同辈元素都相同的情况下两个用法效果一样\n2.用法相同效果不同的情况示例二：# HTML代码&lt;div class=&quot;main&quot;&gt;  &lt;p&gt;one&lt;/p&gt;  &lt;div&gt;div&lt;/div&gt;  &lt;p&gt;two&lt;/p&gt;  &lt;p&gt;three&lt;/p&gt;&lt;/div&gt;\n要实现的效果：同样将two变红\n\n\n先看nth-of-type()的方式:\n\n\n# CSSp:nth-of-type(2)&#123;color:red;&#125;\n效果：\n\n\n再来看nth-child()的方式:\n\n\n# CSSp:nth-child(2)&#123;color:red;&#125;\n效果：\n3.用法不同效果相同的情况示例三：# HTML代码&lt;div class=&quot;main&quot;&gt;  &lt;p&gt;one&lt;/p&gt;  &lt;div&gt;div&lt;/div&gt;  &lt;p&gt;two&lt;/p&gt;  &lt;p&gt;three&lt;/p&gt;&lt;/div&gt;\n要实现的效果：同样将two变红\n\n\n先看nth-of-type()的方式:\n\n\n# CSSp:nth-of-type(2)&#123;color:red;&#125;\n\n\n\n再来看nth-child()的方式:\n\n\n# CSSp:nth-child(3)&#123;color:red;&#125;\n\n效果：\n用法总结从以上三个示例可以看出：\n\n1.在所有子元素都相同的情况下，两种用法效果相同；\n2.在子元素不同的情况下，:nth-of-type选择的是相同（同种元素）元素中的第几个，而:nth-child选择的其父辈元素下面的第几个子元素；\n\n","categories":["javascript"],"tags":["css","伪类选择器"]},{"title":"使用gulp自动化构建前端项目","url":"/2017/07/09/%E4%BD%BF%E7%94%A8gulp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/","content":"\n\n\ngulp简介：&ensp;&ensp;&ensp;&ensp;gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成，从而大大提高我们的工作效率。\n&ensp;&ensp;&ensp;&ensp;gulp是基于Nodejs的自动任务运行器,她能自动化地完成javascript、coffee、sass、less、html、image、css 等文件的的测试、检查、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。\n环境搭建：1.安装nodeJS1.gulp是基于nodejs，所以需要安装nodejs。2.自己去node官网下载nodejs安装。\n2.npm工具说明：npm（node package manager）nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）；\n使用npm安装插件：npm install &lt;name&gt; [-g] [–save-dev]；1.name: node插件名称。例：npm install gulp-sass –save-dev；\n2.-g: 全局安装,可以通过命令行在任何地方调用它。如果不写-g则使非全局安装，将安装在定位目录的node_modules文件夹下，通过require()调用；  \n3.–save: 将保存配置信息至package.json（package.json是nodejs项目配置文件）；\n4.-dev: 保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点；\n3.安装gulp1.npm install gulp -g；\n4.新建package.json文件1.说明：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件；\n2.通过命令行新建：npm init， 创建过程中会提示让输入各种信息，可以一直回车忽略它。\n5.新建gulpfile.js文件1.说明：gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件2.新建gulpfile.js文件示例  \n//导入工具包 require(&#x27;node_modules里对应模块&#x27;)var gulp = require(&#x27;gulp&#x27;); //本地安装gulp所用到的地方var sass = require(&#x27;gulp-sass&#x27;);var minifycss = require(&#x27;gulp-minify-css&#x27;);//压缩css插件var cleancss = require(&#x27;gulp-clean-css&#x27;);//压缩css插件 //定义一个sass任务（自定义任务名称）gulp.task(&#x27;sass&#x27;, function () &#123;    gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件        .pipe(sass()) //该任务调用的模块        .pipe(cleancss(&#123;            advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]            compatibility: &#x27;ie7&#x27;,//保留ie7及以下兼容写法 类型：String 默认：&#x27;&#x27;or&#x27;*&#x27; [启用兼容模式； &#x27;ie7&#x27;：IE7兼容模式，&#x27;ie8&#x27;：IE8兼容模式，&#x27;*&#x27;：IE9+兼容模式]            keepBreaks: true,//类型：Boolean 默认：false [是否保留换行]            keepSpecialComments: &#x27;*&#x27;            //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀        &#125;))        .pipe(gulp.dest(&#x27;./css&#x27;)); //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;); gulp.task(&#x27;default&#x27;,[&#x27;sass&#x27;]); //定义默认任务 //gulp.task(name[, deps], fn) 定义任务  name：任务名称 deps：依赖任务名称 fn：回调函数//gulp.src(globs[, options]) 执行任务处理的文件  globs：处理的文件路径(字符串或者字符串数组) //gulp.dest(path[, options]) 处理完后文件生成路径\n\n6.运行gulp1.gulp [name]:  gulpfile.js里面定义的模块的名称 例如:gulp sass。2.gulp default: 如果定义了默认任务gulp.task(‘default’,[‘sass’])可直接执行gulp命令。\n&ensp;&ensp;&ensp;&ensp;到此为止使用gulp自动化构建前端项目的环境已经配置完成了，接下来就是我们自己去安装相应的插件来完善项目了。","categories":["工具"],"tags":["gulp"]},{"title":"本地存储","url":"/2019/01/16/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/","content":"\n\nHTML5的本地存储HTML5中与本地存储相关的两个重要内容：Web Storage与本地数据库。其中，Web Storage存储机制是对HTML4中cookie存储机制的一个改善。由于cookie存储机制有很多缺点，HTML5不再使用它，转而使用改良后的Web Storage存储机制。本地数据库是HTML5中新增的一个功能，使用它可以在客户端本地建立一个数据库，原本必须保存在服务器端数据库中的内容现在可以直接保存在客户端本地了，这大大减轻了服务器端的负担，同时也加快了访问数据的速度。\n本文主要来讲解Web Storage我们知道，在HTML4中可以使用cookie在客户端保存诸如用户名等简单的用户信息，但是，通过长期的使用，你会发现，用cookie存储永久数据存在以下几个问题：\n1.大小：cookie的大小被限制在4KB。\n2.带宽：cookie是随HTTP事务一起被发送的，因此会浪费一部分发送cookie时使用的带宽。\n3.复杂性：要正确的操纵cookie是很困难的。\n针对这些问题，在HTML5中，重新提供了一种在客户端本地保存数据的功能，它就是Web Storage。\n具体来说，Web Storage又分为两种：1.sessionStorage：将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据。\n2.localStorage：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。\n这两者的区别在于，sessionStorage为临时保存，而localStorage为永久保存。\n到目前为止，Firefox3.6以上、Chrome6以上、Safari 5以上、Pera10.50以上、IE8以上版本的浏览器支持sessionStorage与localStorage的使用。WebStorage的目的是克服由cookie所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。\nWebStorage两个主要目标：（1）提供一种在cookie之外存储会话数据的路径。（2）提供一种存储大量可以跨会话存在的数据的机制。\nHTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage（会话存储）。1、生命周期：localStorage:localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。　　sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。\n2、存储大小：localStorage和sessionStorage的存储数据大小一般都是：5MB\n3、存储位置：localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。\n4、存储内容类型：localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理\n5、获取方式：localStorage：window.localStorage;；sessionStorage：window.sessionStorage;\n6、应用场景：localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录；\nWebStorage的优点：（1）存储空间更大：cookie为4KB，而WebStorage是5MB；\n（2）节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样每次请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量；\n（3）对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便；\n（4）快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快；\n（5）安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题；\nWebStorage提供了一些方法，数据操作比cookie方便；\nsetItem（key, value） ——  保存数据，以键值对的方式储存信息。\n\ngetItem（key） ——  获取数据，将键值传入，即可获取到对应的value值。\n\nremoveItem（key） ——  删除单个数据，根据键值移除对应的信息。\n\nclear（） ——  删除所有的数据\n\nkey（index） —— 获取某个索引的key\n\n\ncookie 、sessionStorage与localStorage的区别特性cookiesessionStoragelocalStorage数据生命期生成时就会被指定一个maxAge值，这就是cookie的生存周期，在这个周期内cookie有效，默认关闭浏览器失效页面会话期间可用除非数据被清除，否则一直存在存放数据大小4K左右（因为每次http请求都会携带cookie）一般5M或更大详细看这(需科学上网)与服务器通信由对服务器的请求来传递，每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题数据不是由每个服务器请求传递的，而是只有在请求时使用数据，不参与和服务器的通信易用性cookie需要自己封装setCookie，getCookie可以用源生接口，也可再次封装来对Object和Array有更好的支持共同点都是保存在浏览器端，和服务器端的session机制不同（这里有一篇很好的介绍cookie和session的文章）\n\n示例：（1） 新建两个文件：\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;a href=&quot;./test.html&quot; target=&quot;_blank&quot;&gt;跳到test.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    localStorage.setItem(&quot;xiongchao&quot;,123);    sessionStorage.setItem(&quot;xiongchao&quot;,456);&lt;/script&gt;\n\n（2） 部署服务（推荐使用nignx做反向代理,比tomcat简单粗暴，也可以不用这一步，只是为了模拟真实网站会话）\n（3） 打开index.html,并使用链接打开test.html\n两个页面的结果是一样的，这是一次会话，sessionStorage储存的内容被保存下来。\n（4） 单独打开test.html,会发现sessionStorage是空的。\n","categories":["缓存"],"tags":["缓存"]},{"title":"大纲","url":"/2019/01/06/%E5%A4%A7%E7%BA%B2/","content":"\n\nIP\nIP头：IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间\nUDP（user datagram protocol）用户数据包协议\nTCP（transmission control protocol）传输控制协议\n性能优化：浏览器的组成与功能\nCDN工作原理\n浏览器渲染引擎与阻塞\n图层与重回重排\n浏览器本地存储\n缓存机制\n浏览器原理：CDN工作原理\nHTTP相关原理\n网页渲染原理\n浏览器的组成与功能\n浏览器相关原理\n三次握手四次挥手\n输入URL后发生了什么\n外链浏览器相关原理详细总结一\n","categories":["浏览器"],"tags":["网络","浏览器"]},{"title":"缓存机制","url":"/2019/02/10/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","content":" \n\n一、缓存理解1.缓存定义:​        浏览器在本地磁盘上将用户之前请求的数据存储起来，当访问者再次需要改数据的时候无需再次发送请求，直接从浏览器本地获取数据。\n2.缓存的好处:\n减少请求的个数；\n节省带宽，避免浪费不必要的网络资源；\n减轻服务器压力；\n提高浏览器网页的加载速度，提高用户体验；\n\n二、缓存分类1.强缓存\n不会向服务器发送请求，直接从本地缓存中获取数据\n\n请求资源的的状态码为: 200 ok(from memory cache)\n\n\n2.协商缓存\n向服务器发送请求，服务器会根据请求头的资源判断是否命中协商缓存\n如果命中，则返回304状态码通知浏览器从缓存中读取资源\n\n3.强缓存 &amp; 协商缓存的共同点\n都是从浏览器端读取资源\n\n4.强缓存 VS 协商缓存的不同点\n强缓存不发请求给服务器\n协商缓存发请求给服务器，根据服务器返回的信息决定是否使用缓存\n\n三、缓存使用示意图\n四、缓存中的header参数1、强缓存的header参数\nexpires：\n这是http1.0时的规范；它的值为一个绝对时间的GMT格式的时间字符串，如Mon, 10 Jun 2015 21:31:12 GMT，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。\n\ncache-control：max-age&#x3D;number。\n\n这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；\n\ncache-control常用的值（做一个简单了解即可）：\n\nno-cache: 不使用本地缓存，需要使用协商缓存。先与服务器确认返回的响应是否被更改，如果之前的响应中存在Etag，那么请求的额时候会与服务器端进行验证，如果资源为被更改则使用缓存。\n\nno-store: 直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。\n\npublic：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。\n\nprivate：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。\n\n注意：当cache-control与Expires共存的时候cache-control的优先级高\n\n\n2、协商缓存的header参数 重点：协商缓存都是由服务器来确定缓存资源是否可用的，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问\nLast-Modified&#x2F;If-Modified-Since:二者的值都是GMT格式的时间字符串\n\n浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间\n浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值\n服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header\n浏览器收到304的响应后，就会从缓存中加载资源\n如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值\n图例：\n\n\nEtag&#x2F;If-None-Match\n\n这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变\n其判断过程与Last-Modified&#x2F;If-Modified-Since类似\n\n\n既生Last-Modified何生Etag\n\nHTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题\n一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET\n某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；\n某些服务器不能精确的得到文件的最后修改时间。\n\n\n小结：\n\n利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。\nLast-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。\n\n","categories":["http"],"tags":["缓存","http"]},{"title":"浏览器相关原理详细总结一","url":"/2019/02/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/","content":" \n\n浏览器相关原理详细总结一Chrome 打开一个页面需要启动多少进程？分别有哪些进程？浏览器从关闭状态进行启动，然后新开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个进程；后续再新开标签页，浏览器、网络进程、GPU进程是共享的，不会重新启动，如果2个页面属于同一站点的话，并且从a页面中打开的b页面，那么他们也会共用一个渲染进程，否则新开一个渲染进程。\n最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。\n\n浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。\n\n渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。\n\nGPU 进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。\n\n网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。\n\n插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。\n\n\n如何保证页面文件能被完整送达浏览器？互联网中的数据是通过数据包来传输的。数据包要在互联网上进行传输，就要符合网际协议(IP)，互联网上不同的在线设备都有唯一的地址，地址只是一个数字，只要知道这个具体的地址，就可以往这里发送信息。\n如果要想把一个数据包从主机 A 发送给主机 B，那么在传输之前，数据包上会被附加上主机 B 的 IP 地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机 A 本身的 IP 地址，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 IP 头的数据结构里。IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。\nIP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，是交给浏览器还是交给王者荣耀？？因此，需要基于 IP 之上开发能和应用打交道的协议，最常见的是用户数据包协议（User Datagram Protocol)，简称UDP和传输控制协议（Transmission Control Protocol）,简称TCP。\n基本传输过程为：\n\n上层将数据包交给传输层；\n传输层会在数据包前面附加上UDP 头，组成新的 UDP 数据包，再将新的 UDP 数据包交给网络层；\n网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；\n数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层；\n在传输层，数据包中的 UDP 头会被拆开，并根据 UDP 中所提供的端口号，把数据部分交给上层的应用程序\n最终，数据包就发送到了主机 B 上层应用程序这里。\n\nUDP和TCP有什么区别？\nTCP协议在传送数据段的时候要给段标号；UDP协议不；\nTCP协议可靠；UDP协议不可靠；\nTCP协议是面向连接；UDP协议采用无连接；\nTCP协议负载较高，采用虚电路；UDP采用无连接；\nTCP协议的发送方要确认接收方是否收到数据段（3次握手协议）；\nTCP协议采用窗口技术和流控制。\n\n\n\n\n特性\nTCP\nUDP\n\n\n\n是否连接\n面向连接\n面向非连接\n\n\n传输可靠性\n可靠\n不可靠\n\n\n应用场合\n传输大量数据\n传输少量数据\n\n\n速度\n慢\n快\n\n\nTCP传输的详细过程是怎样的？进行三次握手，建立TCP连接。\n\n\n第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；\n第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；\n第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，，完成TCP三次握手。 完成了三次握手，客户端和服务器端就可以开始传送数据。\n\nACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。 TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。（ACK：确认字符）SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。（SYN：同步序列编号）FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。\n\n发送HTTP请求，服务器处理请求，返回响应结果TCP连接建立后，浏览器就可以利用HTTP／HTTPS协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200。\n关闭TCP连接![image-20230410171051659](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230410171051659.png)\n\n第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；\n第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；\n第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；\n第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。\n\nMSL：报文最大生存时间。是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。\n\n为什么“握手”是三次，“挥手”却要四次？TCP建立连接时之所以只需要”三次握手”，是因为在第二次”握手”过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。\n即SYN建立连接报文与ACK确认接收报文是在同一次”握手”当中传输的，所以”三次握手”不多也不少，正好让双方明确彼此信息互通。\nTCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次”握手”传输的。为何建立连接时一起传输，释放连接时却要分开传输？\n\n建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。\n释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。\n\n为什么客户端在TIME-WAIT阶段要等2MSL?为的是确认服务器端是否收到客户端发出的ACK确认报文\n当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。\n服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；\n\n如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；\n否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。\n\n所以，客户端要经历时长为2SML的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因\n为什么很多站点第二次打开速度会很快？主要原因是第一次加载页面过程中，缓存了一些耗时的数据。 那么，哪些数据会被缓存呢？\nDNS缓存主要就是在浏览器本地把对应的 IP 和域名关联起来，这样在进行DNS解析的时候就很快。\nMemoryCache是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。内存缓存是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内存里的数据也将不复存在。\n浏览器缓存浏览器缓存，也称Http缓存，分为强缓存和协商缓存。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。\n强缓存强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。\n实现强缓存，过去我们一直用expires。当服务器返回响应时，在 Response Headers 中将&#x3D;&#x3D;过期时间&#x3D;&#x3D;写入 expires 字段。像这样\nexpires: Wed, 12 Sep 2019 06:12:18 GMT\n\n可以看到，&#x3D;&#x3D;expires 是一个时间戳&#x3D;&#x3D;，接下来如果我们试图再次向服务器请求资源，浏览器就会先对&#x3D;&#x3D;比本地时间&#x3D;&#x3D;和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。\n从这样的描述中大家也不难猜测，expires 是有问题的，它最大的问题在于对“本地时间”的依赖。如果服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么 expires 将无法达到我们的预期。\n考虑到 expires 的局限性，HTTP1.1 新增了Cache-Control字段来完成 expires 的任务。expires 能做的事情，&#x3D;&#x3D;Cache-Control&#x3D;&#x3D; 都能做；expires 完成不了的事情，Cache-Control 也能做。因此，Cache-Control 可以视作是 expires 的完全替代方案。在当下的前端实践里，我们继续使用 expires 的唯一目的就是向下兼容。\ncache-control: max-age=31536000\n\n在 Cache-Control 中，我们通过max-age来控制资源的有效期。max-age 不是一个时间戳，而是一个&#x3D;&#x3D;时间长度&#x3D;&#x3D;。在本例中，max-age 是 31536000 秒，它意味着该资源在 31536000 秒以内都是有效的，完美地规避了时间戳带来的潜在问题。\nCache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。\n协商缓存协商缓存依赖于服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。\n协商缓存的实现,从 Last-Modified 到 Etag,Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：\nLast-Modified: Fri, 27 Oct 2017 06:35:57 GMT\n\n随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：\nIf-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT\n\n服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段。\n使用 Last-Modified 存在一些弊端，这其中最常见的就是这样两个场景：\n\n我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。\n\n当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。\n\n\n这两个场景其实指向了同一个 bug——服务器并没有正确感知文件的变化。为了解决这样的问题，Etag 作为 Last-Modified 的补充出现了。\n&#x3D;&#x3D;Etag &#x2F; If-None-Match&#x3D;&#x3D;\nEtag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串可以是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。\nEtag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。正如我们刚刚所提到的——Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。\nEtag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。\nService Worker CacheService Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们&#x3D;&#x3D;实现离线缓存、消息推送和网络代理&#x3D;&#x3D;等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。\nService Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实现离线存储的重要先决条件.\nPush CachePush Cache 是指 HTTP2 在 server push 阶段存在的缓存。这块的知识比较新，应用也还处于萌芽阶段，应用范围有限不代表不重要——HTTP2 是趋势、是未来。在它还未被推而广之的此时此刻，我仍希望大家能对 Push Cache 的关键特性有所了解：\n\nPush Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。\nPush Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。\n不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。\n\n原文地址：浏览器相关原理(面试题)详细总结一\n","categories":["浏览器"],"tags":["浏览器"]},{"title":"浏览器渲染引擎与阻塞","url":"/2019/03/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E4%B8%8E%E9%98%BB%E5%A1%9E/","content":" \n\n浏览器渲染引擎与阻塞一、浏览器渲染引擎主要模块\n一个渲染引擎主要包括：HTML解析器，CSS解析器，javascript引擎，布局layout模块，绘图模块\nHTML解析器：解释HTML文档的解析器，主要作用是将HTML文本解释成DOM树。\nCSS解析器：它的作用是为DOM中的各个元素对象计算出样式信息，为布局提供基础设施。\nJavascript引擎：使用Javascript代码可以修改网页的内容，也能修改css的信息，javascript引擎能够解释javascript代码，并通过DOM接口和CSS树接口来修改网页内容和样式信息，从而改变渲染的结果。\n布局（layout）：在DOM创建之后，Webkit需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能表达这所有信息的内部表示模型。\n绘图模块（paint）：使用图形库将布局计算后的各个网页的节点绘制成图像结果。\n\n大致的渲染过程\n浏览器渲染页面的整个过程：浏览器会从上到下解析文档。\n遇见 HTML 标记，调用HTML解析器解析为对应的 token （一个token就是一个标签文本的序列化）并构建 DOM 树（就是一块内存，保存着tokens，建立它们之间的关系）。\n遇见 style&#x2F;link 标记调用相应解析器处理CSS标记，并构建出CSS样式树。\n遇见 script 标记 调用javascript引擎 处理script标记、绑定事件、修改DOM树&#x2F;CSS树等\n将 DOM树 与 CSS树 合并成一个渲染树。\n根据渲染树来渲染，以计算每个节点的几何信息（这一过程需要依赖GPU）。\n最终将各个节点绘制到屏幕上。\n\n以上这些模块依赖很多其他的基础模块，包括要使用到网络 存储 2D&#x2F;3D图像 音频视频解码器 和 图片解码器。\n所以渲染引擎中还会包括如何使用这些依赖模块的部分。\n二、阻塞渲染1.关于css阻塞声明：只有link引入的外部css才能够产生阻塞。\n1.style标签中的样式：\n​     (1). 由html解析器进行解析（异步解析）；\n​     (2). 不阻塞浏览器渲染（可能会产生“闪屏现象”）；\n​     (3). 不阻塞DOM解析；\n2.link引入的外部css样式（推荐使用的方式）：\n​    (1). 由CSS解析器进行解析（同步解析）。\n​    (2). 阻塞浏览器渲染(可以利用这种阻塞避免“闪屏现象”)。 \n​    (3). 阻塞其后面的js语句的执行。\n​    (4). 不阻塞DOM的解析(绝大多数浏览器的工作方式)。\n3.优化核心理念：尽可能快的提高外部css加载速度\n​    (1).使用CDN节点进行外部资源加速。\n​    (2).对css进行压缩(利用打包工具，比如webpack,gulp等)。\n​    (3).减少http请求数，将多个css文件合并。\n​    (4).优化样式表的代码\n2.关于js阻塞1.阻塞后续DOM解析:\n​        原因：浏览器不知道后续脚本的内容，如果先去解析了下面的DOM，而随后的js删除了后面所有的DOM，那么浏览器就做了无用功，浏览器无法预估脚本里面具体做了什么操作，例如像document.write，这种操作，索性全部停住，等脚本执行完了，浏览器再继续向下解析DOM。  \n2.阻塞页面渲染:\n​        原因：js中也可以给DOM设置样式，浏览器等该脚本执行完毕，渲染出一个最终结果，避免做无用功。\n3.阻塞后续js的执行:\n​        原因：维护依赖关系，例如：必须先引入jQuery再引入bootstrap\nasync：\n当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，脚本下载完成后开始执行脚本，脚本执行的过程中文档将停止解析，直到脚本执行完毕。\ndefer：当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，待到&#x3D;&#x3D;文档解析完成&#x3D;&#x3D;，脚本才会执行。\n3.备注​    【备注1】：css的解析和js的执行是互斥的（互相排斥），css解析的时候js停止执行，js执行的时候css停止解析。\n​    【备注2】：无论css阻塞，还是js阻塞，都不会阻塞浏览器加载外部资源（图片、视频、样式、脚本等）。\n​             原因：浏览器始终处于一种：“先把请求发出去”的工作模式，只要是涉及到网络请求的内容，无论是：图片、样式、脚本，都会先发送请求去获取资源，至于资源到本地之后什么时候用，由浏览器自己协调。这种做法效率很高。\n​    【备注3】：WebKit 和 Firefox 都进行了【预解析】这项优化。\n​            在执行js脚本时，浏览器的其他线程会预解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树\n在上述的过程中，网页在加载和渲染过程中会触发“DOMContentLoaded”和“onload”事件；\n分别是在DOM树构建（解析）完成之后，以及DOM树构建完并且网页所依赖的资源都加载完之后。\n上面介绍的是一个完整的渲染过程，但现代网页很多都是动态的，这意味着在渲染完成之后，由于网页的动画或者用户的交互， 浏览器其实一直在不停地重复执行渲染过程。（重绘重排），以上的数字表示的是基本顺序，这不是严格一致的，这个过程可能重复也可能交叉。\n","categories":["浏览器"],"tags":["浏览器"]},{"title":"TCP三次握手四次挥手","url":"/2019/03/16/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","content":" \n\nTCP的三次握手和四次挥手实质就是TCP通信的连接和断开。\n\n\n1.三次握手​\t\tTCP协议位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略。\n&#x3D;&#x3D;三次握手原理：&#x3D;&#x3D;\n\n第1次握手：客户端发送一个带有SYN（synchronize）标志的数据包给服务端；\n\n第2次握手：服务端接收成功后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示收到了；\n\n第3次握手：客户端再回传一个带有ACK标志的数据包，握手结束。\n\n\n其中：SYN标志位数置1，表示建立TCP连接；ACK标志表示验证字段。\n\nACK：此标志表示应答域有效。TCP应答号将会包含在TCP数据包中。\n​\t\t\t有两个取值：0和1，1表示应答域有效，反之为0。\nSYN(SYNchronization) ：\n​\t\t在连接建立时用来同步序号。SYN置1就表示这是一个连接请求或连接接受报文。\n​\t\t当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文；\n​\t\tSYN&#x3D;1和ACK&#x3D;1，对方同意建立连接。\n\n可通过以下趣味图解理解三次握手：\n\n\n三次握手详细说明：\n\n第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；\n第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；\n第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，，完成TCP三次握手。 完成了三次握手，客户端和服务器端就可以开始传送数据。\n\n2.四次挥手​\t\t由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。\n&#x3D;&#x3D;四次挥手原理：&#x3D;&#x3D;\n\n第1次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态；\n\n第2次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1\n​\t\t\t\t\t（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态；\n​\t\t\t\t\t\t客户端进入FIN_WAIT_2状态\n\n第3次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态；\n\n第4次挥手：客户端收到FIN后，客户端t进入TIME_WAIT状态，接着发送一个ACK给Server，\n​\t\t\t\t\t 确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手。\n\n\n其中：FIN（finis）标志位数置1，表示断开TCP连接。\n可通过以下趣味图解理解四次挥手：\n\n\n\n\n\nLISTEN：等待从任何远端TCP 和端口的连接请求。\nSYN_SENT：发送完一个连接请求后等待一个匹配的连接请求。\nSYN_RECEIVED：发送连接请求并且接收到匹配的连接请求以后等待连接请求确认。\nESTABLISHED：表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态。\nFIN_WAIT_1：等待远端TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认。\nFIN_WAIT_2：等待远端TCP 的连接终止请求。\nCLOSE_WAIT：等待本地用户的连接终止请求。\nCLOSING：等待远端TCP 的连接终止请求确认。\nLAST_ACK：等待先前发送给远端TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认）\nTIME_WAIT：等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认。TIME_WAIT 两个存在的理由：          1.可靠的实现tcp全双工连接的终止；          2.允许老的重复分节在网络中消逝。\nCLOSED：不在连接状态（这是为方便描述假想的状态，实际不存在）\n\n3.为什么需要三次握手，两次不行吗？弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。\n\n第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。\n第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时&#x3D;&#x3D;服务器并不能确认客户端的接收能力是否正常&#x3D;&#x3D;。\n第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。\n\n另一个种解释：\n\n因为某些原因，S没有收到C的包，过了一段时间后才收到，S认为这是两个请求，而C认为是一个请求，从而在2次握手后进入等待状态，造成状态不一致。\n\n如果在3次握手的状态下，S收不到最后的ACK包，自然不会认为连接建立成功。\n\n所以3次握手，就是为了解决网络信道不可靠的问题。\n\n\n因此，需要三次握手才能确认双方的接收与发送能力是否正常。\n\n\n\n\n4.三次握手过程中可以携带数据吗？其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据\n为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。\n也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。\n5.挥手为什么需要四次？因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。\n6.为什么客户端需要等待超时时间这是为了保证对方已经收到ACK。\n\n因为假设客户端发送完最后一份ACK后，就释放了链接，一旦ack包在网络中丢失，服务端将一直停留在最后的确认状态。\n如果客户端发行完最后一份ACK后，等待一段时间，这时服务端又没有收到ACK，会重发FIN包，客户端会响应这个FIN包，重发ACK包，并刷新超时时间，也是为了保证在不可靠的网络链路中进行可靠的链接断开确认\n\n浏览器相关原理(面试题)详细总结一\n","categories":["网络"],"tags":["网络","HTTP"]},{"title":"浏览器的组成与功能","url":"/2019/02/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8A%9F%E8%83%BD/","content":" \n\n浏览器的组成与功能浏览器的内核(渲染引擎)浏览器中有一个最重要的模块，它主要的作用把一切请求回来的资源变为可视化的图像。 这个模块就是浏览器内核，通常它也被称为渲染引擎。 \n浏览器内核总结： IE———-&gt;Trident\nSafari——&gt;WebKit\n​        WebKit本身主要是由两个小引擎构成的，                一个正是渲染引擎“WebCore”，\n                另一个则是javascript解释引擎“JSCore”，\n                它们均是从KDE的渲染引擎KHTML及javascript解释引擎KJS衍生而来。\nChrome——&gt;WebKit的分支引擎—–&gt;Blink\n​        在13年发布的Chrome 28.0.1469.0版本开始，Chrome放弃Chromium引擎转而使用最新的Blink引擎（基于WebKit2——苹果公司于2010年推出的新的WebKit引擎），Blink对比上一代的引擎精简了代码、改善了DOM框架，也提升了安全性。\nOpera——&gt;Blink\n​        Opera在2013年2月宣布放弃Presto:        采用Chromium引擎;        又转为Blink引擎;\nFirefox——&gt;Gecko\n进程与线程进程：​        程序的一次执行, 它占有一片独有的内存空间.是操作系统执行的基本单元。\n​        一个进程中至少有一个运行的线程: 主线程, 进程启动后自动创建。\n​        一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的。\n​        一个进程内的数据可以供其中的多个线程直接共享，多个进程之间的数据是不能直接共享的。\n线程：​        是进程内的一个独立执行单元,是CPU调度的最小单元。程序运行的基本单元。\n​        线程池(thread pool): 保存多个线程对象的容器, 实现线程对象的反复利用。\nJS引擎是单线程运行的！（回忆事件轮询机制）现代浏览器：多进程、多线程模型1.不堪回首的过去:​        当你通过浏览器打开很多页面的时候,如果其中一个页面不响应了或者崩溃了,\n​        那么随之而来的将会是更不幸的事情,你开打的所有页面都会得不到响应,\n​        最让人不能忍受的是,其中的一些页面可能还包含了未保存或者未发送的信息。\n2.浏览器产商如何解决？​        采用多进程模型,该模型可以带来的好处：\n​        ①.避免因单个页面的不响应或者崩溃影响整个浏览器的稳定性；\n​        ②.当第三方插件崩溃时,也不会影响整个浏览器的稳定性；\n​        ③.安全\n3.浏览器到底有些什么进程​        ①.Browser进程:\n​            浏览器的主进程,负责浏览器界面的显示,和各个页面的管理,\n​            浏览器中所有其他类型进程的祖先,负责其他进程的的创建和销毁，\n​            它有且只有一个!!!!!\n​        ②.Renderer进程:\n​            网页渲染进程,负责页面的渲染,可以有多个；\n​            当然渲染进程的数量不一定等于你开打网页的个数。\n​        ③.各种插件进程\n​        ④.GPU进程：​            移动设备的浏览器可能不太一样:\n​                Android不支持插件,所以就没有插件进程；\n​                GPU演化成了Browser进程的一个线程；\n​                Renderer进程演化成了操作系统的一个服务进程,它仍然是独立的。\n4.每个进程内部又有很多线程​        多线程的目的主要是保持用户界面的高度响应。\n​        例如:为了不让Browser进程的UI线程被其他耗时的操作(大文件的加载,本地文件读写)所阻塞,\n​                那么我们就把这些操作放到分线程中去处理。\n​        在Renderer进程中,为了不让其他操作阻止渲染线程的高速执行,我们通常会将渲染过程【管线化】,\n​        利用计算机的多核优势,让渲染的不同阶段在不同的线程中执行\n","categories":["浏览器"],"tags":["浏览器"]},{"title":"图层的重绘与回流","url":"/2019/05/09/%E5%9B%BE%E5%B1%82%E7%9A%84%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/","content":" \n\n图层的重绘与回流css图层览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。\n在渲染DOM的时候，浏览器所做的工作实际上是：\n1. 获取DOM后分割为多个图层；\n2. 对每个图层的节点计算样式结果    （Recalculate style--样式重计算）\n3. 为每个节点生成图形和位置     （Layout--布局，重排,回流）\n4. 将每个节点绘制填充到图层位图中   （Paint--重绘）\n5. 图层作为纹理上传至GPU\n6. 组合多个图层到页面上生成最终屏幕图像  （Composite Layers--图层重组）\n\n图层创建的条件Chrome浏览器满足以下任意情况就会创建图层：\n 1. 拥有具有3D变换的CSS属性（tansform: translateZ(0)）;\n 2. 使用加速视频解码的&lt;video&gt;节点;\n 3. \\&lt;canvas\\&gt;节点;\n 4. CSS3动画的节点;\n 5. 拥有CSS加速属性的元素(will-change)【will-change：transform】\n\n重绘(Repaint)重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。\n需要注意的是：重绘重排都是以图层为单位，如果图层中某个元素需要重绘，那么整个图层都需要重绘。所以为了提高性能，我们应该让这些“变化的东西”拥有一个自己一个图层，不过好在绝大多数的浏览器自己会为CSS3动画的节点自动创建图层。\n重排(Reflow 又称：回流)渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排\n“重绘”不一定需要”重排”，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。\n“重排”大多数情况下会导致”重绘”，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。\n触发重绘的属性* color             * background                * outline-color* border-style      * background-image          * outline* border-radius     * background-position       * outline-style* visibility        * background-repeat         * outline-width* text-decoration   * background-size           * box-shadow\n\n触发重排(回流)的属性* width           * top                  * text-align* height          * bottom               * overflow-y* padding         * left                 * font-weight* margin          * right                * overflow* display         * position             * font-family* border-width    * float                * line-height* border          * clear                * vertival-align* min-height                             * white-space\n\n常见的触发重排的操作Reflow(重排) 的成本比 Repaint(重绘) 的成本高很多很多。\n一个结点的 Reflow 很有可能导致子结点，甚至父点以及同级结点的 Reflow。\n在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。\n所以，下面这些动作有很大可能会是成本比较高的。\n​        当你增加、删除、修改 DOM 结点时，会导致 Reflow , Repaint。\n​        当你移动 DOM 的位置。\n​        当你修改 CSS 样式的时候。\n​        当你 Resize 窗口的时候（移动端没有这个问题，因为移动端的缩放没有影响布局视口)。\n​        当你修改网页的默认字体时。【获取某些属性时(width,height…)！！！！！】\n注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发生位置变化。\n优化方案（重绘重排）我们已知：浏览器渲染页面时经历了如下“细致”的环节：\n1. 计算需要被加载到节点上的样式结果（Recalculate style--样式重计算）；\n2. 为每个节点生成图形和位置（Layout--重排或回流）；\n3. 将每个节点填充到图层中（Paint--重绘）；\n4. 组合图层到页面上（Composite Layers--图层重组）\n\n如果我们需要提升性能，需要做的就是减少浏览器在运行时所需要做的工作，即：尽量减少1234步。\n【具体优化方案如下】：1.元素位置移动变换时尽量使用CSS3的transform来代替对top left等的操作。\n​    变换（transform）和透明度（opacity）的改变仅仅影响图层的组合\n2.使用opacity来代替visibility\n​    (1).使用visibility不触发重排，但是依然重绘。\n​    (2).直接使用opacity既触发重绘，又触发重排（GPU底层设计如此！）。\n​    (3).opacity配合图层使用，既不触发重绘也不触发重排。\n​        原因：\n​                透明度的改变时，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并不需要整体的重绘。\n​                不过这个前提是这个被修改opacity本身必须是一个图层。\n3.不要使用table布局。\n​    table-cell；\n4.将多次改变样式属性的操作合并成一次操作。\n​    不要一条一条地修改DOM的样式，预先定义好class，然后修改DOM的className；\n5.将DOM离线后再修改。\n​    由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。\n​    如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。\n6.利用文档碎片。\n​    (documentFragment)——vue使用了该种方式提升性能。\n7.不要把获取某些DOM节点的属性值放在一个循环里当成循环的变量\n​    当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如：\n 1. offsetTop, offsetLeft, offsetWidth, offsetHeight\n 2. scrollTop/Left/Width/Height\n 3. clientTop/Left/Width/Height\n 4. width,height\n\n​    当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要刷新内部队列，\n​    因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。\n8.动画实现过程中，启用GPU硬件加速:transform: tranlateZ(0)。\n9.为动画元素新建图层,提高动画元素的z-index\n10.编写动画时，尽量使用如下的API：\nrequestAnimationFrame—-请求动画帧1.window.requestAnimationFrame()\n说明：该方法会告诉浏览器在下一次重绘重排之前调用你所指定的函数。\n①参数：\n​        该方法使用一个回调函数作为参数，这个回调函数会在浏览器下一次重绘之前调用。\n​        回调函数会被自动传入一个参数，DOMHighResTimeStamp，标识requestAnimationFrame()开始触发回调函数的当前时间\n②返回值：\n​            一个 long 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。你可以传这个值给 window.cancelAnimationFrame() 以取消回调函数。\n备注：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()\n2.window.cancelAnimationFrame(requestID)\n​        取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。\n​        requestID是先前调用window.requestAnimationFrame()方法时返回的值，它是一个时间标识，用法与定时器的id类似。\n","categories":["浏览器"],"tags":["缓存","浏览器"]},{"title":"细说浏览器输入URL后发生了什么","url":"/2019/04/28/%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/","content":" \n\n细说浏览器输入URL后发生了什么大体上，可以分为六步，当然每一步都可以详细都展开来说，这里先放一张总览图:\n\n1. 合成URL​\t\t用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引警合成新的URL， 如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL\n2. DNS域名解析​\t\t在网络世界，你肯定记得住网站的名称，但是很难记住网站的 IP 地址，因而也需要一个地址簿，就是 DNS 服务器。DNS 服务器是高可用、高并发和分布式的，它是树状结构，如图：\n\n根域名：www.baidu.com 的完整写法是 www.baidu.com.最后的这个 . 就是根域名。（下一级是顶级域名）\n顶级域 ：com, cn、org、edu 等。（下一级是权威 DNS 服务器）\n权威 DNS 服务器：返回主机 - IP 的最终映射。\n\n\n\n\n根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址\n顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址\n权威 DNS 服务器 ：返回相应主机的 IP 地址\n\nDNS的域名查找，在客户端和浏览器，本地DNS之间的查询方式是递归查询；\n在本地DNS服务器与根域及其子域之间的查询方式是迭代查询；\n递归过程：\n![image-20230410214854082](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230410214854082.png)\n​\t\t在客户端输入 URL 后，会有一个递归查找的过程，&#x3D;&#x3D;从浏览器缓存中查找 -&gt; 本地的hosts文件查找 -&gt; 找本地DNS解析器缓存查找 -&gt; 本地DNS服务器查找&#x3D;&#x3D;，这个过程中任何一步找到了都会结束查找流程。\n​\t\t如果本地DNS服务器无法查询到，则根据本地DNS服务器设置的转发器进行查询。若未用转发模式，则迭代查找过程如下图：\n\n\n结合起来的过程，可以用一个图表示：\n\n\n在查找过程中，有以下优化点：\n\nDNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。\n\n在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。\n\n\n3. 建立TCP连接​\t\t首先，判断是不是https的，如果是，则HTTPS其实是HTTP + SSL &#x2F; TLS 两部分组成，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。\n进行&#x3D;&#x3D;三次握手&#x3D;&#x3D;，建立TCP连接。\n\n第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；\n第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；\n第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。\n\nSSL握手过程\n\n第一阶段：建立安全能力，包括协议版本、会话Id、密码构件、压缩方法和初始随机数；\n第二阶段：服务器发送证书，密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号；\n第三阶段：如果有证书请求客户端发送此证书，之后客户端发送密钥交换数据，也可以发送证书验证消息；\n第四阶段：变更密码构件和结束握手协议\n\n完成了之后，客户端和服务器端就可以开始传送数据。更多 HTTPS 的资料可以看这里：\n\n深入理解HTTPS原理、过程与实践\n解析HTTPS\n\n备注\nACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。TCP协议规定，只有ACK&#x3D;1时有效，也规定连接建立后所有发送的报文的ACK必须为1。\nSYN(SYNchronization)：在连接建立时用来同步序号。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN&#x3D;1和ACK&#x3D;1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。\nFIN(finis）即完，终结的意思， 用来释放一个连接。当 FIN &#x3D; 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。\n4. 发送HTTP请求，服务器处理请求，返回响应结果​\t\tTCP连接建立后，浏览器就可以利用HTTP／HTTPS协议向服务器发送请求了。服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200.\n这里有发生的一个过程是HTTP缓存，是一个常考的考点，大致过程如图：\n其过程，比较多内容，可以参考我的这篇文章《浏览器相关原理(面试题)详细总结一》，这里我就不详细说了～\n5.关闭TCP连接\n第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；\n\n第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我”同意”你的关闭请求；\n\n第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；\n\n第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。\n\n\n6.浏览器渲染按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示。如图：\n![image-20230410220321066](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230410220321066.png)\n\n渲染进程将 HTML 内容转换为能够读懂DOM 树结构。\n渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。\n创建布局树，并计算元素的布局信息。\n对布局树进行分层，并生成分层树。\n为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。\n合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。\n\n6.1 构建 DOM 树浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程将字节解析为DOM树，先将HTML的原始字节数据转换为文件指定编码的字符，然后浏览器会根据HTML规范来将字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树。\n![image-20230410220818656](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230410220818656.png)\n具体步骤：\n\n转码（Bytes -&gt; Characters）—— 读取接收到的 HTML 二进制数据，按指定编码格式将字节转换为 HTML 字符串；\nTokens 化（Characters -&gt; Tokens）—— 解析 HTML，将 HTML 字符串转换为结构清晰的 Tokens，每个 Token 都有特殊的含义同时有自己的一套规则；\n构建 Nodes（Tokens -&gt; Nodes）—— 每个 Node 都添加特定的属性（或属性访问器），通过指针能够确定 Node 的父、子、兄弟关系和所属 treeScope；\n构建 DOM 树（Nodes -&gt; DOM Tree）—— 最重要的工作是建立起每个结点的父子兄弟关系\n\n6.2 样式计算渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。\nCSS 样式来源主要有 3 种，分别是通过 link 引用的外部 CSS 文件、style标签内的 CSS、元素的 style 属性内嵌的 CSS。,其样式计算过程主要为：\n可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。处理完成后再处理样式的继承和层叠，有些文章将这个过程称为CSSOM的构建过程。\n6.3 页面布局布局过程，即排除 script、meta 等功能化、非视觉节点，排除 display: none 的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。如图：\n![image-20230410221008150](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230410221008150.png)\n![image-20230410220939974](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230410220939974.png)\n其中，这个过程需要注意的是回流和重绘，关于回流和重绘，详细的可以看我另一篇文章《浏览器相关原理(面试题)详细总结二》，这里就不说了～\n6.4 生成分层树页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree），如图：\n![image-20230410221057683](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230410221057683.png)\n如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。在浏览器中，你可以打开 Chrome 的”开发者工具”，选择”Layers“标签。渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。\n并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？详细的可以看我另一篇文章《浏览器相关原理(面试题)详细总结二》，这里就不说了～\n栅格化合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。如图：\n\n\n通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。\n显示最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成。\n原文地址：细说浏览器输入URL后发生了什么\n","categories":["网络"],"tags":["网络","HTTP"]},{"title":"网络安全","url":"/2019/05/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/","content":" \n\n1. XSSXSS（Cross Site Script），即&#x3D;&#x3D;跨站脚本攻击&#x3D;&#x3D;；\nXSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。\n攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。\nXSS攻击可以分为3类：\n\n反射型（非持久型）\n存储型（持久型）\n基于DOM。\n\n1.1 反射型反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。\n攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如cookie)的脚本，这取决于攻击者的目的。\n1.2 存储型存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。\n比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。\n当用户点击提交按钮将输入信息提交到服务端时，服务端通过 userInput 变量保存了输入内容。当用户通过 http://localhost:8001/$&#123;id&#125; 访问时，服务端会返回与 id 对应的内容(本示例简化了处理)。如果用户输入了恶意脚本内容，则其他用户访问该内容时，恶意脚本就会在浏览器端执行：\n1.3 基于DOM基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。\n看如下代码：\n&lt;h2&gt;XSS: &lt;/h2&gt;&lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;&lt;button id=&quot;btn&quot;&gt;Submit&lt;/button&gt;&lt;div id=&quot;div&quot;&gt;&lt;/div&gt;&lt;script&gt;    const input = document.getElementById(&#x27;input&#x27;);    const btn = document.getElementById(&#x27;btn&#x27;);    const div = document.getElementById(&#x27;div&#x27;);    let val;         input.addEventListener(&#x27;change&#x27;, (e) =&gt; &#123;        val = e.target.value;    &#125;, false);    btn.addEventListener(&#x27;click&#x27;, () =&gt; &#123;        div.innerHTML = `&lt;a href=$&#123;val&#125;&gt;testLink&lt;/a&gt;`    &#125;, false);&lt;/script&gt;\n\n点击 Submit 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容：\n&#x27;&#x27; onclick=alert(/xss/)\n\n用户提交之后，页面代码就变成了：\n&lt;a href onlick=&quot;alert(/xss/)&quot;&gt;testLink&lt;/a&gt;\n\n此时，用户点击生成的链接，就会执行对应的脚本：\n2. XSS 攻击的防范现在主流的浏览器内置了防范 XSS 的措施，例如 CSP。但对于开发者来说，也应该寻找可靠的解决方案来防止 XSS 攻击。\n2.1 HttpOnly 防止劫取 CookieHttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。\n上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。\n2.2 输入检查不要相信用户的任何输入。 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。\n在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 &lt;，&gt; 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。\n而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 &lt;，&gt;，script，防止 XSS 攻击：\nconst decodingMap = &#123;  &#x27;&amp;lt;&#x27;: &#x27;&lt;&#x27;,  &#x27;&amp;gt;&#x27;: &#x27;&gt;&#x27;,  &#x27;&amp;quot;&#x27;: &#x27;&quot;&#x27;,  &#x27;&amp;amp;&#x27;: &#x27;&amp;&#x27;,  &#x27;&amp;#10;&#x27;: &#x27;\\n&#x27;&#125;\n\n\n\n2.3 输出检查用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。\n3. CSRFCSRF（ Cross Site Request Forgery），中译是&#x3D;&#x3D;跨站请求伪造&#x3D;&#x3D;，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。\n通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。\n在举例子之前，先说说浏览器的 Cookie 策略。\n3.1 浏览器的 Cookie 策略Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。Cookie 主要用于以下三个方面：\n\n会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\n个性化设置（如用户自定义设置、主题等）\n浏览器行为跟踪（如跟踪分析用户行为等）\n\n而浏览器所持有的 Cookie 分为两种：\n\nSession Cookie(会话期 Cookie)：会话期 Cookie 是最简单的Cookie，它不需要指定过期时间（Expires）或者有效期（Max-Age），它仅在会话期内有效，浏览器关闭之后它会被自动删除。\nPermanent Cookie(持久性 Cookie)：与会话期 Cookie 不同的是，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。\n\nres.setHeader(&#x27;Set-Cookie&#x27;, [&#x27;mycookie=222&#x27;, &#x27;test=3333; expires=Sat, 21 Jul 2018 00:00:00 GMT;&#x27;]);\n\n上述代码创建了两个 Cookie：mycookie 和 test，前者属于会话期 Cookie，后者则属于持久性 Cookie。当我们去查看 Cookie 相关的属性时，不同的浏览器对会话期 Cookie 的 Expires 属性值会不一样：\nFirefox：\n![image-20230414081138509](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230414081138509.png)\nChrome:\n![image-20230414081204646](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230414081204646.png)\n此外，每个 Cookie 都会有与之关联的域，这个域的范围一般通过 donmain 属性指定。如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie（first-party cookie），如果 Cookie 的域和页面的域不同，则称之为第三方 Cookie（third-party cookie）。一个页面包含图片或存放在其他域上的资源（如图片）时，第一方的 Cookie 也只会发送给设置它们的服务器。\n3.2 通过 Cookie 进行 CSRF 攻击由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。\n但若 CSRF 攻击的目标并不需要使用 Cookie，则也不必顾虑浏览器的 Cookie 策略了。\n4. CSRF 攻击的防范当前，对 CSRF 攻击的防范措施主要有如下几种方式。\n\n验证码\nreferer check\n添加 token 验证\n\n4.1 验证码验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。\n从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。\n但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。\n4.2 Referer Check根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。\n比如，如果用户要删除自己的帖子，那么先要登录 www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 http://www.c.com；当请求是从 www.a.com 发起时，Referer 的值是 http://www.a.com 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 www.c.com 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。\nReferer Check 不仅能防范 CSRF 攻击，另一个应用场景是 “防止图片盗链”。\n4.3 添加 token 验证CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。\n总结XSS攻击可以分为3类：\n\n反射型（非持久型）：诱导用户点击恶意链接；\n\n存储型（持久型）：攻击者在论坛上写下一篇包含恶意 脚本的文章或评论，用户访问后，会在他们的浏览器中执行这段恶意的脚本。\n\n基于DOM：通过恶意脚本修改页面的 DOM 结构\n\n\n总结一下 XSS 攻击和 CSRF 攻击的常见防御措施：\n\n防御 XSS 攻击\n\nHttpOnly 防止劫取 Cookie。（浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。）\n用户的输入检查。（对于用户的任何输入要进行检查、过滤和转义，对特殊字符进行过滤或编码）\n服务端的输出检查\n\n\n防御 CSRF 攻击\n\n验证码\nReferer Check\nToken 验证\n\n\n\n👉👉 浅说 XSS 和 CSRF\n","categories":["安全"],"tags":["网络","安全"]},{"title":"性能优化总结","url":"/2019/07/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/","content":" \n\n\n\ncss 和 js 优化\n\n减少css和js阻塞；\n优化样式表的代码（选择器的权重）；\n异步加载js（ script 标签加上 defer 属性），放在页面底部；\n对css、js进行压缩；\n减少http请求数，将多个css、js文件合并。\n\n\n使用CDN节点进行外部资源加速。\n\n图片优化\n\n使用字体图标代替图片图标\n图片使用CSS雪碧图\n图片懒加载\n响应式图片。根据屏幕大小自动加载合适的图片\n图片压缩\n\n\n减少重绘和回流\n\n元素位置移动变换时尽量使用transform\n用opacity来代替visibility（opacity配合图层使用，既不触发重绘也不触发重排）\n将多次改变样式属性的操作合并成一次操作。（预先定义好class，然后修改DOM的className）\n将DOM离线后再修改（先隐藏它，操作完成后再显示，这样只在隐藏和显示时触发2次重排）\n利用文档碎片。（documentFragment）\n动画实现过程中，启用GPU硬件加速:transform: tranlateZ(0)。\n使用requestAnimationFrame(cb) （请求动画帧：回调函数会在浏览器下一次重绘之前调用。）\n\n\n使用事件委托。（利用事件冒泡，可以管理某一类型的所有事件，可以节省内存）\n\n强缓存\n\nExpires\ncache-control: max-age &#x3D; number\n\n\n协商缓存\n\nLast-Modified&#x2F;If-Modified-Since\nEtag&#x2F;If-None-Match\n\n\nStorage\n\n资源预加载\n\n prefetch 是利用浏览器的空闲时间，加载页面将来可能用到的资源的一种机制；通常可以用于加载其他页面（非首页）所需要的资源，以便加快后续页面的打开速度\n 在后台预加载具有高优先级的资源，对于在几秒钟内预加载您需要的资源非常有用\n\n\nwebpack打包优化\n\n**alias**：起别名，减少查找过程\n\n后缀尝试列表要尽可能的小，导入文件时尽可能的带上后缀，避免寻找过程（extensions）\n\ninclude 缩小打包范围\n\nGzip 对文件进行压缩，能大大提高首屏加载速度\n\n总体优化\n\n异步加载或按需加载\n路由懒加载（实现：ES6动态加载模块import() ）\n服务端渲染。提高首屏加载速度。\n\n\nDNS预解析。   适用于网页引用了大量其他域名的资源\n\nWeb Worker\n\n作用就是为 JavaScript 创造多线程环境，将一些任务在后台运行。\nWorker 线程完成计算任务，再把结果返回给主线程。\n好处是一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。\n\n\n\n\n","categories":["性能"],"tags":["网络","性能"]},{"title":"网页渲染原理","url":"/2019/06/26/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/","content":" \n\n浏览器相关原理详细总结二浏览器渲染过程是怎样的？按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示。\n\n渲染进程将 HTML 内容转换为能够读懂DOM 树结构。\n渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。\n创建布局树，并计算元素的布局信息。\n对布局树进行分层，并生成分层树。\n为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。\n合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。\n\n浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程将字节解析为DOM树，先将HTML的原始字节数据转换为文件指定编码的字符，然后浏览器会根据HTML规范来将字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树。\n获取css，获取style标签内的css、或者内嵌的css，或者当HTML代码遇见标签时，浏览器会发送请求获得该标签中标记的CSS，当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的styleSheets。\n创建布局树，遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。最后计算 DOM 元素的布局信息，使其都保存在布局树中。\n布局完成过程中，如果有js操作或者其他操作，对元素的颜色，背景等作出改变就会引起重绘，如果有对元素的大小、定位等有改变则会引起回流。\n因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。\n渲染引擎实现图层的绘制，把一个图层的绘制拆分成很多小的绘制指令然后再把这些指令按照顺序组成一个待绘制列表，当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程，合成线程会将图层划分为图块，然后按照视口附近的图块来优先生成位图(实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图)\n一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令，然后将该命令提交给浏览器进程,浏览器最后进行显示。\n如何理解回流和重绘？回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。\n重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。 由此我们可以看出，重绘不一定导致回流，回流一定会导致重绘。\n常见的会导致回流的元素：\n常见的几何属性有 width、height、padding、margin、left、top、border 等等。\n\n最容易被忽略的操作：获取一些需要通过即时计算得到的属性,当你要用到像这样的属性：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight 时，浏览器为了获取这些值，也会进行回流。\n\n当我们调用了 getComputedStyle 方法，或者 IE 里的 currentStyle 时，也会触发回流。原理是一样的，都为求一个“即时性”和“准确性”。\n\n\n避免方式：\n避免逐条改变样式，使用类名去合并样式；\n将 DOM “离线”，使用DocumentFragment；\n提升为合成层，如使用will-change\n\n#divId &#123;  will-change: transform;&#125;\n\n优点\n\n合成层的位图，会交由 GPU 合成，比 CPU 处理要快;\n当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层；\n对于 transform 和 opacity 效果，不会触发 layout 和 paint；\n\n注意：\n部分浏览器缓存了一个 flush 队列，把我们触发的回流与重绘任务都塞进去，待到队列里的任务多起来、或者达到了一定的时间间隔，或者“不得已”的时候，再将这些任务一口气出队。但是当我们访问一些即使属性时，浏览器会为了获得此时此刻的、最准确的属性值，而提前将 flush 队列的任务出队。\n渲染引擎什么情况下才会为特定的节点创建新的图层？层叠上下文是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。\n1、拥有层叠上下文属性的元素会被提升为单独的一层。拥有层叠上下文属性：\n\n根元素 (HTML),\nz-index 值不为 “auto”的 绝对&#x2F;相对定位元素，\nposition,固定（fixed） &#x2F; 沾滞（sticky）定位（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）\nz-index值不为 “auto”的 flex 子项 (flex item)，即：父元素 display: flex|inline-flex\nz-index值不为”auto”的grid子项，即：父元素display：grid\nopacity 属性值小于 1 的元素,\ntransform 属性值不为 “none”的元素，\nmix-blend-mode 属性值不为 “normal”的元素，\nfilter值不为”none”的元素，\nperspective值不为”none”的元素，\nclip-path值不为”none”的元素\nmask &#x2F; mask-image &#x2F; mask-border不为”none”的元素\nisolation 属性被设置为 “isolate”的元素\n在 will-change 中指定了任意CSS属性（参考 这篇文章）\n-webkit-overflow-scrolling 属性被设置 “touch”的元素\ncontain属性值为”layout”，”paint”，或者综合值比如”strict”，”content”\n\n2、需要剪裁（clip）的地方也会被创建为图层。这里的剪裁指的是，假如我们把 div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域。出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。\n","categories":["浏览器"],"tags":["浏览器"]},{"title":"CDN工作原理","url":"/2019/07/22/CDN%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","content":" \n\n\n什么是CDN？工作原理是什么？网站通常将其所有的服务器都放在同一个地方，当用户群增加时，公司就必须在多个地理位置不同的服务器上部署内容。\n为了缩短http请求的时间，我们应该把大量的静态资源放置的离用户近一点。\n&#x3D;&#x3D;内容发布网络CDN（Content Delivery Networks）&#x3D;&#x3D;（也叫内容分发网络）\n​         CDN是一组分布在多个不同地理位置的web服务器，用于更加有效的向用户发布内容。\n基本思路：\n尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。\n\n通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，\n\n&#x3D;&#x3D;CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息&#x3D;&#x3D;\n\n\n​        &#x3D;&#x3D;将用户的请求重新导向离用户最近的服务节点上。&#x3D;&#x3D;\n基础架构：最简单的CDN网络由一个DNS服务器和几台缓存服务器组成。\n用户输入的url，会经过DNS解析“翻译”成对应的ip地址，从而找到CDN专用的服务器。\n\nCDN “拿到” 用户的IP地址，随后和区域负载均衡设备配合，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。\n\n上述步骤中的“选择”依据：\n\n\n​        (1). 选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；\n​        (2). 根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；\n​        (3). 查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。\n当用户访问一个网站时，如果没有 CDN，过程是这样的：\n\n浏览器要将域名解析为 IP 地址，所以需要向本地 DNS(Domain Name System) 发出请求。\n本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址。\n本地 DNS 将 IP 地址发回给浏览器，浏览器向网站服务器 IP 地址发出请求并得到资源。\n\n\n\n\n\n如果用户访问的网站部署了 CDN，过程是这样的：\n\n浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。\n本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到&#x3D;&#x3D;全局负载均衡系统（GSLB）&#x3D;&#x3D;的 IP 地址。\n本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的&#x3D;&#x3D;本地负载均衡系统（SLB）&#x3D;&#x3D;，并将该 SLB 的 IP 地址作为结果返回给本地 DNS。\n本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。\nSLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。\n浏览器再根据 SLB 发回的地址重定向到缓存服务器。\n如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。\n\n","categories":["网络"],"tags":["网络"]},{"title":"HTTP相关","url":"/2019/08/07/HTTP%E7%9B%B8%E5%85%B3/","content":" \n\n1、http 和 https 的基本概念​\t\t**http (HyperText Transfer Protocol)**：是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的&#x3D;&#x3D;超文本传输协议&#x3D;&#x3D;。\n​\t\thttps：是以安全为目标的 HTTP 通道，即 HTTP 下 加入 &#x3D;&#x3D;SSL 层进行加密&#x3D;&#x3D;。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。\nHTTP + SSL&#x2F;TLS &#x3D; HTTPSSSL(Secure Sockets Layer，安全套接字协议)\nTLS(Transport Layer Security，传输层安全协议)\nHTTP(HyperText Transfer Protocol ，超文本传输协议)，让计算机之间可以进行明文数据交换，默认端口80.\nHTTPS(HyperText Transfer Protocol Secure，超文本传输安全协议)，用SSL&#x2F;TLS对数据加密，再通过HTTP传输，保证数据的安全性，默认端口443.\nTLS是基于SSL 3.0的一个新版本，原则上他的名字是SSL 4.0；只是IETF在把SSL标准化时把SSL名称改成了TLS。\n2、HTTP​\t\t在实际应用中，HTTP常被用于在Web浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密。\n特点如下：\n\n支持客户&#x2F;服务器模式；\n简单快速：客户向服务器请求服务时，只需传送请求方法和路径。**&#x3D;&#x3D;由于HTTP协议简单&#x3D;&#x3D;，使得HTTP服务器的程序规模小，因而&#x3D;&#x3D;通信速度很快&#x3D;&#x3D;**；\n灵活：HTTP**&#x3D;&#x3D;允许传输任意类型的数据对象&#x3D;&#x3D;**。正在传输的类型由Content-Type加以标记；\n无连接：无连接的含义是**&#x3D;&#x3D;限制每次连接只处理一个请求&#x3D;&#x3D;**。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间;\n无状态：HTTP协议无法根据之前的状态进行本次的请求处理;\n\n3、HTTPS​\t\t在上述介绍HTTP中，了解到HTTP传递信息是以明文的形式发送内容，这并不安全。而HTTPS出现正是为了解决HTTP不安全的特性。\n​\t\t为了保证这些隐私数据能加密传输，让HTTP运行安全的SSL/TLS协议上，即 &#x3D;&#x3D;HTTPS &#x3D; HTTP + SSL&#x2F;TLS&#x3D;&#x3D;，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。\n​\t\tSSL 协议位于TCP/IP 协议与各种应用层协议之间，浏览器和服务器在使用 SSL 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持\n流程如下：\n\n客户端向服务器发起 HTTPS 请求，请求中包含了 SSL&#x2F;TLS 支持的信息，比如支持的 SSL&#x2F;TLS 版本号、加密算法等。\n服务器返回证书给客户端，证书中包含了服务器的公钥、服务器的身份信息和证书的有效期等。\n客户端验证服务器的身份，包括验证证书的有效性、证书是否过期、证书中的域名与服务器的域名是否一致等。\n如果证书验证通过，客户端生成一个随机的加密密钥，并使用服务器的公钥进行加密，然后发送给服务器。\n服务器使用私钥解密客户端发来的密钥，然后生成一个随机数作为会话密钥，并将会话密钥加密后发送给客户端。\n客户端和服务器使用会话密钥进行数据传输，客户端和服务器之间的所有数据都使用会话密钥进行加密和解密，保证数据的机密性和完整性。\n\n简洁版：\n客户端使用https的url访问web服务器,要求与服务器建立ssl连接\nweb服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端\n客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥\n客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥\n之后服务器与客户端使用秘钥加密传输\n\n4、http 和 https 的区别及优缺点\nhttp 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。\nhttp 协议的默认端口为 80，https 的默认端口为 443。\nhttp 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。\nhttps 缓存不如 http 高效，会增加数据开销。\nHttps 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。\nSSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。\n\n5、http1和http1.1的区别\n&#x3D;&#x3D;持久连接&#x3D;&#x3D;：\n\nHTTP &#x2F; 1.1引入了持久连接，这意味着在单个TCP连接上可以发送多个请求&#x2F;响应对，从而减少了每个请求的延迟。\nHTTP &#x2F; 1.0在每个请求&#x2F;响应之后关闭TCP连接。\n\n\n&#x3D;&#x3D;块传输编码&#x3D;&#x3D;：\n​\t\tHTTP &#x2F; 1.1支持块传输编码，这意味着可以在接收响应时逐步解压缩数据，而不必等待整个响应。这对于处理大型响应或流式数据非常有用。\n\n&#x3D;&#x3D;身份验证&#x3D;&#x3D;：\n​\t\tHTTP &#x2F; 1.1提供了更安全的身份验证方法，例如基于令牌的身份验证方案，可以替代HTTP &#x2F; 1.0中的基本身份验证。\n\n&#x3D;&#x3D;缓存处理&#x3D;&#x3D;：\n​\tHTTP &#x2F; 1.1对缓存处理进行了改进，包括新的Cache-Control指令，可以更好地控制缓存行为。\n\n&#x3D;&#x3D;响应码&#x3D;&#x3D;：\n​\tHTTP &#x2F; 1.1引入了更多的响应码，例如“100 Continue”，这使得客户端可以更好地控制它们的请求行为。\n\n&#x3D;&#x3D;管道化&#x3D;&#x3D;：\n​\tHTTP &#x2F; 1.1支持管道化，允许客户端同时发送多个请求，从而提高性能。\n\n\n6、GET 和 POST 的区别1. POST请求相对安全，GET请求相对不安全\nGET请求参数会直接挂载在URL上。POST请求携带的参数在URL上看不见。\nPOST请求记录不会被保存在浏览器历史或web服务器日志中。但是GET请求会。\n\n当然，以上是相对的。这不表示POST请求就绝对安全，其实。\n从数据传输的角度来说，POST和GET都不是很安全，因为http协议本身是明文传输。对内行人来说，抓包解析GET和POST都是一样的。\n2. GET请求可以缓存，POST请求不能缓存​\t\tGET请求一般用于数据和静态资源的获取，有些GET请求不用和数据库交互。比如一些静态资源和固定的字典表。所以可以使用缓存。\n数据缓存👇\n![image-20230411143847289](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230411143847289.png)\n静态资源缓存👇\n![image-20230411143907562](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230411143907562.png)\nPOST请求则更多用于数据的新增和修改。新增数据无法具备固定内容。所以很多浏览器都不支持缓存POST请求\n3. GET请求有长度限制，POST请求没有长度限制GET请求本身是没有长度限制的，但是URL有。不同的浏览器对于GET的长度限制也不一样。\n4. GET只能传输字符串，POST可以传输多种类型数据​\t\t因为GET请求是挂载在URL上的，所以传输的数据类型只能是字符串，但是POST请求可以传输除字符串以外的数据，比如：视频，声音，图片，文档等。\n5. GET请求入参在URL上，POST请求入参在Request body上​\t\t\n6. POST有可能产生两个数据包，GET只会发送一个数据包​\t\tGET请求在任何情况下都会把http header和data一次性发送完成。\n​\t\tPOST在部分情况下，（这取决于 浏览器&#x2F;发送方 和它的版本），会产生两个数据包。第一个tcp发送header,确认服务器可以响应并且具备接受数据的能力，响应100。第二个TCP包在第一个请求成功（100后）才会发送。包含data。如果第一个请求（header）失败，则data不进行发送。\n7.  刷新和回退的时候GET请求无害，POST数据会被重新提交​\t\t以前我一直没搞明白这一点区别的含义，怎么GET就无害了，POST就又会重新提交了。后来我明白了。\n​\t\t这点区别指向的是那些页面加载时候就默认执行的请求。\n​\t\t比如静态资源获取，刷新了就得重新加载吧。如果是GET，GET主要用重新获取数据，因为是获取，请求不会对数据产生什么危害，何况有时候还直接返回的缓存。所以无害。\n​\t\t再说POST，POST主要用于数据的修改&#x2F;新增，针对默认执行的情况下，POST请求的每次执行都有可能改变数据库中的某一个值，比如文章的阅读量。刷新一下就+1（不信你刷一个试试）。所以这里说POST数据会被重新提交，这种提交他不一定有害，但确实不一定有用。\n7、HTTP状态码使用场景:\n1xx：表示目前是协议的中间状态，还需要后续请求。\n2xx：表示请求成功。\n3xx：表示重定向状态，需要重新请求。\n4xx：表示请求报文错误。\n5xx：服务器端错误。\n\n常用状态码：\n101 切换请求协议，从 HTTP 切换到 WebSocket\n200 请求成功，有响应体，服务器成功返回网页\n301 永久重定向：会缓存\n302 临时重定向：不会缓存\n304 协商缓存命中\n403 服务器禁止访问\n404 资源未找到，请求的网页不存在\n400 请求错误\n500 服务器端错误\n503 服务器繁忙\n\n8、跨域解决方案8.1 JSONPJSONP 主要就是利用了 script 标签没有跨域限制的这个特性来完成的。\n仅支持 GET 方法，如果想使用完整的 REST 接口，请使用 CORS 或者其他代理方式。\n后端获取前端声明的执行函数（jsonpCallback），并以带上参数并调用执行函数的方式传递给前端。\nfunction callback()&#123;    console.log(&quot;月薪一千五，心比美式苦&quot;)&#125;$.ajax(&#123;    url: &#x27;http://www.domain2.com:8080/login&#x27;,    type: &#x27;get&#x27;,    dataType: &#x27;jsonp&#x27;,  // 请求方式为jsonp  设置跨域的重点    jsonpCallback: &quot;callBack&quot;,  // 回调函数&#125;);\n\n\n\n8.2 添加Access-Control-Allow-Origin响应头res.writeHead(200, &#123;    Access-Control-Allow-Origin&#x27;:&#x27;http://192.168.0.103:8080&#x27;\t\t// 或者    Access-Control-Allow-Origin&#x27;:&#x27;*&#x27;&#125;);\n\n\n\n8.3 前端工具的Proxy代理devServer: &#123;  port: 8000,    proxy: &#123;      &quot;/api&quot;: &#123;        target: &quot;http://localhost:8080&quot;      &#125;    &#125;&#125;,\n\n\n\n8.4 Nginx 反向代理server &#123;  listen 80;  server_name local.test;  location /api &#123;    proxy_pass http://localhost:8080;  &#125;  location / &#123;    proxy_pass http://localhost:8000;  &#125;&#125;\n\n\n\n8.5 WebsocketWebSocket 规范定义了一种 API，可在网络浏览器和服务器之间建立“套接字”连接。简单地说：客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据\n这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制。\n8.6 document.domain + Iframe「该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式」。 只需要给页面添加 document.domain =&#39;test.com&#39; 表示二级域名都相同就可以实现跨域。\nwww.   baidu.  com     .三级域  二级域   顶级域   根域\n\n8.7 window.location.hash + Iframe8.8 window.name + Iframe","categories":["网络"],"tags":["网络","HTTP"]},{"title":"二叉树","url":"/2020/01/18/%E4%BA%8C%E5%8F%89%E6%A0%91/","content":" \n\n二叉树+ 特性\n\n一个二叉树第i层的最大节点树为： &#x3D;&#x3D;2^(i-1)&#x3D;&#x3D;, i &gt;&#x3D; 1;\n\n深度为K的二叉树有最大节点总数为：&#x3D;&#x3D;2^k - 1&#x3D;&#x3D;, k &gt;&#x3D; 1;\n\n对任何非空二叉树T，若n0表示叶节点的个数、n2是度为2的非叶节点个数，\n那么两者满足关系n0 &#x3D; n2 + 1;\n\n\n二叉搜索树（BST， Binary Search Tree）,也叫二叉排序树，或二叉查找树\n\n二又搜索树是一颗二叉树，可以为空;\n如果不为空，满足以下&#x3D;&#x3D;性质&#x3D;&#x3D;\n非空&#x3D;&#x3D;左子树&#x3D;&#x3D;的所有键值&#x3D;&#x3D;小于&#x3D;&#x3D;其&#x3D;&#x3D;根节点&#x3D;&#x3D;的键值\n非空&#x3D;&#x3D;右子树&#x3D;&#x3D;的所有键值&#x3D;&#x3D;大于&#x3D;&#x3D;其&#x3D;&#x3D;根节点&#x3D;&#x3D;的键值\n\n\n左、右子树本身也都是二叉搜索树\n\n![image-20230403220345266](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230403220345266.png)\n特点：\n相对较小的值总是保存在左节点上，相对较大的值总是保存在右节点上。\n查找效率非常高，这也是二又搜索树中，搜索的来源\n\n+ 二叉搜索树作为数据存储有重要优势：\n可以快速地找到给定关键字的数据项并且可以快速地插入和删除数据项.\n+ 问题\n如果插入的数据是有序的数据，树的深度会很大，反而影响效率；\n树的遍历适用于所有二叉树\n\n先序遍历\n\n\n1.访问根节点\n2.遍历其左子树\n3.遍历其右子树\n\n\n中序遍历\n\n\n1.遍历其左子树\n2.访问根节点\n3.遍历其右子树\n\n\n后序遍历\n\n\n1.遍历其左子树\n2.遍历其右子树\n3.访问根节点\n\n\n\n二叉搜索树-封装属性：node\nkey: 键\nleft：左子节点\nright：右子节点\n方法：\n\ninsert ()：向树中插入一个新的键;\n\nsearch (key)：搜索特定的节点（值），存在返回true，否则返回false;\n\nmidOrderTraversal ()：通过中序遍历方式遍历所有节点，根节点在中间时遍历\n\npreOrderTraversal ()：通过先序遍历方式遍历所有节点：\n根节点最先遍历：从上到左 -&gt; 从左到右 -&gt; 从子到父\n\npostOrderTraversal ()：通过后序遍历方式遍历所有节点，最后遍历根节点\n\nmin ()：返回树中最小的值&#x2F;键。一直往左节点查找\n\nmax ()：返回树中最大的值&#x2F;键\n\nremove (key)：从树中移除某个节点\n\n\n/***************  二叉搜索树的封装 ***********/\t/**   *             11   *        7             15   *    5      9      13      20   *  3   6  8  10  12  14  18  25   */function BinarySearchTree() &#123;  function Node(key) &#123;    this.key = key;    this.left = null    this.right = null;  &#125;  this.root = null;  /**     * @description 向树中插入一个新的键     *      * 思路：     * 1.从根节点开始查找，大于该节点，往右查找；小于该节点，往左查找；     * 2.直到 被计较的 节点为空，则在该位置插入新节点；     *      */  BinarySearchTree.prototype.insert = function (key) &#123;    // 1.创建节点    const newNode = new Node(key);    // 2.判断是否存在根节点    if (this.root == null) &#123;      this.root = newNode;    &#125; else &#123;      this.insertNode(this.root, newNode);    &#125;  &#125;  /**     * @description 内部调用的方式，不对外暴露     * @node 被计较的节点     * @newNode 要插入的节点     *      */  BinarySearchTree.prototype.insertNode = function (node, newNode) &#123;    if (newNode.key &lt; node.key) &#123; // 向左查找      if (node.left == null) &#123; // 左边节点不存在，直接插入        node.left = newNode;      &#125; else &#123; // 左边节点不为空，继续进行比较        this.insertNode(node.left, newNode);      &#125;    &#125; else &#123; // 向右查找      if (node.right == null) &#123;        node.right = newNode;      &#125; else &#123; // 右边节点不为空，继续进行比较        this.insertNode(node.right, newNode);      &#125;    &#125;  &#125;  // 通过中序遍历方式遍历所有节点，根节点在中间时遍历  BinarySearchTree.prototype.midOrderTraversal = function (handler) &#123;    this.midOrderTraversalNode(this.root, handler);  &#125;  BinarySearchTree.prototype.midOrderTraversalNode = function (node, handler) &#123;    if (node !== null) &#123;      // 1.处理经过节点的 左子节点      this.preOrderTraverseNode(node.left, handler);      // 2.处理经过的节点      handler(node.key);      // 3.处理经过节点的 右子节点      this.preOrderTraverseNode(node.right, handler);    &#125;  &#125;  // 通过先序遍历方式遍历所有节点：根节点最先遍历：从上到左 -&gt; 从左到右 -&gt; 从子到父  BinarySearchTree.prototype.preOrderTraversal = function (handler) &#123;    this.preOrderTraverseNode(this.root, handler);  &#125;  BinarySearchTree.prototype.preOrderTraverseNode = function (node, handler) &#123;    if (node !== null) &#123;      // 1.处理经过的节点      handler(node.key);      // 2.处理经过节点的 左子节点      this.preOrderTraverseNode(node.left, handler);      // 3.处理经过节点的 右子节点      this.preOrderTraverseNode(node.right, handler);    &#125;  &#125;  // 通过后序遍历方式遍历所有节点，最后遍历根节点  BinarySearchTree.prototype.postOrderTraversal = function (handler) &#123;    this.postOrderTraversalNode(this.root, handler);  &#125;  BinarySearchTree.prototype.postOrderTraversalNode = function (node, handler) &#123;    if (node !== null) &#123;      // 1.处理经过节点的 左子节点      this.postOrderTraversalNode(node.left, handler);      // 2.处理经过节点的 右子节点      this.postOrderTraversalNode(node.right, handler);      // 3.处理经过的节点      handler(node.key);    &#125;  &#125;  // 返回树中最小的值/键：一直往左节点查找  BinarySearchTree.prototype.min = function () &#123;    let node = this.root;    while (node.left !== null) &#123;      node = node.left;    &#125;    return node.key;  &#125;  // 返回树中最大的值/键  BinarySearchTree.prototype.max = function () &#123;    let node = this.root;    while (node.right !== null) &#123;      node = node.right;    &#125;    return node.key;  &#125;  // 搜索特定的节点（值）  BinarySearchTree.prototype.search = function (key) &#123;    // 一、循环方式    // 结束循环条件 node === null    // 1.获取根节点    let node = this.root;    // 2.遍历所有节点    while (node) &#123;      if (key &lt; node.key) &#123; // 向左查找        node = node.left;      &#125; else if (key &gt; node.key) &#123; // 向右查找        node = node.right;      &#125; else &#123;        return true;      &#125;    &#125;    return false;    // 二、递归方式    // return this.searchNode(this.root, key)  &#125;  // 退出递归的条件：  // 1.当前节点为null, node === null;   // 2.找到了key，node.key === key;  BinarySearchTree.prototype.searchNode = function (node, key) &#123;    if (node === null) &#123;      return false;    &#125;    if (key &lt; node.key) &#123; // 向左查找      return this.searchNode(node.left, key);    &#125; else if (key &gt; node.key) &#123; // 向右查找      return this.searchNode(node.right, key);    &#125; else &#123;      return true;    &#125;  &#125;  /**     * @description 从树中移除某个节点     *      * 1.找到要删除的节点，如果没有找到，不进行删除操作     * 2.如果找到了，则分为如下 三种情况：     *      * 一、没有子节点：叶节点     * 1.检测 当前节点的 left &amp; right === null     * 2.都为null之后，检测是否为 根节点，如果是，则清空二叉树     * 3.如果不是根节点，将父节点的 left 或者 right 设置为null 即可     *      * 二、只有一个子节点     *      * 三、有两个子节点     *      */  BinarySearchTree.prototype.remove = function (key) &#123;    // 1.寻找要删除的节点    // 1.1 保存当前节点，要删除的节点的父节点    let currentNode = this.root;    let parentNode = null;    let isLeftChild = true;    // 1.2 遍历查找    while (currentNode.key !== key) &#123;      parentNode = currentNode;      if (key &lt; currentNode.key) &#123; // 向左查找        isLeftChild = true;        currentNode = currentNode.left;      &#125; else &#123; // 向右查找        isLeftChild = false;        currentNode = currentNode.right;      &#125;      // 直到遍历到了最后的节点，依然没有找到 == key 的节点      if (currentNode === null) return false;    &#125;    // 2.根据对应的情况删除节点    // 2.1 删除的节点是叶子节点    if (currentNode.left === null &amp;&amp; currentNode.right === null) &#123;      if (currentNode === this.root) &#123;        this.root = null;      &#125; else if (isLeftChild) &#123;        parentNode.left = null;      &#125; else &#123;        parentNode.right = null;      &#125;    &#125;    // 2.2 删除的节点有一个子节点    /**       *             11       *        7             15       *    5      9      13      20       *  3  6   8  10  12  14  18  25       */    // 2.2.1 当前节点在左节点，currentNode.left === parentNode.left;(例如：5)    // left:  parentNode.left = currentNode.left;（有3无6的情况）    // right: parentNode.left = currentNode.right;（有6无3的情况）    else if (currentNode.right === null) &#123;      // 当前节点为根节点，父节点为null      if (currentNode === this.root) &#123;        this.root = currentNode.left;      &#125; else if (isLeftChild) &#123;        parentNode.left = currentNode.left; // （有3无6的情况）      &#125; else &#123;        parentNode.right = currentNode.left; // （有8无10的情况）      &#125;    &#125;    // 2.2.2 当前节点在右节点，currentNode.right === parentNode.right;(例如：9)    // left:  parentNode.right = currentNode.left;（有8无10的情况）    // right: parentNode.right = currentNode.right;（有10无8的情况）    else if (currentNode.left === null) &#123;      // 当前节点为根节点，父节点为null      if (currentNode === this.root) &#123;        this.root = currentNode.right;      &#125; else if (isLeftChild) &#123;        parentNode.left = currentNode.right; // （有6无3的情况）      &#125; else &#123;        parentNode.right = currentNode.right; // （有10无8的情况）      &#125;    &#125;    /**       *             11       *        7             15       *    5      9      13      20       *  3      8  10  12  14  18  25       *                          19       *        * 19连着18连着20       */    // 2.3 删除的节点有两个子节点    // 情况一：删除节点9，任选8或者10放到原本9的位置    // 情况二：删除节点7    // - 方案一：左边：将5移到7的位置，3移到原本5的位置；    // - 方案二：右边：将8放到7的位置    // 情况三：删除节点15    // - 方案一：左边：将14放到15的位置    // - 方案二：右边：将18放到15的位置，19移到原本18的位置；    // 规律 &amp; 思路    // + 如果我们要删除的节点有两个子节点甚至子节点还有子节点,    // 这种情况下我们需要从下面的子节点中找到个节点,来替换当前的节点    // + 但是找到的这个节点有什么特征呢?应该是 current节点下面所有节点中最接近 current节点的    // - 要么比 current节点小一点点要么比 current节点大一点点    // - 总之你最接近 current,你就可以用来替换 current的位置.    // + 这个节点怎么找呢？    // - 比 current小一点点的节点一定是 current左子树的最大值    // - 比 current大一点点的节点一定是 current右子树的最小值    // + 前驱&amp;后继    // - 在二叉搜索树中,这两个特别的节点有两个特别的名字    // - 比 current小一点点的节点称为 current节点的前区    // - 比 current大一点点的节点称为 current节点的后继    // + 也就是为了能够删除有两个子节点的α urrent,要么找到它的前驱,要么找到它的后继.    // + 所以接下来,我们先找到这样的节点(前驱或者后继都可以我这里以找后继为例)    else &#123;      // 1.获取后继节点      let successor = this.getSuccssor(currentNode)      // 2.判断是否为根节点      if (currentNode === this.root) &#123;        this.root = successor;      &#125;    &#125;  &#125;  // 找到后继  BinarySearchTree.prototype.getSuccssor = function (delNode) &#123;    // 1.定义变量，，保存找到的后继    let successor = delNode;    let current = delNode.right;    // 2.循环查找    while (current !== null) &#123;      successor = current;      current = current.left;    &#125;    return successor;  &#125;&#125;\n\n\n\n测试用例：\n/**   * 删除用的   *             11   *        7             15   *    5      9      13      20   *     6   8  10  12  14  18  25   */let bst = new BinarySearchTree();bst.insert(11);bst.insert(7);bst.insert(15);bst.insert(5);bst.insert(3);bst.insert(9);bst.insert(8);bst.insert(10);bst.insert(13);bst.insert(12);bst.insert(14);bst.insert(20);bst.insert(18);bst.insert(25);bst.insert(6);bst.insert(19);// 测试先序遍历let resultString1 = &quot;&quot;;bst.preOrderTraversal(function (key) &#123;  resultString1 += key + &#x27; &#x27;&#125;);console.log(&#x27;先序遍历：&#x27;, resultString1)// 测试中序遍历let resultString2 = &quot;&quot;;bst.midOrderTraversal(function (key) &#123;  resultString2 += key + &#x27; &#x27;&#125;);console.log(&#x27;先序遍历：&#x27;, resultString2)// 测试后续序遍历let resultString3 = &quot;&quot;;bst.postOrderTraversal(function (key) &#123;  resultString3 += key + &#x27; &#x27;&#125;);console.log(&#x27;后序遍历：&#x27;, resultString3)console.log(&#x27;最小值：&#x27;, bst.min())console.log(&#x27;最大值：&#x27;, bst.max())console.log(&#x27;是否存在 key = 3 的节点&#x27;, bst.search(3));console.log(&#x27;是否存在 key = 9 的节点&#x27;, bst.search(9));console.log(&#x27;是否存在 key = 13 的节点&#x27;, bst.search(13));console.log(&#x27;是否存在 key = 18 的节点&#x27;, bst.search(18));console.log(&#x27;是否存在 key = 21 的节点&#x27;, bst.search(21));console.log(&#x27;删除6&#x27;, bst.remove(6), bst)// console.log(&#x27;删除3&#x27;, bst.remove(3), bst)// console.log(&#x27;删除5&#x27;, bst.remove(5), bst)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"红黑树","url":"/2020/02/06/%E7%BA%A2%E9%BB%91%E6%A0%91/","content":" \n\n二叉树 对比+ 二叉搜索树+ 优点：\n\n可以快速地找到给定关键字的数据项并且可以快速地插入和删除数据项.\n\n+ 缺点\n\n如果插入的数据是&#x3D;&#x3D;有序&#x3D;&#x3D;的数据，树的深度会很大，反而影响效率；\n\n+ 非平衡树\n比较好的二叉搜索树数据应该是左右分布均匀的；\n\n但是插入连续数据后，&#x3D;&#x3D;分布的不均匀&#x3D;&#x3D;，我称这种树为&#x3D;&#x3D;非平衡树&#x3D;&#x3D;；\n\n对于一棵平衡二叉树来说，插入&#x2F;查找等操作的效率是O(logN)；\n\n对于一棵非平衡二叉树，相当于编写了—个链表，查找效率变成了O(N)。\n\n\n+ 为了能以较快的时间O(logN)来操作一棵树，我们需要保证树总是平衡的:\n\n至少大部分是平衡的那么时间复杂度也是接近O(logN)的；\n\n也就是说树中每个&#x3D;&#x3D;节点左边的子孙节点&#x3D;&#x3D;的个数应该尽可能的&#x3D;&#x3D;等于&#x3D;&#x3D;，&#x3D;&#x3D;右边的子孙节点&#x3D;&#x3D;的个数；\n\n常见的平衡树有哪些呢?\n\n\n+ AVL树AVL树是最早的—种平衡树.它有些办法保持树的平衡(每个节点多存储了一个额外的数据)；\n因为AVL树是平衡的所以时间复杂度也是O(logN)；\n但是，每次&#x3D;&#x3D;插入&#x2F;删除&#x3D;&#x3D;操作相对于红黑树&#x3D;&#x3D;效率都不高&#x3D;&#x3D;，所以整体效率&#x3D;&#x3D;不如红黑树&#x3D;&#x3D;。\n+ 红黑树红黑树也通过一些特性来保持树的平衡；\n因为是平衡树，所以时间复杂度也是在O(logN)；\n另外插入&#x2F;删除等操作，红黑树的性能要优于AVL树，所以现在平衡树的应用基本都是红黑树。\n二、特性 + 红黑树，除了符合二叉搜索树的基本规则外，还添加了一下特性\n\n\n\n节点是红色或黑色。\n&#x3D;&#x3D;根节点是黑色&#x3D;&#x3D;。\n每个&#x3D;&#x3D;叶子节点&#x3D;&#x3D;都是&#x3D;&#x3D;黑色&#x3D;&#x3D;的空节点(NIL节点)\n每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上&#x3D;&#x3D;不能有两个连续&#x3D;&#x3D;的&#x3D;&#x3D;红色&#x3D;&#x3D;节点)\n从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n\n+ 红黑树的关键特性:\n\n从根到叶子的&#x3D;&#x3D;最长可能路径&#x3D;&#x3D;，不会超过&#x3D;&#x3D;最短可能路径&#x3D;&#x3D;的&#x3D;&#x3D;两倍长&#x3D;&#x3D;;\n结果就是这个树基本是平衡的；\n虽然没有做到绝对的平衡，但是可以保证在最坏的情况下，依然是高效的；\n\n+ 为什么可以做到 最长路径不超过最短路径的两倍 呢?\n\n性质4决定了路径&#x3D;&#x3D;不能&#x3D;&#x3D;有两个&#x3D;&#x3D;相连&#x3D;&#x3D;的&#x3D;&#x3D;红色节点&#x3D;&#x3D;；\n最短的可能路径都是黑色节点；\n最长的可能路径是红色和黑色交替；\n性质5&#x3D;&#x3D;所有路径&#x3D;&#x3D;都有&#x3D;&#x3D;相同数目&#x3D;&#x3D;的&#x3D;&#x3D;黑色&#x3D;&#x3D;节点；\n这就表明了没有路径能多余任何其他路径的两倍长。\n\n+ 插入一个新节点时，有可能树不再平衡，可以通过三种方式的变换，让树保持平衡\n\n换色-左旋转一右旋转\n\n1.变色\n为了重新符合红黑树的规则，尝试把&#x3D;&#x3D;红色&#x3D;&#x3D;节点&#x3D;&#x3D;变&#x3D;&#x3D;为&#x3D;&#x3D;黑色&#x3D;&#x3D;，或者把&#x3D;&#x3D;黑色&#x3D;&#x3D;节点&#x3D;&#x3D;变&#x3D;&#x3D;为&#x3D;&#x3D;红色&#x3D;&#x3D;\n\n+ 插入的 &#x3D;&#x3D;新的节点&#x3D;&#x3D; 通常都是 &#x3D;&#x3D;红色&#x3D;&#x3D;节点.\n\n因为在插入节点为红色的时候，有可能插入一次是不违反红黑树任何规则的\n而 插入黑色节点，必然会导致有一条路径上多了黑色节点这是很难调整的\n红色节点 可能&#x3D;&#x3D;导致&#x3D;&#x3D;出现&#x3D;&#x3D;红红相连&#x3D;&#x3D; 的情况，但是这种情况可以通过 &#x3D;&#x3D;颜色调换&#x3D;&#x3D;和&#x3D;&#x3D;旋转&#x3D;&#x3D; 来调整\n\n2.旋转旋转后，依然符合二叉搜索树的特性\n\n左旋转：\n\n&#x3D;&#x3D;逆时针&#x3D;&#x3D;旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子\n\n\n\n图中，身为右孩子的Y取代了X的位置，而X变成了Y的左孩子。此为左旋转\n\n不影响子节点：b节点，旋转前后，都满足 x &lt; b &lt; y\n\n\n\n右旋转：\n\n&#x3D;&#x3D;顺时针&#x3D;&#x3D;旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子\n\n图中，身为左孩子的Y取代了X的位置，而X变成了Y的右孩子。此为右旋转\n不影响子节点：c节点，旋转前后，都满足 y &lt; c &lt; x\n\n\n\n\n接下来,讨论一下插入的情况:设要插入的节点为N,其父节点为P其祖父节点为G,其父亲的兄弟节点为U(即P和U是同一个节点的子节点)\n\n情况一：(简单变色即可)新节点N位于树的根上,没有父节点这种情况下,我们直接将红色变换成黑色即可,这样满足性质2\n\n情况二：(不用变)新节点的父节点P是黑色性质4没有失效(新节点是红色的),性质5也没有任何问题尽管新节点N有两个黑色的叶子节点nil但是新节点N是红色的,所以通过它的路径中黑色节点的个数依然相同,满足性质5\n\n情况三：P为红色，U也是红色，G是黑色（父红叔红祖黑 &#x3D;》 父黑叔黑 祖红）\n\n操作方案将P和U变换为黑色,并且将G变换为红色现在新节点N有了一个黑色的父节点P，所以每条路径上黑色节点的数目没有改变；而从更高的路径上必然都会经过G节点所以那些路径的黑色节点数目也是不变的.符合性质5.\n\n可能出现的问题但是，N的祖父节点G的父节点也可能是红色,这就违反了性质3,可以递归的调整颜色.但是如果递归调整颜色到了根节点,就需要进行旋转了,待会儿我们的例子中会遇到这个问题.\n\n情况四：N的叔叔∪是黑节点,且N是左孩子；（父红，叔黑，祖父黑，N左）\n\n操作方案对祖父节点G进行依次右旋转在旋转查收的树中,以前的父节点P现在是新节点以前祖父节点G的父节点交换以前的父节点P和祖父节点G的颜色(P为黑色,G变成红色——G原来一定是黑色,为什么?)B节点向右平移,成为G节点的左子节点\n\n情况五N的叔叔U是黑色节点,且N是有孩子.（父红叔黑祖父黑，N右）\n\n旋转以P为根，左旋转将P作为新插入的红色接地那考虑即可\n\n操作方案对P节点进行依次左旋转,形成情况四的结果.对祖父节点G进行一次右旋转,并且改变颜色即可\n\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"链表","url":"/2019/10/08/%E9%93%BE%E8%A1%A8/","content":" \n\n一、概念![image-20230402115800488](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230402115800488.png)\n数组\n要存储多个元素，数组可能是最常用的数据结构。\n几乎每一种编程语言都有默认实现数组结构。\n\n数组的缺点：\n\n数组的创建通常需要申请一段连续的内存空间（整块的内存），并且大小是固定的（大多数编程语言数组都是固定的）；\n所以当 当前数组 不能满足容量需求时，需要扩容（一般情况下是申请—个更大的数组，比如2倍。然后将原数组中的元素复制过去）。\n而且在数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移。\n尽管我们已经学过的 JavaScript 的Array类方法可以帮我们做这些事，但背后的原理依然是这样。\n\n链表结构\n不同于数组，链表中的元素在内存中不必是连续的空间。\n链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（有些语言称为指针或者连接）组成。\n\n优点：\n\n内存空间不是必须连续的。可以充分利用计算机的内存，实现灵活的内存动态管理。\n链表不必在创建时就确定大小，并且大小可以无限的延伸下去。\n链表在插入和删除数据时，时间复杂度可以达到O(1)。相对数组效率高很多。\n\n结构模型\n​    head -&gt; { data, next } -&gt; { data, next } -&gt; { data, next } -&gt; null;\n\nhead 指向头部节点；\nnext 指向下一个节点；\ndata 当前节点数据\n二、属性和方法链表的属性：\n\nhead: 头部节点\nnode: 节点\ndata: 节点数据\nnext：指向下一个节点的指针\n\n\nlength: 链表长度\n\n链表的方法（6个）：\n\nappend(data)：向链表尾部添加一个新的项\ninsert(position, data)：向链表的特定位置 插入一个新的项\nget(position)：获取对应位置的元素\nindexOf(data)：返回元素在链表中的索引。如果链表中没有该元素，则返回-1\nupdate(position, data)：修改某个位置的元素\nremoveAt(position)：从链表的特定位置删除一项\nremove(data)：从列表中删除一项\nisEmpty()：如果链表中不包含任何元素，返回true；否则返回false\nsize()：返回链表中包含的元素个数\ntoString()：将链表中的内容，转换成字符串形式\n\n具体实现：\n/***************  链表封装 ***********/function LinkedList() &#123;  // 内部类：节点类  function Node(data) &#123;    this.data = data;    this.next = null;  &#125;  // 属性  this.head = null;  this.length = 0;  // 向链表尾部添加一个新的项  LinkedList.prototype.append = function (data) &#123;    const node = new Node(data);    // 1.是否是第一个节点，是，则将head指向新节点    if (this.length === 0) &#123;      this.head = node;    &#125; else &#123; // 2.找到最后一个节点，将next等于当前的新节点      let currentNode = this.head;      // 找到最后一个节点      while (currentNode.next) &#123;        currentNode = currentNode.next;      &#125;      // 最后一个节点的 next 指向新节点      currentNode.next = node;    &#125;    this.length++;  &#125;  // 向链表的特定位置 插入一个新的项  LinkedList.prototype.insert = function (position, data) &#123;    // 1.对 position 进行越界判断    if (position &lt; 0 || position &gt; this.length) &#123;      return false    &#125;    // 2.创建节点数据    const node = new Node(data);    // 3.判断是否插入的是第一个位置    if (position === 0) &#123;      node.next = this.head;      this.head = node;    &#125; else &#123;      // 4.插入的是中间位置      // 3.1 当前节点      let currentNode = this.head;      // 3.2 前一个节点      let prevNode = null;      // 3.2 当前节点索引      let index = 0;      while (index++ &lt; position) &#123;        prevNode = currentNode;        currentNode = currentNode.next;      &#125;      node.next = currentNode;      prevNode.next = node;    &#125;    this.length++;    return true;  &#125;  // 获取对应位置的元素  LinkedList.prototype.get = function (position) &#123;    // 1.对 position 进行越界判断    if (position &lt; 0 || position &gt;= this.length) &#123;      return null    &#125;    // 2.获取对应的data    let currentNode = this.head;    let index = 0;    while (index++ &lt; position) &#123;      currentNode = currentNode.next;    &#125;    return currentNode.data;  &#125;  // 返回元素在链表中的索引。如果链表中没有该元素，则返回-1  LinkedList.prototype.indexOf = function (data) &#123;    let currentNode = this.head;    let index = 0;    while (currentNode) &#123;      if (data === currentNode.data) &#123;        return index;      &#125;      currentNode = currentNode.next;      index++;    &#125;    return -1;  &#125;  // 修改某个位置的元素  LinkedList.prototype.update = function (position, data) &#123;    // 1.对 position 进行越界判断    if (position &lt; 0 || position &gt;= this.length) &#123;      return false    &#125;    // 2.获取对应的data    let currentNode = this.head;    let index = 0;    while (index++ &lt; position) &#123;      currentNode = currentNode.next;    &#125;    // 修改数据    currentNode.data = data;    return true;  &#125;  // 从链表的特定位置删除一项  LinkedList.prototype.removeAt = function (position) &#123;    // 1.对 position 进行越界判断    if (position &lt; 0 || position &gt;= this.length) &#123;      return false    &#125;    let currentNode = this.head;    // 2.判断是否删除的是第一个元素    if(position === 0) &#123;      this.head = this.head.next;    &#125; else &#123;      let index = 0;      let prevNode = null;      while(index++ &lt; position) &#123;        prevNode = currentNode;        currentNode = currentNode.next;      &#125;      // 前一个节点的next指向currentNode的next即可      prevNode.next = currentNode.next;    &#125;    this.length--;    return currentNode.data;  &#125;  // 从链表中删除一项  LinkedList.prototype.remove = function (data) &#123;    // 1.根据元素获取 其位置    const postion = this.indexOf(data);    // 2.根绝位置信息，删除节点    return this.removeAt(postion);  &#125;  // 如果链表中不包含任何元素，返回true；否则返回false  LinkedList.prototype.isEmpty = function () &#123;    return this.length === 0;  &#125;  // 返回链表中包含的元素个数  LinkedList.prototype.size = function () &#123;    return this.length  &#125;  // 由于链表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值  LinkedList.prototype.toString = function () &#123;    let current = this.head;    let listString = &#x27;&#x27;;    while (current) &#123;      listString += current.data + &#x27; &#x27;;      current = current.next;    &#125;    return listString;  &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"哈希表","url":"/2019/11/26/%E5%93%88%E5%B8%8C%E8%A1%A8/","content":" \n\n一、哈希表 vs 数组哈希表：基于数组进行实现的，相对于数组，有很多优势。\n\n提供 非常&#x3D;&#x3D;快速的插入-删除-查找&#x3D;&#x3D;操作。\n无论多少数据，插入和删除值需要接近常量的时间：即O(1)的时间级。实际上只需要几个机器指令即可完成。\n哈希表的 &#x3D;&#x3D;速度 比 树&#x3D;&#x3D; 还要快，基本可以瞬间查找到想要的元素。\n哈希表相对于 树 来说&#x3D;&#x3D;编码要容易&#x3D;&#x3D;的很多。\n哈希表的结构就是&#x3D;&#x3D;数组，对下标值的一种变换&#x3D;&#x3D;，这种变换称之为&#x3D;&#x3D;哈希函数&#x3D;&#x3D;，通过哈希函数可以获得HashCode;\n\n相对于数组的不足：\n数据没有顺序，不能以一种固定的方式（比如从小大）来遍历其中的元素\n通常情况下，哈希表中的key是不允许充重复的，不能放置相同的key，用于保存不同的元素\n\n数组查找效率：\n如果是基于索引进行查找，效率非常高\n如果是基于内容查找(name&#x3D;’why’)，效率比较低\n进行删除操作，效率也不高\n\n二、哈希表自定义编码：\n\n规则：用1表示a，用26表示z，用0表示空格\n\n字母转数组：\n  2.1 数组相加。\n\n\n\n方法：cats &#x3D; 3 + 1 + 20 + 19 &#x3D; 43;\n问题：很多单词的数字之和都相同，会造成数据覆盖。\n结果：数组下标太少\n\n​\t2.2 &#x3D;&#x3D;幂的连乘&#x3D;&#x3D;。\n\n方法：7654 &#x3D; 710^3 + 610^2 + 5*10 + 4;（基本保证唯一性）\n\n问题： \n\n单词太长，得到的结果非常大，数组能否表示这么大的下标值吗？\n就算能够创建这么大的数组，实时上有很多是无效的单词\n创建这么大的数组时没有意义的、\n\n\n结果：数组下标太多\n\n改进：压缩范围，将巨大的整数范围压缩到可以接受的数组范围中。\n\n压缩实现：取余操作。\n​\n\n\n哈希化：将大数字转化成数组范围内下标的过程。\n哈希函数：通常会将单词转成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数被称为哈希函数。\n哈希表：最终将数据插入到的这个数组，对整个结构的封装，称之为一个哈希表\n冲突下标值仍然可能相同，冲突不可避免，只能解决冲突。\n解决冲突：\n\n链地址法（拉链法）。\n开放地址法。\n\n链地址法\n\n\n每个数组单元中存储的不再是单个数据，而是一个&#x3D;&#x3D;链条&#x3D;&#x3D;。\n链条的数据结构通常是 数组或&#x3D;&#x3D;链表&#x3D;&#x3D;。\n比如是链表，也就是每个数组单元中存储着一个链表。一旦发现重复，将重复的元素插入到链表的首端或者未端即可。\n当查询时，先根据哈希化后的下标值找到对应的位置，再取出链表，依次查询找寻找的数据。\n\n开放地址法\n\n寻找空白的单元格来添加重复的数据\n探索这个位置的方式：\n\n线性探测：\n二次探测\n再哈希法\n\n1.线性探测（82和32）\n\n插入：\n\n​\t经过哈希化得到index &#x3D; 2，在插入的时候，发现该位置已经有了82；\n​\t从 index+1 的位置开始一点点查找合适位置（空白位置）来放置32\n\n查找：\n\n​\t经过哈希化得到index &#x3D; 2，比如2的位置结果和查询的数据是否相同，相同则直接返回；\n​\t不相同，则从 index+1 位置开始查找和32一样的\n​\t如果32的位置 我们之前 没有插入，则查询到空位置就停止，因为查询到这里有空位置，32之前不可能跳过空位置去其他的位置。\n\n删除：\n\n​\t删除一个数据项时，不可以将这个下标的内容设置为null；\n​\t如果设置为null可能会影响之后的查询操作，通常删除一个位置的数据项时，可以进行特殊处理（比如设置为-1）；\n​\t当看到-1位置的数据项时，就知道要继续查询，但是插入时这个位置可以放置数据。\n\n问题：聚集\n\n​\t比如在没有任何数据的时候，插入的是22-23-24-25-26，那么意味着下标值2-3-4-5的位置都有元素；\n​\t这种一连串填充单元就叫做聚集；\n​\t聚集会影响哈希表的性能，无论是插入&#x2F;查询&#x2F;删除 都有影响\n​\t比如插入一个32，会发现连续的单元都不允许放置数据，并且在这个过程中需要探测多次；\n​\t二次探测可以解决一部分这个问题。\n2.二次探测\n\n二次探测主要优化的是&#x3D;&#x3D;探测时的步长&#x3D;&#x3D;；\n&#x3D;&#x3D;线性探测&#x3D;&#x3D;，可以看成是&#x3D;&#x3D;步长为1&#x3D;&#x3D;的探测，比如从下标值x开始,那么线性测试就是x+1，X+2，X+3依次探测；\n二次探测，对步长做了优化，比如从下标值x开始，x+1^2，x+2^2，x+3^2；\n这样就可以&#x3D;&#x3D;一次性探测比较长的距离&#x3D;&#x3D;，比避免那些聚集带来的影响；\n\n问题：\n​\t二次探测依然存在问题，比如我们连续插入的是32-112-82-2-192,那么它们依次累加的时候步长的相同的；\n​\t也就是这种情况下会造成&#x3D;&#x3D;步长不一的一种聚集&#x3D;&#x3D;，还是会影响效率、(当然这种可能性相对于连续的数字会小一些)\n3.再哈希法\n\n二次探测的算法产生的探测序列步长是固定的：1，4，9，16，依次类推；\n现在需要一种方法：产生一种 &#x3D;&#x3D;依赖关键字的探测序列&#x3D;&#x3D;，而不是每个关键字都一样；\n那么，&#x3D;&#x3D;不同的关键字&#x3D;&#x3D; 即使映射到 &#x3D;&#x3D;相同的数组下标&#x3D;&#x3D;，也可以使用 &#x3D;&#x3D;不同的探测序列&#x3D;&#x3D;；\n再哈希法的做法就是：把关键字用另外一个哈希函数，再做一次哈希化，用这次哈希化的结果作为步长；\n对于&#x3D;&#x3D;指定的关键字，步长&#x3D;&#x3D;在整个探测中是&#x3D;&#x3D;不变&#x3D;&#x3D;的，不过&#x3D;&#x3D;不同的关键字&#x3D;&#x3D;使用&#x3D;&#x3D;不同的步长&#x3D;&#x3D;\n\n第二次哈希化需要具备如下特点：\n\n和&#x3D;&#x3D;第一个哈希函数不同&#x3D;&#x3D; (不要再使用上一次的哈希函数了，不然结果还是原来的位置)；\n&#x3D;&#x3D;不能输岀为0&#x3D;&#x3D; (否则，将没有步长每次探测都是原地踏步，算法就进入了死循环)\n\n其实，我们不用费脑细胞来设计了，计算机专家已经设计出一种工作很好的哈希函数:\n\nstepsize &#x3D; constant - (key % constant);\n其中 constant是质数，且小于数组的容量;\n例如: stepsize &#x3D; 5 - (key % 5)，满足需求，并且结果不可能为0\n\n哈希表中执行插入和搜索操作效率是非常高的：\n\n如果没有产生冲突，那么效率就会更高；\n如果发生冲突，存取时间就依赖后来的探测长度；\n平均探测长度以及平均存取时间，取决于墳装因子，随着填装因子变大，探测长度也越来越长；\n随着填裝因子变大，效率下降的情况，在不同开放地址法方案中比链地址法更严重；\n所以我们来对比-下他们的效率，再决定我们选取的方案\n\n在分析效率之前，我们先了解一个概念：裝填因子\n\n装填因子表示当前哈希表中 已经包含的数据项 和 整个哈希表长度的 比值；\n装填因子 &#x3D; 总数据项 &#x2F; 哈希表长度；\n开放地址法 的 装填因子 最大 是多少呢?1，因为它必须寻找到空白的单元才能将元素放入\n链地址法 的 装填因子 呢?可以大于1，因为拉链法可以无限的延伸下去，只要你愿意(当然后面效率就变低了)。\n\n三、哈希函数好的哈希函数应该尽可能让计算的过程变得简单提高计算的效率。\n\n哈希表的主要&#x3D;&#x3D;优点是它的速度&#x3D;&#x3D;，所以在速度上不能满足，那么就达不到设计的目的了；\n提高速度的一个办法就是让哈希函数中&#x3D;&#x3D;尽量少的有乘法和除法&#x3D;&#x3D;。因为它们的&#x3D;&#x3D;性能是比较低&#x3D;&#x3D;的；\n\n+ 设计好的哈希函数应该具备哪些优点呢?\n\n快速的计算\n\n\n哈希表的优势就在于效率，所以快速获取到对应的 hash Code非常重要；\n我们需要通过快速的计算来获取到元素对应的 hash Code；\n\n\n均匀的分布\n\n\n哈希表中，无论是链地址法还是开放地址法，当多个元素映射到同一个位置的时候都会影响效率；\n所以优秀的哈希函数应该尽可能将元素映射到不同的位置，让元素在哈希表中均匀的分布；\n\n​\t在设计哈希表时，我们已经有办法处理 映射到相同下标值 的情况：链地址法或者开放地址法.\n​\t但是无论哪种方案，为了提供效率，最好的情况还是让数据在哈希表中均匀分布.\n​\t因此，我们需要在使用常量的地方，尽量使用质数.\n哪些地方我们会使用到常量呢?\n+ 质数的使用\n\n哈希表的长度.\nN次幂的底数(我们之前使用的是27)\n\n/***************  哈希函数 ***********/// 1.将字符串转成比较大的数字：hashCode// 2.将大的数字hashCode压缩到数组范围（大小）之内function hashFunc(str, size) &#123;  // 1.定义hashCode边浪  let hashCode = 0;  // 2.霍纳算法，来计算hashCode的值  // cats -&gt; Unicode编码  for (let i = 0; i &lt; str.length; i++) &#123;    hashCode = 37 * hashCode + str.charCodeAt(i);  &#125;  // 3.取余操作  return hashCode % size;&#125;console.log(hashFunc(&#x27;abc&#x27;, 7)) // 4console.log(hashFunc(&#x27;cba&#x27;, 7)) // 3console.log(hashFunc(&#x27;nba&#x27;, 7)) // 5console.log(hashFunc(&#x27;mba&#x27;, 7)) // 1\n\n\n\n四、哈希表的实现结构：\n[  [], [[&#x27;name&#x27;,&#x27;Alice&#x27;]], [[&#x27;age&#x27;, 20]]]\n\n\n\n代码实现：\n/***************  哈希表 ***********/function HashTable() &#123;  // 数组中存放相关的元素  this.storage = [];  // 当前哈希表已经存放的元素个数  this.count = 0;  // 哈希表 数组当前的总长度  this.limit = 7;  // 加载因子/装载因子 loadFactor &gt; 0.75 || loadFactor &lt; 0.25 ; loadFactor = count / limit  // 哈希函数  HashTable.prototype.hashFunc = function (str, size) &#123;    // 1.定义hashCode边浪    let hashCode = 0;    // 2.霍纳算法，来计算hashCode的值    for (let i = 0; i &lt; str.length; i++) &#123;      hashCode = 37 * hashCode + str.charCodeAt(i);    &#125;    // 3.取余操作    return hashCode % size;  &#125;  // 插入和修改操作  HashTable.prototype.put = function (key, value) &#123;    // 1.根据key获取索引值（目的：将数据插入到对应的位置）    let index = this.hashFunc(key, this.limit);    // 2.根据索引值取出bucket    let bucket = this.storage[index];    // 3.判断该bucket是否为null    if (!bucket) &#123;      bucket = [];      this.storage[index] = bucket;    &#125;    // 4.判断是否是修改数据    for (let i = 0; i &lt; bucket.length; i++) &#123;      let tuple = bucket[i];      if(tuple[0] === key) &#123;        tuple[1] = value;        return;      &#125;    &#125;    // 5.进行添加操作    bucket.push([key, value])    this.count += 1;  &#125;  HashTable.prototype.get = function (key) &#123;    // 1.根据key获取对应的index    let index = this.hashFunc(key, this.limit);    // 2.根据index获取对应的bucket    let bucket = this.storage[index];    // 3.判断bucket是否为null，是，直接返回null    if(bucket === null) return null;    // 4.线性查找bucket中每一个key是否等于传入的key    for (let i = 0; i &lt; bucket.length; i++) &#123;      const tuple = bucket[i];      if (tuple[0] === key) &#123;        return tuple[1]      &#125;    &#125;    // 5.依然没有知道    return null;  &#125;  HashTable.prototype.remove = function (key) &#123;    // 1.根据key获取对应的index    let index = this.hashFunc(key, this.limit);    // 2.根据index获取对应的bucket    let bucket = this.storage[index];    // 3.判断bucket是否为null，是，直接返回null    if(bucket === null) return null;    // 4.线性查找bucket中每一个key是否等于传入的key    for (let i = 0; i &lt; bucket.length; i++) &#123;      const tuple = bucket[i];      if (tuple[0] === key) &#123;        bucket.splice(i, 1);        this.count--;        return tuple[1];      &#125;    &#125;    // 5.依然没有找到    return null;  &#125;  // 判断哈希表是否为空  HashTable.prototype.isEmpty = function () &#123;    return this.count === 0;  &#125;  // 判断哈希表元素的个数  HashTable.prototype.size = function () &#123;    return this.count;  &#125;&#125;\n\n\n\n五、哈希表扩容+ 为什么需要扩容\n\n目前，我们是将所有的数据项放在长度为7的数组中的。\n因为我们使用的是链地址法， load Factor可以大于1，所以这个哈希表可以无限制的插入新数据。\n但是，随着数据量的增多，每—个 index对应的 bucket会越来越长，也就造成效率的降低。\n所以在合适的情况对数组进行扩容。比如扩容两倍。\n\n+ 如何进行扩容\n\n扩容可以简单的将容量增大两倍(不是质数吗?质数的问题后面再讨论)。\n但是这种情况下，所有的数据项一定要同时进行修改(重新调用哈希函数来获取到不同的位置)。\n比如 hash Code&#x3D;12的数据项在 length&#x3D;8的时候 index&#x3D;5。在长度为16的时候呢? index&#x3D;12。\n这是一个耗时的过程，但是如果数组需要扩容，那么这个过程是必要的。\n\n+ 什么情况下需要扩容\n\n比较常见的情况是 Lload Factor&gt;0.75的时候进行扩容。\n比如Java的哈希表就是在&#x3D;&#x3D;装填因子大于0.75&#x3D;&#x3D;的时候，对哈希表进行扩容。\n\n容量质数+ 我们前面提到过，容量最好是质数\n\n虽然在链地址法中将容量设置为质数，没有在开放地址法中重要。\n但是其实链地址法中质数作为容量也更利于数据的均匀分布。\n\n+ 质数的特点\n\n质数也称为素数\n质数表示大于1的自然数中，只能被1和自己整除的数。\n在 2到n-1 中间有可以被整除的数\n\n\n\n+ 判定质数\n\n对于每个数n，其实并不需要从2判断到n-1\n一个数若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n).\n比如16可以被分解。那么是2*8, 2小于sqrt(16)，也就是4，8大于4。而4*4都是等于sqrt(n)\n所以其实我们遍历到等于sqrt(n)即可\n\n // 判断是否是质数HashTable.prototype.isPrime = function (number) &#123;  if(number &lt;= 1) return false;  // 获取number的平方根  const sqrt = parseInt(Math.sqrt(number));  for (let i = 2; i &lt;= sqrt; i++) &#123;    if (number % i === 0) &#123;      return false;    &#125;  &#125;  return true;&#125;// 获取质数：实现恒为质数HashTable.prototype.getPrime = function(number) &#123;  while(!this.isPrime(number)) &#123;    number++;  &#125;  return number;&#125;\n\n// 哈希表扩容/缩容HashTable.prototype.resize = function (newLimit) &#123;  // 1.保存旧数组内容  let oldStorage = this.storage;  // 2.重置所有属性  this.storage = [];  this.count = 0;  this.limit = newLimit  // 3.遍历oldStorage 中所有的bucket  for (let i = 0; i &lt; oldStorage.length; i++) &#123;    // 3.1 取出对应的bucket    const bucket = oldStorage[i];    // 3.2 判断bucket是否为null    if(!bucket) &#123;      continue;    &#125;    // 3.3 bucekt中有数据，那么取出数据，重新插入    for (let i = 0; i &lt; bucket.length; i++) &#123;      const tuple = bucket[i];      this.put(tuple[0], tuple[0])    &#125;  &#125;&#125;// 插入时，扩容HashTable.prototype.put = function (key, value) &#123;  // 1.根据key获取索引值（目的：将数据插入到对应的位置）  let index = this.hashFunc(key, this.limit);  // 2.根据索引值取出bucket  let bucket = this.storage[index];  // 3.判断该bucket是否为null  if (!bucket) &#123;    bucket = [];    this.storage[index] = bucket;  &#125;  // 4.判断是否是修改数据  for (let i = 0; i &lt; bucket.length; i++) &#123;    let tuple = bucket[i];    if(tuple[0] === key) &#123;      tuple[1] = value;      return;    &#125;  &#125;  // 5.进行添加操作  bucket.push([key, value])  this.count += 1;  // 6.判断是否需要扩容  if(this.count &gt; this.limit * 0.75) &#123;    let newPrime = this.getPrime(this.limit * 2);    this.resize(newPrime);  &#125;&#125;// 删除时，减小容量HashTable.prototype.remove = function (key) &#123;  // 1.根据key获取对应的index  let index = this.hashFunc(key, this.limit);  // 2.根据index获取对应的bucket  let bucket = this.storage[index];  // 3.判断bucket是否为null，是，直接返回null  if(bucket === null) return null;  // 4.线性查找bucket中每一个key是否等于传入的key  for (let i = 0; i &lt; bucket.length; i++) &#123;    const tuple = bucket[i];    if (tuple[0] === key) &#123;      bucket.splice(i, 1);      this.count--;      // 缩小容量      if(this.limit &gt; 7 &amp;&amp; this.count &lt; this.limit * 0.25) &#123;        let newPrime = this.getPrime(Math.floor(this.limit / 2));        this.resize(newPrime)      &#125;      return tuple[1];    &#125;  &#125;  // 5.依然没有找到  return null;&#125;\n\n\n\n\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"遍历算法","url":"/2020/03/16/%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/","content":" \n\nconst tree = [   &#123;     value: 1,     children: [       &#123;         value: 2,         children: [&#123; value: 4 &#125;, &#123; value: 5 &#125;]       &#125;,       &#123;         value: 10,         children: [&#123; value: 11 &#125;, &#123; value: 12 &#125;]       &#125;,       &#123;         value: 3,         children: [           &#123;             value: 6,             children: [&#123; value: 7 &#125;, &#123; value: 8 &#125;]           &#125;,           &#123; value: 9 &#125;         ]       &#125;     ]   &#125;]\n\n\n\n深度优先遍历：深度优先搜索算法将会从第—个指定的顶点开始遍历图，沿着路径直到这条路径最后被访问了，接着原路回退并探索条路径。\n\n\nfunction dfs(arr, handler) &#123;  arr.forEach(item =&gt; &#123;    handler(item.value)    if (item.children) &#123;      dfs(item.children, handler);    &#125;  &#125;)&#125;\n\n\n\n广度优先遍历：广度优先算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深的访问顶点。\n\n\nfunction bfs(arr, handler) &#123;  while (arr.length) &#123;    let temp = arr.shift();    handler(temp.value);    if (temp.children) &#123;      temp.children.forEach(item =&gt; &#123;        arr.push(item);      &#125;)    &#125;  &#125;&#125;\n\n\n\n模拟二叉树结构：\nconst node = &#123;  root: &#123;    key: 11,    left: &#123;      key: 7,      left: &#123;        key: 5,        left: &#123;          key: 3,        &#125;,        right: &#123;          key: 6,        &#125;      &#125;,      right: &#123;        key: 9,        left: &#123;          key: 8,        &#125;,        right: &#123;          key: 10,        &#125;      &#125;    &#125;,    right: &#123;      key: 15,      left: &#123;        key: 13,        left: &#123;          key: 12,        &#125;,        right: &#123;          key: 14,        &#125;      &#125;,      right: &#123;        key: 20,        left: &#123;          key: 18,          right: &#123;            key: 19,          &#125;        &#125;,        right: &#123;          key: 25,        &#125;      &#125;    &#125;  &#125;&#125;\n\n前序遍历：function prevSearch(node) &#123;  let resultString1 = &#x27;&#x27;;  prevSearchNode(node.root, (v) =&gt; &#123;    resultString1 += v + &#x27; &#x27;  &#125;)  console.log(resultString1)&#125;function prevSearchNode(node, handler) &#123;  if (node) &#123;    handler(node.key);    prevSearchNode(node.left, handler);    prevSearchNode(node.right, handler);  &#125;&#125;\n\n\n\n","categories":["数据结构"],"tags":["算法"]},{"title":"树","url":"/2019/12/12/%E6%A0%91/","content":" \n\n普通表示法：\n![image-20230403172700286](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230403172700286.png)\n儿子-兄弟 表示法：(模拟二叉树)\n![image-20230403173159644](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230403173159644.png)\nB: {\n​\tthis.data &#x3D; data;\n​\tthis.leftChild &#x3D; E,\n​\tthis.sibling &#x3D; C（this.rightChild &#x3D; E）\n}\nD : {\n​\tthis.data &#x3D; data;\n​\tthis.leftChild &#x3D; H,\n​\tthis.sibling &#x3D; Null（this.rightChild &#x3D; Null）\n}\n树结构 vs 【数组】- 优点：\n\n数组的主要优点是根据&#x3D;&#x3D;下标值访问效率&#x3D;&#x3D;会很高。\n但是如果我们希望根据元素来查找对应的位置呢?\n比较好的方式是先对数组进行排序，再进行二分查找。\n\n- 缺点：\n\n需要&#x3D;&#x3D;先&#x3D;&#x3D;对数组进行&#x3D;&#x3D;排序&#x3D;&#x3D;，生成有序数组，才能提高査找效率。\n另外数组在插入和删除数据时，需要有大量的位移操作(插入到首位或者中间位置的时候，效率很低)。\n\n树结构 vs 【链表】- 优点：\n\n链表的&#x3D;&#x3D;插入和删除操作效率很高&#x3D;&#x3D;。\n\n- 缺点\n\n&#x3D;&#x3D;查找效率很低&#x3D;&#x3D;，需要从头开始依次访问链表中的每个数据项直到找到。\n而且即使插入和删除操作效率很高，但是如果要插入和删除中间位置的数据，还是需要重头先找到对应的数据。\n\n树结构 vs 【哈希表】- 优点：\n\n哈希表的&#x3D;&#x3D;插入&#x2F;查询&#x2F;删除效率&#x3D;&#x3D;都是非常&#x3D;&#x3D;高&#x3D;&#x3D;的。\n\n- 缺点：\n\n&#x3D;&#x3D;空间利用率不高&#x3D;&#x3D;，底层使用的是数组，并且某些单元是没有被利用的。\n哈希表中的元素是无序的，不能按照固定的顺序来遍历哈希表中的元素。\n不能快速的找出哈希表中的最大值或者最小值这些特殊的值。\n\n树结构我们不能说树结构比其他结构都要好，因为每种数据结构都有自己特定的应用场景。\n但是树确实也综合了上面的数据结构的优点(当然优点不足于盖过其他数据结构，比如效率一般情况下没有哈希表高)。\n并且也弥补了上面数据结构的缺点。\n树结构是非线性的，可以表示一对多的关系。\n树的术语n(n&gt;&#x3D;0)个节点构成的有限集合，当n &#x3D; 0时，称为空树；\n1.节点的度(Degree)：节点的子树个数。\n2.树的度：树的所有节点中最大的度数。\n3.叶节点(Leaf)：度为0的节点。(也称为叶子节点)\n4.父节点(Parent)：有子树的节点是其子树的根节点的父节点。\n5.子节点(Chid)：若A节点是B节点的父节点，则称B节点是A节点的子节点；子节点也称孩子节点。\n6.兄弟节点(Sibling)：具有同一父节点的各节点彼此是兄弟节点。\n7.路径和路径长度：从节点η1到nk的路径为一个节点序列n1,n2….,nk,ni是ni+1的父节点。路径所包含边的个数为路径的长度。\n8.节点的层次(Level)：规定根节点在1层，其它任一节点的层数是其父节点的层数加1。\n9.树的深度(Depth)：树中所有节点中的最大层次是这棵树的深度。\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"图论","url":"/2020/02/27/%E5%9B%BE%E8%AE%BA/","content":" \n\n\n\n一、什么是图？\n图结构是一种与&#x3D;&#x3D;树&#x3D;&#x3D;结构有些&#x3D;&#x3D;相似&#x3D;&#x3D;的数据结构.\n图论是数学的一个分支，在数学的概念上，&#x3D;&#x3D;树是图的一种&#x3D;&#x3D;\n它以图为研究对象，研究&#x3D;&#x3D;顶点&#x3D;&#x3D;和&#x3D;&#x3D;边&#x3D;&#x3D;组成的图形的数学理论和方法.\n主要研究的目的是事物之间的关系，顶点代表事物，边代表两个事物间的关系\n\n那么，什么是图呢?\n我们会发现，上面的结点(图中叫&#x3D;&#x3D;顶点 Vertex&#x3D;&#x3D;)之间的关系是不能使用树来表示使用几叉树都不可以模拟\n，这个时候,我们就可以使用图来模拟它们。\n图的特点\n&#x3D;&#x3D;一组顶点&#x3D;&#x3D;：通常用 &#x3D;&#x3D;V(Vertex)&#x3D;&#x3D;表示顶点的集合\n\n&#x3D;&#x3D;一组边&#x3D;&#x3D;∶ 通常用&#x3D;&#x3D;E(Edge)&#x3D;&#x3D;表示边的集合\n\n边是顶点和顶点之间的连线\n\n边可以是&#x3D;&#x3D;有向&#x3D;&#x3D;的也可以是&#x3D;&#x3D;无向&#x3D;&#x3D;的\n\n比如A–B,通常表示无向。A–&gt;B,通常表示有向\n\n\n\n\n二、图的概念顶点:\n表示图中的一个&#x3D;&#x3D;节点&#x3D;&#x3D;\n比如地铁站中某个站&#x2F; 多个村庄中的某个村庄&#x2F; 互联网中的某台主机&#x2F;人际关系中的人\n\n边:\n表示顶点和&#x3D;&#x3D;顶点之间&#x3D;&#x3D;的&#x3D;&#x3D;连线&#x3D;&#x3D;\n比如地铁站中两个站点之间的直接连线，就是—个边\n注意: 这里的边不要叫做路径，路径有其他的概念。\n\n相邻顶点\n由&#x3D;&#x3D;一条边连接在一起的顶点&#x3D;&#x3D;称为相邻顶点\n\n度\n一个顶点的度是&#x3D;&#x3D;相邻顶点的数量&#x3D;&#x3D;.\n\n图一\n\n\n路径\n路径是顶点V1,V2…,Vn的一个&#x3D;&#x3D;连续序列&#x3D;&#x3D;。比如上图中的 0-1-5-9是一条简单的路径\n简单路径:：简单路径要求&#x3D;&#x3D;不包含重复&#x3D;&#x3D;的顶点.\n回路：&#x3D;&#x3D;第一个顶点&#x3D;&#x3D;和&#x3D;&#x3D;最后一个顶点相同的路径&#x3D;&#x3D;称为回路。比如0-1-5-6-3-0\n\n无向图:\n所有的边都&#x3D;&#x3D;没有方向&#x3D;&#x3D;（边没有箭头）\n比如 0 - 1之间有边，那么说明这条边可以保证0 -&gt; 1，也可以保证 1 -&gt; 0\n\n图二\n\n\n有向图:\n图中的边是有方向的（边有箭头）\n比如 0 -&gt; 1，不能保证一定可以 1 -&gt; 0，要根据方向来定\n\n无权图:\n图一\n边没有携带权重(边无关长度和时间的长短)\n边是没有任何意义\n\n带权图：\n图二\n边有一定的权重。这里的权重可以是任意你希望表示的数据\n比如距离或者花费的 时间 或者 票价.\n\n三、图的表示顶点的表示\n使用&#x3D;&#x3D;数组&#x3D;&#x3D;来储存所有&#x3D;&#x3D;顶点&#x3D;&#x3D;\n\n边的表示1.邻接矩阵（非重点）\n\n\n每个节点和一个整数相关联，该整数作为数组的下标值\n用一个二维数组来表示顶点之间的连接.\n在二维数组中，0表示没有连线，1表示有连线\n通过二维数组,我们可以很快的找到一个顶点和哪些顶点有连线\n另外,A-A,B-B(也就是顶点到自己的连线)通常使用O表示\n\n2.邻接表（&#x3D;&#x3D;重点&#x3D;&#x3D;）\n\n\n邻接表由图中每个顶点以及和&#x3D;&#x3D;顶点相邻的顶点列表&#x3D;&#x3D;组成\n这个列表有很多中方式来存储，&#x3D;&#x3D;数组&#x2F;链表&#x2F;字典(哈希表)&#x3D;&#x3D;都可以\n\n- 邻接表的问题\n\n邻接表计算”出度”是比较简单的(出度:指向别人的数量,入度:指向自己的数量)\n邻接表如果需要计算有向图的”λ度”,那么是一件非常麻烦的事情.\n它必须构造一个“逆邻接表”,才能有效的计算“入度”但是开发中“出度”相对用的比较少\n\n四、图的遍历图的遍历思想\n图的遍历思想和&#x3D;&#x3D;树的遍历&#x3D;&#x3D;思想是一样的.\n图的遍历意味着需要将图中&#x3D;&#x3D;毎个顶点访问一遍&#x3D;&#x3D;，并且&#x3D;&#x3D;不能有重复&#x3D;&#x3D;的访问\n\n有两种算法可以对图进行遍历\n&#x3D;&#x3D;广度&#x3D;&#x3D;优先搜索( Breadth-First-search,简称&#x3D;&#x3D;BFS&#x3D;&#x3D;)\n&#x3D;&#x3D;深度&#x3D;&#x3D;优先搜索(Depth-First-search,简称&#x3D;&#x3D;DFS&#x3D;&#x3D;)\n两种遍历算法，都需要明确指定 第一个被访问的顶点\n\n广度优先搜索的思路：广度优先算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层.换句话说，就是先宽后深的访问顶点\n\n\n\n\n广度优先搜索的实现：\n创建一个&#x3D;&#x3D;队列&#x3D;&#x3D;Q\n将V标注为被发现的(灰色)，并将v将入队列Q\n如果Q非空，执行下面的步骤:\n将v从Q中取出队列.\n将ν标注为被发现的灰色\n将ν所有的未被访问过的邻接点(白色)，加入到队列中\n将v标志为黑色.\n\n\n\n深度优先搜索的思路:深度优先搜索算法将会从第—个指定的顶点开始遍历图，沿着路径直到这条路径最后被访问了接着原路回退并探索条路径。\n\n\n\n深度优先搜索算法的实现广度优先搜索算法我们使用的是队列,这里可以使用栈完成,也可以使用递归.方便代码书写,我们还是使用递归(递归本质上就是函数栈的调用)\n\n为了记录顶点是否被访问过，我们使用三种颜色来反应它们的状态\n\n&#x3D;&#x3D;白色&#x3D;&#x3D;：表示该顶点还&#x3D;&#x3D;没有被访问&#x3D;&#x3D;.\n&#x3D;&#x3D;灰色&#x3D;&#x3D;：表示该顶点被访问过，但并&#x3D;&#x3D;未被探索&#x3D;&#x3D;过\n&#x3D;&#x3D;黑色&#x3D;&#x3D;：表示该顶点被访问过且被&#x3D;&#x3D;完全探索&#x3D;&#x3D;过.\n\n五、图结构的封装属性和方法属性：\nvertexes：所有顶点（数组）\nedges：边（字典）\n\n方法：\naddVertex（）：添加顶点；\naddEdge（v1, v2）：添加边, v1,v2表示顶点；\ntoString（）：输出所有顶点\nbfs（）：广度优先搜索\ndfs（）：深度优先搜索；\n\n具体代码： // 封装图结构function Graph() &#123;  // 属性：  // 定点：数组  this.vertexes = [];  // 边：字典  this.edges = new Dictionay();  // 添加定点  Graph.prototype.addVertex = function (v) &#123;    this.vertexes.push(v);    this.edges.set(v, []);  &#125;  // 添加边, v1,v2表示顶点  Graph.prototype.addEdge = function (v1, v2) &#123;    this.edges.get(v1).push(v2);    this.edges.get(v2).push(v1);  &#125;  Graph.prototype.toString = function () &#123;    // 1.定义字符串，保存最终的结果    let resultStr = &#x27;&#x27;;    // 2.遍历所有的顶点，以及顶点对应的边    for (let i = 0; i &lt; this.vertexes.length; i++) &#123;      const vertex = this.vertexes[i];      resultStr += vertex + &#x27;-&gt;&#x27;;      let vEdges = this.edges.get(vertex);      for (let j = 0; j &lt; vEdges.length; j++) &#123;        resultStr += vEdges[j] + &#x27; &#x27;;      &#125;      resultStr += &#x27;\\n&#x27;;    &#125;    return resultStr;  &#125;  Graph.prototype.initializeColor = function () &#123;    let color = [];    for (let i = 0; i &lt; this.vertexes.length; i++) &#123;      const vertex = this.vertexes[i];      color[vertex] = &#x27;white&#x27;;    &#125;    return color;  &#125;  // 广度优先搜索  // initV: 初始化的顶点  Graph.prototype.bfs = function (initV, handler) &#123;    // 1.初始化颜色    const colors = this.initializeColor();    // 2.创建队列    const queue = new Queue();    // 3.将顶点加入到队列中    queue.enqueue(initV);    // 4.循环从队列中取出元素    while (!queue.isEmpty()) &#123;      // 4.1 从队列中取出一个顶点      const v = queue.dequeue();      // 4.2 获取和顶点相连的另外顶点      const vList = this.edges.get(v);      // 4.3 将v的颜色设置成灰色      colors[v] = &#x27;gray&#x27;;      // 4.4 遍历所有的顶点，加入到队列中      for (let i = 0; i &lt; vList.length; i++) &#123;        const e = vList[i];        if (colors[e] === &#x27;white&#x27;) &#123;          colors[e] = &#x27;gray&#x27;;          queue.enqueue(e);        &#125;      &#125;      // 4.5 访问顶点      handler(v);      // 4.6 将顶点设置为黑色      colors[v] = &#x27;black&#x27;;    &#125;  &#125;  // 深度优先搜索  Graph.prototype.dfs = function (initV, handler) &#123;    // 1.初始化颜色    const colors = this.initializeColor();    // 2.从某个顶点开始一次递归访问    this.dfsVisit(initV, colors, handler);  &#125;  Graph.prototype.dfsVisit = function (v, colors, handler) &#123;    // 1.将颜色设置成灰色    colors[v] = &#x27;gray&#x27;;    // 2.处理v顶点    handler(v);    // 3.访问v相连的顶点    const vList = this.edges.get(v);    for (let i = 0; i &lt; vList.length; i++) &#123;      const e = vList[i];      if (colors[e] === &#x27;white&#x27;) &#123;        this.dfsVisit(e, colors, handler);      &#125;    &#125;    // 4.将v设置成黑色    colors[v] = &#x27;black&#x27;;  &#125;&#125;\n\n测试用例：const g = new Graph();// 添加顶点let myVertexes = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;];for (let i = 0; i &lt; myVertexes.length; i++) &#123;  const item = myVertexes[i];  g.addVertex(item)&#125;// 添加边g.addEdge(&#x27;A&#x27;, &#x27;B&#x27;);g.addEdge(&#x27;A&#x27;, &#x27;C&#x27;);g.addEdge(&#x27;A&#x27;, &#x27;D&#x27;);g.addEdge(&#x27;C&#x27;, &#x27;D&#x27;);g.addEdge(&#x27;C&#x27;, &#x27;G&#x27;);g.addEdge(&#x27;D&#x27;, &#x27;G&#x27;);g.addEdge(&#x27;D&#x27;, &#x27;H&#x27;);g.addEdge(&#x27;B&#x27;, &#x27;E&#x27;);g.addEdge(&#x27;B&#x27;, &#x27;F&#x27;);g.addEdge(&#x27;E&#x27;, &#x27;I&#x27;);console.log(g.toString())// 广度优先遍历var bfsResult = &#x27;&#x27;;g.bfs(g.vertexes[0], function (v) &#123;  bfsResult += v + &#x27; &#x27;;&#125;)console.log(&#x27;广度优先搜索：&#x27; + bfsResult)// 深度优先遍历var dfsResult = &#x27;&#x27;;g.bfs(g.vertexes[0], function (v) &#123;  dfsResult += v + &#x27; &#x27;;&#125;)console.log(&#x27;深度优先搜索：&#x27; + dfsResult)\n\n\n\n字典结构// 封装字典结构function Dictionay() &#123;  // 字典属性  this.item = &#123;&#125;;  // 在字典中添加键值对  Dictionay.prototype.set = function (key, value) &#123;    this.item[key] = value;  &#125;  // 判断字典中是否有某个Key  Dictionay.prototype.has = function (key) &#123;    return this.item.hasOwnProperty(key);  &#125;  // 从字典中移除元素  Dictionay.prototype.remove = function (key) &#123;    // 1.判断字典中是否有这个key    if (!this.has(key)) return false;    // 2.从字典中删除key    delete this.item[key];    return true;  &#125;  Dictionay.prototype.get = function (key) &#123;    return this.has(key) ? this.item[key] : undefined;  &#125;  Dictionay.prototype.gets = function () &#123;    return Object.keys(this.item);  &#125;&#125;\n\n\n\n队列结构：function Queue() &#123;  this.items = [];  // 向队列尾部天机一个或多个新的项  Queue.prototype.enqueue = function (el) &#123;    this.items.push(el);  &#125;  // 移出队列的第一项（排在队列最前面的）项，并返回被移出的元素  Queue.prototype.dequeue = function () &#123;    return this.items.shift();  &#125;  // 返回队列中第一个元素——最先被添加，也将是最先被移除的元素。  // 队列不做任何变动，不移除元素，只返回元素  Queue.prototype.front = function () &#123;    return this.items[0]  &#125;  // 如果队列中不包含任何元素，返回true，否则返回false  Queue.prototype.isEmpty = function () &#123;    return this.items.length === 0  &#125;  // 返回队列包含的元素个数，与数组的length属性类似  Queue.prototype.size = function () &#123;    return this.items.length;  &#125;  // 将队列中的内容，转换成字符串形式  Queue.prototype.toString = function () &#123;    return this.items.toString();  &#125;&#125;\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"队列","url":"/2019/08/22/%E9%98%9F%E5%88%97/","content":" \n\n\n一、概念![image-20230401213838127](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230401213838127.png)\n队列（Queue）\n受限的线性结构，&#x3D;&#x3D;先进先出&#x3D;&#x3D;（FIFO First In First Out）\n\n只允许在表的&#x3D;&#x3D;前端进行删除&#x3D;&#x3D;操作，在表的&#x3D;&#x3D;后端进行插入&#x3D;&#x3D;操作\n\n\n队列结构的实现\n基于数组实现\n基于链表实现（链表：也是一种数据结构，JavaScript中没有自带的链表结构）\n\n二、属性和方法队列的方法（6个）：\n\nenqueue(): 向队列尾部添加一个或多个新的项\ndequeue(): 移出队列的第一项，并返回被移出的元素\nfront(): 返回队列中第一个元素\nisEmpty(): 如果队列中不包含任何元素，返回true，否则返回false\nsize(): 返回队列包含的元素个数\ntoString(): 将队列中的内容，转换成字符串形式\n\n代码实现\n/***************  队列的封装 ***********/function Queue() &#123;  this.items = [];  // 向队列尾部天机一个或多个新的项  Queue.prototype.enqueue = function (el) &#123;    this.items.push(el);  &#125;  // 移出队列的第一项（排在队列最前面的）项，并返回被移出的元素  Queue.prototype.dequeue = function () &#123;    return this.items.shift();  &#125;  // 返回队列中第一个元素——最先被添加，也将是最先被移除的元素。  // 队列不做任何变动，不移除元素，只返回元素  Queue.prototype.front = function () &#123;    return this.items[0]  &#125;  // 如果队列中不包含任何元素，返回true，否则返回false  Queue.prototype.isEmpty = function () &#123;    return this.items.length === 0  &#125;  // 返回队列包含的元素个数，与数组的length属性类似  Queue.prototype.size = function () &#123;    return this.items.length;  &#125;  // 将队列中的内容，转换成字符串形式  Queue.prototype.toString = function () &#123;    return this.items.toString();  &#125;&#125;\n\n\n\n三、算法实例击鼓传花游戏\n原游戏规则：\n\n班级中玩一个游戏，所有学生围成一圈，从某位同学手里开始向旁边的同学传一束花。\n这个时候某个人(比如班长)在击鼓，鼓声停下的一颗，花落在谁手里，谁就出来表演节目。\n\n修改游戏规则：\n\n几个朋友一起玩—个游戏，围成一圈，开始数数，数到某个数字的人自动淘汰。\n最后剩下的这个人会获得胜利，请问最后剩下的是原来在哪一个位置上的人?\n\n封装一个基于队列的函数\n\n参数: 所有参与人的姓名，基于的数字。\n结果: 最终剩下的一人的姓名。\n\nfunction passGame(nameList, num) &#123;  // 1.创建一个队列结构  const queue = new Queue();  // 2.将所有人添加到 队列 中  for (const item of nameList) &#123;    queue.enqueue(item)  &#125;  // 3.开始数数  while(queue.size() &gt; 1) &#123;    // - 不是num的时候，重新添加到队列的 末尾    // - 是num这个数字的时候，将其从队列中删除    // 3.1 num数字之前的人，添加到队列的末尾    for (let i = 0; i &lt; num - 1; i++) &#123;      queue.enqueue(queue.dequeue());    &#125;    // 3.2 num数字的这个人，直接从队列中删除    queue.dequeue();  &#125;  // 4.获取最后剩下的那个人  const lastName = queue.front();  console.log(&#x27;剩下的人：&#x27;, lastName)  return nameList.indexOf(lastName);&#125;const index = passGame([&#x27;红&#x27;, &#x27;橙&#x27;, &#x27;黄&#x27;, &#x27;绿&#x27;, &#x27;青&#x27;, &#x27;蓝&#x27;, &#x27;紫&#x27;], 3);console.log(&#x27;剩下人的索引：&#x27;, index)\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"双链表","url":"/2019/10/24/%E5%8F%8C%E9%93%BE%E8%A1%A8/","content":" \n\n一、概念![image-20230402124602154](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230402124602154.png)\n单向链表\n只能从头遍历到尾或者从尾遍历到头(一般从头到尾)，也就是链表相连的过程是 单向 的。\n实现的原理是上一个链表中有一个指向下一个的引用。\n\n单链表的缺点：\n\n我们可以轻松的到达下一个节点，但是回到前一个节点是很难的。\n但是，在实际开发中，经常会遇到需要回到上一个节点的情况。\n\n举个例子：\n假设一个文本编辑用链表来存储文本。每一行用一个 String 对象存储在链表的一个节点中。\n当编辑器用户向下移动光标时，链表直接操作到下一个节点即可。但是当用于将光标向上移动呢？\n这个时候为了回到上一个节点，我们可能需要从first开始，依次走到想要的节点上。\n\n\n双向链表\n既可以从头遍历到尾，又可以从尾遍历到头。也就是链表的相连过程是双向的，\n一个节点既有向前连接的引用，也有一个向后连接的引用。\n\n优点：\n\n每次在插入或删除某个节点时，需要处理四个引用，而不是两个。实现起来要困难一些。\n相对于单向链表，占用的内存空间更大一些。\n\n结构模型\nhead -&gt; { prev, data, next } -&gt; { prev, data, next } -&gt; { prev, data, next(tail) } -&gt; null;\n\n\nhead 指向头部节点；\n\ntail 指向尾部节点；\n\nprev 指向上一个节点；\n\nnext 指向下一个节点；\n\ndata 当前节点数据\n\n\n第一个节点的  prev 是 null\n最后一个节点的 next 是 null\n二、属性和方法链表的属性：\n\nhead: 头部节点\nnode: 节点\ndata: 节点数据\nprev：指向下一个节点的\nnext：指向下一个节点的\n\n\ntail: 尾部节点\nlength: 链表长度\n\n链表的方法（6个）：\n\nappend(data)：向链表尾部添加一个新的项\ninsert(position, data)：向链表的特定位置 插入一个新的项\nget(position)：获取对应位置的元素\nindexOf(data)：返回元素在链表中的索引。如果链表中没有该元素，则返回-1\nupdate(position, data)：修改某个位置的元素\nremoveAt(position)：从链表的特定位置删除一项\nremove(data)：从列表中删除一项\ngetHead()：获取头部节点\nforwardString()：返回向前遍历的节点字符串形式\nbackwordString()：返回向后遍历的节点字符串形式\ngetTail()：获取尾部节点\nisEmpty()：如果链表中不包含任何元素，返回true；否则返回false\nsize()：返回链表中包含的元素个数\ntoString()：将链表中的内容，转换成字符串形式\n\n具体实现：\n/***************  链表封装 ***********/function DoublyLinkedList() &#123;  // 内部类：节点类  function Node(data) &#123;    this.data = data;    this.prev = null;    this.next = null;  &#125;  // 属性  this.head = null;  this.tail = null;  this.length = 0;  // 向列表尾部添加一个新的项  DoublyLinkedList.prototype.append = function (data) &#123;    const node = new Node(data);    // 第一个节点    if (this.length === 0) &#123;      this.head = node;      this.tail = node;    &#125; else &#123;      node.prev = this.tail;      this.tail.next = node;      this.tail = node;    &#125;    this.length++;  &#125;  // 向列表的特定位置 插入一个新的项  DoublyLinkedList.prototype.insert = function (position, data) &#123;    // 1.越界判断    if (position &lt; 0 || position &gt; this.length) &#123;      return false    &#125;    // 2.创建节点数据    const node = new Node(data);    // 3.判断 原列表 是否为空    if (this.length === 0) &#123;      this.head = node;      this.tail = node;    &#125; else &#123;      // 3.1 插入的是第一个节点      if (position === 0) &#123;        this.head.prev = node;        node.next = this.head;        this.head = node;      &#125; else if (position === this.length) &#123; // 3.2 插入的是 最后一个节点        this.tail.next = node;        node.prev = this.tail;        this.tail = node;      &#125; else &#123; // 3.3 在中间位置插入        let currentNode = this.head;        let index = 0;        while (index++ &lt; position) &#123;          currentNode = currentNode.next;        &#125;        node.next = currentNode;        node.prev = currentNode.prev        currentNode.prev.next = node;        currentNode.prev = node;      &#125;    &#125;    this.length++;    return true;  &#125;  // 获取对应位置的 元素  DoublyLinkedList.prototype.get = function (position) &#123;    if (position &lt; 0 || position &gt;= this.length) &#123;      return null;    &#125;    let currentNode = this.head;    let index = 0;    while(index++ &lt; position) &#123;      currentNode = currentNode.next;    &#125;    return currentNode.data;  &#125;  // 返回元素在列表中的索引。如果列表中没有该元素，则返回-1  DoublyLinkedList.prototype.indexOf = function (data) &#123;    let curentNode = this.head;    let index = 0;    while(index &lt; this.length) &#123;      if (curentNode.data === data) &#123;        return index;      &#125;      curentNode = curentNode.next;      index++    &#125;    return -1;  &#125;  // 修改某个位置的元素  DoublyLinkedList.prototype.update = function (position, data) &#123;    if(position &lt; 0 || position &gt;= this.length) &#123;      return false;    &#125;    let curentNode = this.head;    let index = 0;    while(index++ &lt; position) &#123;      curentNode = curentNode.next;    &#125;    curentNode.data = data;    return true;  &#125;  // 从列表的特定位置删除一项  DoublyLinkedList.prototype.removeAt = function (position) &#123;    if(position &lt; 0 || position &gt;= this.length) &#123;      return null;    &#125;    let curentNode = this.head;    // 只有一个节点    if (this.length === 1) &#123;      this.head = null      this.tail = null;    &#125; else &#123;      if (position === 0) &#123; // 删除的是 第一个节点        this.head.next.prev = null;        this.head = this.head.next;      &#125; else if (position === this.length - 1) &#123; // 删除的是 最后一个节点        curentNode = this.tail;        this.tail.prev.next = null;        this.tail = this.tail.prev;      &#125; else &#123; // 删除的是 中间部分的节点        let index = 0;        while(index++ &lt; position) &#123;          curentNode = curentNode.next;        &#125;        curentNode.prev.next = curentNode.next;        curentNode.next.prev = curentNode.prev;      &#125;    &#125;    this.length--;    return curentNode.data;  &#125;  // 从列表中删除一项  DoublyLinkedList.prototype.remove = function (data) &#123;    // 1.根据元素获取 其位置    const postion = this.indexOf(data);    // 2.根绝位置信息，删除节点    return this.removeAt(postion);  &#125;  DoublyLinkedList.prototype.getHead = function () &#123;    return this.head.data;  &#125;  DoublyLinkedList.prototype.getTail = function () &#123;    return this.tail.data;  &#125;  // 如果链表中不包含任何元素，返回true；否则返回false  DoublyLinkedList.prototype.isEmpty = function () &#123;    return this.length === 0;  &#125;  // 返回链表中包含的元素个数  DoublyLinkedList.prototype.size = function () &#123;    return this.length  &#125;  // 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值  DoublyLinkedList.prototype.toString = function () &#123;    return this.backwordString();  &#125;  // 返回向前遍历的节点字符串形式  DoublyLinkedList.prototype.forwardString = function () &#123;    let current = this.tail;    let listString = &#x27;&#x27;;    while (current) &#123;      listString += current.data + &#x27; &#x27;;      current = current.prev;    &#125;    return listString;  &#125;  // 返回向后遍历的节点字符串形式  DoublyLinkedList.prototype.backwordString = function () &#123;    let current = this.head;    let listString = &#x27;&#x27;;    while (current) &#123;      listString += current.data + &#x27; &#x27;;      current = current.next;    &#125;    return listString;  &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"栈","url":"/2019/09/21/%E6%A0%88/","content":" \n\n一、概念\n\n\n\n数组和栈\n数组是一种线性结构，可以在 任意位置 插入和删除数据\n栈和队列 是 &#x3D;&#x3D;受限制的线性结构&#x3D;&#x3D;\n\n栈结构\n是一种受限的线性表，&#x3D;&#x3D;先进后出&#x3D;&#x3D; LIFO（last in first out）， 后进先出。\n仅允许在表的一端进行插入和删除，这一端成为&#x3D;&#x3D;栈顶&#x3D;&#x3D;。相对地，另一端为栈底。\n向一个栈插入新元素又称 &#x3D;&#x3D;进栈&#x3D;&#x3D;、入栈或压栈)、出栈(退栈)\n向一个栈删除元素又称作 &#x3D;&#x3D;出栈&#x3D;&#x3D;、退栈\n\n程序中的栈实现\n函数调用栈\nA调用B，B中又调用了C，C中又调用D；\n执行过程中，先将A压入栈，A没有执行完，不会退出栈\n依次将B&#x2F;C&#x2F;D压入到栈中，D压入到栈顶。当前栈顺序是 栈底A-&gt;B-&gt;C-&gt;D栈顶\nD执行完，弹出栈。C&#x2F;B&#x2F;A 依次出栈\n函数调用栈的称呼，就来自于其内部的实现机制（通过栈来实现的）。\n\n\n递归（容易引发栈溢出）\n\n栈结构的实现\n基于数组实现\n基于链表实现（链表：也是一种数据结构，JavaScript中没有自带的链表结构）\n\n二、属性和方法栈的方法（6个）：\n\npush(element): 添加一个新元素到栈顶位置\npop(): 移出栈顶位置，同时返回被移出的元素\npeek(): 返回栈顶的元素，不对栈做任何修改\nisEmpty(): 如果栈里没有任何元素就返回true，否则返回false\nsize(): 返回栈元素的个数\ntoString(): 将栈结构的内容以字符形式返回\n\n具体代码实现\n// 基于数组的实现function Stack() &#123;  // 栈的属性  this.items = [];  // push(element): 添加一个新元素到栈顶位置  Stack.prototype.push = function (element) &#123;    this.items.push(element);  &#125;  // pop(): 移出栈顶位置，同时返回被移出的元素  Stack.prototype.pop = function () &#123;    return this.items.pop();  &#125;  // peek(): 返回栈顶的元素，不对栈做任何修改  Stack.prototype.peek = function () &#123;    return this.items[this.items.length - 1];  &#125;  // isEmpty(): 如果栈里没有任何元素就返回true，否则返回false  Stack.prototype.isEmpty = function () &#123;    return this.items.length === 0;  &#125;  // size(): 返回栈元素的个数  Stack.prototype.size = function () &#123;    return this.items.length;  &#125;  // toString(): 将栈结构的内容以字符形式返回  Stack.prototype.toString = function () &#123;    return this.items.toString();  &#125;&#125;\n\n\n\n// 栈的使用const stack = new Stack();stack.push(1)stack.push(2)stack.push(3)stack.items = [1,2,3]console.log(stack.items)console.log(stack.peek())\n\n\n\n三、算法实例/***************  十进制转二进制 ***********/// 方法：除以2，直到商为0，倒着取全部的余数function dec2bin(decNumber) &#123;  // 1.定义栈对象，用于保存余数  let stack = new Stack();  // 2.循环取余数  while(decNumber &gt; 0) &#123;    // 2.1 获取余数，放入到栈中    stack.push(decNumber % 2);    // 2.2 获取整除后的结果，作为下一次循环的数字    decNumber = Math.floor(decNumber / 2);  &#125;  // 3.从栈中取出余数  let binaryString = &#x27;&#x27;;  while(!stack.isEmpty()) &#123;    binaryString += stack.pop();  &#125;  return binaryString;&#125;\n\n\n\n\n\n\n\n\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"优先级队列","url":"/2019/09/05/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/","content":" \n\n一、概念![image-20230401213838127](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230401213838127.png)\n优先级队列的特点：\n优先级队列，在插入一个元素的时候会考虑该数据的优先级。\n和其他数据优先级进行比较。\n比较完成后，可以得出这个元素在队列中正确的位置。\n其他处理方式和基本队列的处理方式一样。\n\n优先级队列主要考虑的问题\n每个元素不再只是一个数据，而且包含数据的优先级。\n在添加方式中，根据优先级放入正确的位置。\n\n优先级队列的应用\n登机顺序（头等舱、商务舱、经济舱）\n急诊科（严重患者，普通排号患者）\n计算机中，通过 优先级队列 来重新排序队列中任务的顺序\n\n二、属性和方法队列的方法（6个）：\n\nenqueue(): 向队列尾部添加一个或多个新的项\ndequeue(): 移出队列的第一项，并返回被移出的元素\nfront(): 返回队列中第一个元素\nisEmpty(): 如果队列中不包含任何元素，返回true，否则返回false\nsize(): 返回队列包含的元素个数\ntoString(): 将队列中的内容，转换成字符串形式\n\n代码实现\n/***************  优先级队列的封装 ***********/function PriorityQueue() &#123;  function QueueElement(element, priority) &#123;    this.element = element;    this.priority = priority;  &#125;  // 属性  this.items = [];  // 插入方法  PriorityQueue.prototype.enqueue = function (element, priority) &#123;    // 1.创建QueueElement 对象    let queueElement = new QueueElement(element, priority);    // 2.判断队列是否为空    if (this.items.length === 0) &#123;      this.items.push(queueElement);    &#125; else &#123;      let added = false;      for (let i = 0; i &lt; this.items.length; i++) &#123;        const item = this.items[i];        if (queueElement.priority &lt; item.priority) &#123;          this.items.splice(i, 0, queueElement);          added = true;          break;        &#125;      &#125;      if (!added) &#123;        this.items.push(queueElement);      &#125;    &#125;  &#125;  // 移出队列的第一项（排在队列最前面的）项，并返回被移出的元素  PriorityQueue.prototype.dequeue = function () &#123;    return this.items.shift();  &#125;  // 返回队列中第一个元素——最先被添加，也将是最先被移除的元素。  // 队列不做任何变动，不移除元素，只返回元素  PriorityQueue.prototype.front = function () &#123;    return this.items[0]  &#125;  // 如果队列中不包含任何元素，返回true，否则返回false  PriorityQueue.prototype.isEmpty = function () &#123;    return this.items.length === 0  &#125;  // 返回队列包含的元素个数，与数组的length属性类似  PriorityQueue.prototype.size = function () &#123;    return this.items.length;  &#125;  // 将队列中的内容，转换成字符串形式  PriorityQueue.prototype.toString = function () &#123;    return this.items.toString();  &#125;&#125;\n\n测试：\nconst pq = new PriorityQueue();pq.enqueue(&#x27;aa&#x27;, 100)pq.enqueue(&#x27;bb&#x27;, 200)pq.enqueue(&#x27;cc&#x27;, 50)pq.enqueue(&#x27;dd&#x27;, 80)pq.enqueue(&#x27;ee&#x27;, 60)console.log(pq)\n\n","categories":["数据结构"],"tags":["数据结构","算法"]},{"title":"排序算法","url":"/2020/04/01/z%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","content":" \n\n排序算法排序算法有很多：冒泡排序&#x2F;选择排序&#x2F;插入排序&#x2F;归并排序&#x2F;计数排序( counting sort)&#x2F;基数排序(radix sort)&#x2F;希尔排序&#x2F;堆排序&#x2F;桶排序；\n\n简单排序：冒泡排序 - 选择排序 - 插入排序；\n高级排序：希尔排序 - 快速排序 - 归并排序 - 堆排序。\n非比较排序：计数排序 - 基数排序 - 桶排序；\n\n一、冒泡排序\n从序列的一端开始往另一端冒泡，依次&#x3D;&#x3D;比较相邻&#x3D;&#x3D;的两个数的大小\n\n如果 左边的数大，则两数交换位置；\n向右移动一个位置 比较下面两个数；\n当走到 最右端时，最大的数 一定被放在了最右边；\n按照这个思路，从最左端重新开始，这次走到倒数第二个位置的数；\n即可依次类推，就可以将数据排序完成。\n\nArray.prototype.swap = function (m, n) &#123;  let temp = this[m];  this[m] = this[n];  this[n] = temp;&#125;function bubbleSort(array) &#123;  const len = array.length;  for (let i = 0; i &lt; len - 1; i++) &#123;    for (let j = 0; j &lt; len - i - 1; j++) &#123;      if (array[j] &gt; array[j + 1]) &#123;        array.swap(j, j + 1);      &#125;    &#125;  &#125;&#125;\n\n\n\n代码解析:\n\n获取数组的长度；\n外层循环应该让j依次减少，因此我们这里使用了反向的遍历；\n内层循环我们使用i &lt; j。因为上面的j在不断减小，这样就可以控制内层循环的次数；\n比较两个数据项的大小，如果前面的大，那么就进行交换；\n\n比较次数：\n\n假如一共有7个数字；\n第一次循环6次比较，第二次5次比较，第三次4次比较…到最后一趟进行了1次比较；\n对于7个数据项比较次数：6+5+4+3+2+1；\n对于N个数据项：(N-1)+(N-2)+(N-3)+…+1 &#x3D; N*(N-1)&#x2F;2。\n\n冒泡排序的O表示法：\n\nN*(N-1)&#x2F;2 &#x3D; N²&#x2F;2 - N&#x2F;2，根据规则2，只保留最高阶项变成N²&#x2F;2；\nN²&#x2F;2，根据规则3，去除最高项的常量，变成N²；\n因此冒泡排序的比较次数的大O表示法为&#x3D;&#x3D;O(N²)&#x3D;&#x3D;；\n\n冒泡排序交换次数：\n\n真实的次数: N*(N-1)&#x2F;4；【两次比较，需要一次交换】\n冒泡排序的交换次数是多少呢?\n如果有两次比较才需要交换一次(不可能每次比较都交换一次)，那么交换次数为 N²&#x2F;4\n由于常量不算在大O表示法中，因此，我们可以认为交换次数的大O表示也是&#x3D;&#x3D;O(N²)&#x3D;&#x3D;\n\n二、选择排序\n思路：\n\n1.取第一个数，和其他数依次比较，获得最小的数，将最小的数与第一个数交换位置，\n这样第一个数就是最小的数；\n\n2.依次取2、3、4…个数，重复第一步；\n\n\nfunction selectionSort(array) &#123;  for (let i = 0; i &lt; array.length - 1; i++) &#123;    let minIndex = i;    for (let j = i + 1; j &lt; array.length; j++) &#123;      if (array[minIndex] &gt; array[j]) &#123;        minIndex = j;      &#125;    &#125;    array.swap(minIndex, i);  &#125;&#125;\n\n代码解析：\n\n1.取一个临时变量min，表示最小值的索引；\n2.取第一个数，去和其他数比较，当arr[min] &gt; arr[other]时，min &#x3D; other;\n3.一轮比较下来之后，min就是最小值的索引，然后与第一个数 交换位置，这样第一个数就是最小的数；\n4.取第二个数，循环以上操作，得到剩余元素中最小的值，与第二个数交换位置；\n5.重复以上步骤，即可排序；\n\n比较次数：\n\n假如一共有7个数字；\n第一次循环6次比较，第二次5次比较，第三次4次比较…到最后一趟进行了1次比较；\n对于7个数据项比较次数：6+5+4+3+2+1；\n对于N个数据项：(N-1)+(N-2)+(N-3)+…+1 &#x3D; N*(N-1)&#x2F;2。\n\n选择排序的O表示法：\n\n与冒泡排序一样，O(N²)；\n\n选择排序交换次数：\n\n每次比较最多（也可能不交换）只需要交换一次，一共需要 N-1 次;\n用大O表示法，就是O(N);\n所以选择排序通常认为在执行&#x3D;&#x3D;效率上是 高于 冒泡排序&#x3D;&#x3D;的。\n\n三、插入排序\n插入排序：\n\n插入排序是&#x3D;&#x3D;简单排序中效率最好&#x3D;&#x3D;的一种\n插入排序也是学习其他&#x3D;&#x3D;高级排序的基础&#x3D;&#x3D;，比如希尔排序&#x2F;快速排序，所以也非常重要.\n\n局部有序：\n\n插入排序思想的核心是局部有序。什么是局部有序呢？\n比如在一个队列中的人，我们选择其中一个作为标记的队员；\n这个 被标记的队员左边 的所有队员已经是局部有序的；\n这意味着，有一部分人是按顺序排列好的，有一部分还没有顺序。\n\n思路：\n\n从第一个元素开始，该元素可以认为已经被排序；\n取出下一个元素，在已经排序的元素序列中从后向前扫描；\n如果该元素(已排序)大于新元素，将该元素移到下一位置；\n重复上一个步骤，直到找到已排序的元素小于或者等于新元素的位置；\n将新元素插入到该位置后，重复上面的步骤。\n\nfunction insertionSort(array) &#123;  for (let i = 1; i &lt; array.length; i++) &#123;    let j = i;    let current = array[i];    while (current &lt; array[j - 1] &amp;&amp; j &gt; 0) &#123;      array[j] = array[j - 1]      j--;    &#125;    array[j] = current;  &#125;&#125;\n\n\n\n比较次数：\n\n第一次，最多需要比较一次，第二次最多需要2次，以此类推，最后一次是 N-1 次；\n因此插入排序的最多比较次数是：1+2+3+…+N-1 &#x3D; N*(N-1)&#x2F;2;\n然而毎趟发现插入点之前，平均只有全体数据项的一半需要进行比较我们可以除以2得到N*(N-1)&#x2F;4.\n所以相对于选择排序，其比较次数是少了一半的。\n\n插入排序的复制次数：\n\n第一趟时，需要的最多复制次数是1，第二趟最多次数是2，依次类推，最后一趟是N-1次；\n因此复制次数最多是1+2+3+…+N-1&#x3D;N*N-1)&#x2F;2；\n平均次数N*(N-1)&#x2F;4。\n\n对于基本有序的情况:\n\n对于已经有序或基本有序的数据来说，插入排序要好很多；\n当数据有序的时候 while循环的条件总是为假，所以它变成了外层循环中的个简单语句，执行N-1次；\n在这种情况下，算法运行至需要O(N)的时间，效率相对来说会更高；\n另外别忘了，我们的比较次数是选择排序的一半，所以这个算法的 效率 是 高于 选择排序 的。\n\n四、希尔排序希尔排序：\n\n希尔排序是插入排序的一种高效的改进版,并且效率比插入排序要更快.\n插入排序也是学习其他高级排序的基础，比如希尔排序&#x2F;快速排序，所以也非常重要.\n\n思路：\n比如下面的数字，81,94,11,96,12,35,17,95,28,58,41,75,15：\n\n\n\n我们先让间隔为5，进行排序：\n\n(35,81)，(94,17)，(11,95)，(96,28)，(12,58)，(35,41)，(17,75)，(95,15)\n\n排序后的新序列一定可以让数字离自己的正确位置更近一步。\n\n\n\n我们再让间隔位3，进行排序：\n\n(35,28,75,58,95)，(17,12,15,81)，(11,41,96,94)\n\n排序后的新序列，一定可以让数字离自己的正确位置又近了一步最后。\n\n\n\n我们让间隔为1，也就是正确的插入排序。\n\n这个时候数字都离自己的位置更近，那么需要复制的次数一定会减少很多。\n\n\n\nfunction shellSort(array) &#123;   // 1.获取数组长度  const len = array.length;  // 2.初始化增量  let gap = Math.floor(len / 2);  // 3.while循环，gap不断减小至1  while (gap &gt;= 1) &#123;    // 4.以gap作为间隙，进行分组，对分组进行插入排序    for (let i = gap; i &lt; len; i++) &#123;      let j = i;      let current = array[i];      while (current &lt; array[j - gap] &amp;&amp; j - gap &gt; -1) &#123;        array[j] = array[j - gap]        j-= gap;      &#125;      // 5.将j位置元素赋值 current      array[j] = current;    &#125;    // 6.增量变化    gap = Math.floor(gap / 2);  &#125;&#125;\n\n\n\n\n\n希尔排序的效率：\n\n希尔排序的效率很增量是有关系的；\n但是，它的效率证明非常困难，甚至某些增量的效率到目前依然没有被证明岀来；\n但是经过统计，希尔排序使用原始增量，最坏的情况下时间复杂度为O(N²)，通常&#x3D;&#x3D;情况下都要好于O(N²)&#x3D;&#x3D;。\n\n总之我们使用希尔排序大多数情况下效率都高于简单排序：\n\n这个可以通过统计排序算法的时间来证明；\n甚至在合适的增量和某些数量N的情况下，还好好于快速排序。\n\n五、快速排序\n\n\n\n\n\n快速排序：\n\n快速排序几乎可以说是目前所有排序算法中，&#x3D;&#x3D;最快&#x3D;&#x3D;的一种&#x3D;&#x3D;排序算法&#x3D;&#x3D;；\n当然，没有任何一种算法是在任意情况下都是最优的；\n比如希尔排序确实在某些情况下可能好于快速排序；\n但是大多数情况下，快速排序还是比较好的选择。\n\n&#x3D;&#x3D;希尔&#x3D;&#x3D;排序相当于&#x3D;&#x3D;插入&#x3D;&#x3D;排序的升级版，\n&#x3D;&#x3D;快速&#x3D;&#x3D;排序是&#x3D;&#x3D;冒泡&#x3D;&#x3D;排序的升级版\n&#x3D;&#x3D;枢纽&#x3D;&#x3D; (pivot) 的选择：\n\n一种方案是直接选择第一个元素作为枢纽，但是效率不高\n另一种比较优秀的方案是，取&#x3D;&#x3D;头、中、尾的中位数&#x3D;&#x3D;。例如：8、12、3、的中位数是8。\n\n\n\n\n\n&#x3D;&#x3D;最坏&#x3D;&#x3D;情况效率：\n\n每次选择的&#x3D;&#x3D;枢纽&#x3D;&#x3D;都是&#x3D;&#x3D;最左边&#x3D;&#x3D;或者&#x3D;&#x3D;最后边&#x3D;&#x3D;的，那么效率等&#x3D;&#x3D;同于冒泡排序&#x3D;&#x3D;；\n而我们的例子可能有最坏的情况吗？是不可能的.因为我们是选择三个值的中位值。\n\n&#x3D;&#x3D;平均效率&#x3D;&#x3D;：\n\n快速排序的平均效率是&#x3D;&#x3D;O(N*logN)&#x3D;&#x3D;\n虽然其他某些算法的效率也可以达到O(N*logN)，但是快速排序是最好的\n\n枢纽为中位数：\nfunction quickSort(array) &#123;  sort(0, array.length - 1);  function sort(left, right) &#123;    if (left &gt;= right) return;    const pivot = median(array, left, right);    let i = left;    let j = right - 1;    while (i &lt; j) &#123;      while (array[++i] &lt; pivot) &#123; &#125;;      while (array[--j] &gt; pivot) &#123; &#125;;      if (i &lt; j) &#123;        swap(array, i, j);      &#125;    &#125;    swap(array, i, right - 1);    sort(left, i - 1);    sort(i + 1, right)  &#125;  function swap(array, m, n) &#123;    const temp = array[m];    array[m] = array[n]    array[n] = temp;  &#125;  function median(array, left, right) &#123;    let center = Math.floor((left + right) / 2);    // 2.判断大小，并进行交换位置    if (array[left] &gt; array[center]) &#123;      swap(array, left, center);    &#125;    if (array[center] &gt; array[right]) &#123;      swap(array, center, right);    &#125;    if (array[left] &gt; array[center]) &#123;      swap(array, left, center);    &#125;    // 3.将中位数与倒数第二个数交换    swap(array, center, right - 1);    // 4.返回枢纽数（即：交换后的中位数，倒数第二个数）    return array[right - 1];  &#125;&#125;\n\n\n\n枢纽为 最左边&#x2F;最右边&#x2F;中间数&#x2F;任意数：\nfunction quickSort(array) &#123;  sort(0, array.length - 1);  function sort(left, right) &#123;    if (left &gt;= right) return;    const pivotIndex = Math.floor((left + right) / 2);    const pivot = array[pivotIndex];    swap(array, right, pivotIndex);    let i = left;    let j = right - 1;    while (i &lt;= j) &#123;      while (array[i] &lt; pivot) &#123; i++ &#125;;      while (array[j] &gt; pivot) &#123; j-- &#125;;      if (i &lt;= j) &#123;        swap(array, i, j);      &#125;    &#125;    swap(array, i, right);    sort(left, i - 1);    sort(i + 1, right)  &#125;  function swap(array, m, n) &#123;    const temp = array[m];    array[m] = array[n]    array[n] = temp;  &#125;&#125;\n\n\n\n![image-20230410143729163](&#x2F;Users&#x2F;xiongchao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230410143729163.png)\n","categories":["数据结构"],"tags":["算法"]},{"title":"集合","url":"/2019/11/11/%E9%9B%86%E5%90%88Set/","content":" \n\n一、概念集合结构\n集合通常是由一组无序的，不能重复的元素构成。\n集合中的元素不允许重复。\n特殊的数组：\n元素&#x3D;&#x3D;没有顺序，不能重复&#x3D;&#x3D;。\n没有顺序意味着&#x3D;&#x3D;不能通过下标访问&#x3D;&#x3D;；\nES6 中的 Set结构 就是一种集合结构\n\n\n\n二、属性和方法集合的方法：\n\nadd()：向集合中添加一个新的元素\nremove()：从集合中移除一个元素\nhas()：检查元素是否存在于集合中，若存在，返回true，否则返回false\nclear()：移除集合中的所有元素\nsize()：返回集合所包含的元素的数量\nvalues()：返回一个包含集合中所有值的数组\nunion()：并集\nintersection()：交集\ndefference()：差集\nsubset()：子集， A是否是B的子集\n\n具体实现\n/***************  集合结构 ***********/function Set() &#123;  // 属性（不用数组，用对象的原因：数组允许元素重复）  this.items = &#123;&#125;;  // 向集合中添加一个新的元素  Set.prototype.add = function (value) &#123;    if (this.has(value)) &#123;      return false;    &#125;    this.items[value] = value;    return true;  &#125;  // 从集合中移除一个元素  Set.prototype.remove = function (value) &#123;    if(!this.has(value))&#123;      return false;    &#125;    delete this.items[value];    return true;  &#125;  // 检查元素是否存在于集合中，若存在，返回true，否则返回false  Set.prototype.has = function (value) &#123;    return this.items.hasOwnProperty(value);  &#125;  // 移除集合中的所有元素  Set.prototype.clear = function () &#123;    this.items = &#123;&#125;;  &#125;  // 返回集合所包含的元素的数量  Set.prototype.size = function () &#123;    return Object.keys(this.items).length;  &#125;  // 返回一个包含集合中所有值的数组  Set.prototype.values = function () &#123;    return Object.keys(this.items);  &#125;  // 集合间的操作  // 并集  Set.prototype.union = function(otherSet) &#123;    // this:     集合A    // otherSet: 集合B    // 1.创建新集合    const unionSet = new Set();    // 2.将A集合的成员添加到 新集合 中    const values = this.values();    for (let i = 0; i &lt; values.length; i++) &#123;      unionSet.add(values[i]);    &#125;    // 3取出B集合中的元素，添加到新集合中    const values2 = otherSet.values();    for (let i = 0; i &lt; values2.length; i++) &#123;      unionSet.add(values2[i]);    &#125;    return unionSet;  &#125;  // 交集  Set.prototype.intersection = function(otherSet) &#123;    // this:     集合A    // otherSet: 集合B    // 1.创建新集合    const intersectionSet = new Set();    // 2取出 同时存在于 B集合中 和 A集合 的元素，添加到 新集合中    const values = this.values();    for (let i = 0; i &lt; values.length; i++) &#123;      const item_a = values[i]      if (otherSet.has(item_a)) &#123;        intersectionSet.add(item_a);      &#125;    &#125;    return intersectionSet;  &#125;  // 差集  Set.prototype.defference = function(otherSet) &#123;    // this:     集合A    // otherSet: 集合B    // 1.创建新集合    const defferenceSet = new Set();    // 2.将不存在B集合 中的元素添加到 新集合中    const values = this.values();    for (let i = 0; i &lt; values.length; i++) &#123;      const item_a = values[i]      if (!otherSet.has(item_a)) &#123;        defferenceSet.add(item_a);      &#125;    &#125;    return defferenceSet;  &#125;  // 子集， A是否是B的子集  Set.prototype.subset = function(otherSet) &#123;    // this:     集合A    // otherSet: 集合B    // 1.创建新集合    const subSet = new Set();    // 2.遍历A集合中的所有元素，如果发现集合A中的元素，在集合B中不存在，则返回flase    const values = this.values();    for (let i = 0; i &lt; values.length; i++) &#123;      const item = values[i];      if(!otherSet.has(item)) &#123;        return false;      &#125;    &#125;    return true;  &#125;&#125;\n\n测试用例：\nconst set = new Set();set.add(&#x27;aa&#x27;);set.add(&#x27;bb&#x27;);set.add(&#x27;cc&#x27;);set.add(&#x27;dd&#x27;);set.remove(&#x27;dd&#x27;);set.values(); // [&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;]set.has(&#x27;aa&#x27;); // trueset.has(&#x27;dd&#x27;); // falseset.size(); // 3 [&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;]const otherSet = new Set();otherSet.add(&#x27;cc&#x27;);otherSet.add(&#x27;dd&#x27;);console.log(&#x27;集合A：&#x27;, set.values());console.log(&#x27;集合B：&#x27;, otherSet.values());const unionSet = set.union(otherSet);console.log(&#x27;并集：&#x27;, unionSet.values());const intersectionSet = set.intersection(otherSet);console.log(&#x27;交集：&#x27;, intersectionSet.values());const defferenceSet = set.defference(otherSet);console.log(&#x27;差集：&#x27;, defferenceSet.values());console.log(&#x27;*************** 子集 *****************&#x27;)const setC = new Set();setC.add(&#x27;aa&#x27;);setC.add(&#x27;bb&#x27;);setC.add(&#x27;cc&#x27;);setC.add(&#x27;dd&#x27;);console.log(&#x27;集合C：&#x27;, setC.values());const subSet1 = set.subset(otherSet);console.log(&#x27;A是B的子集：&#x27;, subSet1);const subSet2 = set.subset(setC);console.log(&#x27;A是C的子集：&#x27;, subSet2);\n\n","categories":["数据结构"],"tags":["数据结构","算法"]}]