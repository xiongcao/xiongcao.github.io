[{"title":"Ajax跨域的几种解决方案","url":"/2018/08/14/Ajax%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":" \n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个前后端分离越来越流行的时代，跨域请求对于我们来说已经非常常见了。关于跨域，有N种类型，本文只专注于ajax请求跨域。\n何为跨域请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号 (如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等。\n几种常见跨域请求\n\n\n请求地址\n服务器地址\n结果\n\n\n\nhttp://www.123.com\nhttp://www.abc.com\n(主域名不同，跨域)\n\n\nhttp://123.xiongchao.com\nhttp://abc.xiongchao.com\n(子域名不同，跨域)\n\n\nhttp://www.xiongchao.com:8080\nhttp://www.xiongchao.com:8081\n(端口不同，跨域)\n\n\nhttp://www.xiongchao.com\nhttps://www.xiongchao.com\n(协议不同，跨域)\n\n\n注意：localhost 和 localhost:8080、localhost 和 127.0.0.1 也属于跨域\n\n\n\n\n跨域情形请求代码：\nvar requestApi = &quot;http://localhost:8080/springmvc_hibernate_maven/&quot;;$.ajax(&#123;    type:&#x27;get&#x27;,    url:requestApi + &quot;test/userInfo&quot;,    dataType:&#x27;json&#x27;,    success:function(data)&#123;        console.log(data);    &#125;,    error:function(err)&#123;        console.log(err);    &#125;&#125;);\n\n服务器端java代码\n@Controller@RequestMapping(&quot;/test&quot;)public class Test &#123;\t@ResponseBody\t@RequestMapping(value = &quot;/userInfo&quot;,method = RequestMethod.GET)\tpublic String getUserInfo(HttpServletResponse httpServletResponse)&#123;\t\tUser user = new User();\t\tuser.setId(1);\t\tuser.setName(&quot;java&quot;);\t\tuser.setPassword(&quot;123456&quot;);\t\tuser.setLoginDate(&quot;2018-08-14&quot;);\t\tSystem.out.println(JSON.toJSONString(user));\t\treturn JSON.toJSONString(user);\t&#125;&#125;\n\n浏览器中访问（将html部署到nginx）结果:\n虽然请求成功并且返回了状态码200，但是并没有返回内容，并且控制台还打印了报错信息\n常见几种解决方案jsonp方式处理（基本被淘汰了）先看看json和jsonp数据格式的区别：\njson格式&#123;  &quot;id&quot;:&quot;1&quot;,  &quot;name&quot;:&quot;java&quot;,  &quot;password&quot;:&quot;123456&quot;,  &quot;loginDate&quot;:&quot;2018-08-14&quot;&#125;\n\njsonp格式callback(&#123;  &quot;id&quot;:&quot;1&quot;,  &quot;name&quot;:&quot;java&quot;,  &quot;password&quot;:&quot;123456&quot;,  &quot;loginDate&quot;:&quot;2018-08-14&quot;&#125;)\njsonp比json外面有多了一层，callback()。\n我们在请求的url后面拼接一个callback参数，用于返回jsonp格式数据\n$.ajax(&#123;    type:&#x27;get&#x27;,    url:requestApi + &quot;test/userInfo?callback=&quot;,    dataType:&#x27;jsonp&#x27;,    success:function(data)&#123;        console.log(data);    &#125;,    error:function(err)&#123;        console.log(err);    &#125;&#125;)\n\n服务器端处理：\n@Controller@RequestMapping(&quot;/test&quot;)public class Test &#123;\t@ResponseBody\t@RequestMapping(value = &quot;/userInfo&quot;,method = RequestMethod.GET)\tpublic String getUserInfo(HttpServletRequest request)&#123;                String callback = request.getParameter(&quot;callback&quot;);\t\tUser user = new User();\t\tuser.setId(1);\t\tuser.setName(&quot;java&quot;);\t\tuser.setPassword(&quot;123456&quot;);\t\tuser.setLoginDate(&quot;2018-08-14&quot;);\t\tSystem.out.println(JSON.toJSONString(user));\t\treturn callback+&quot;(&quot; + JSONObject.toJSONString(user) + &quot;)&quot;;\t&#125;&#125;\n\n我们看一下后台获取的callback的值\n修改请求代码再看一下后台获取的callback的值\n$.ajax(&#123;    type:&#x27;get&#x27;,    url:requestApi + &quot;test/userInfo&quot;,    dataType:&#x27;jsonp&#x27;,    jsonpCallback:&#x27;testCallback&#x27;,    success:function(data)&#123;        console.log(data);    &#125;,    error:function(err)&#123;        console.log(err);    &#125;&#125;)\n正是我们自定义的callback的值\n最后查看请求结果，控制台成功打印获取获取的数据\n需要注意的是jsonp是不支持post方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。另外可以使用jquer-jsonp插件实现跨域请求，服务器端无需做任何处理。java服务器端添加允许跨域请求的响应头ajax请求不用改，只需要添加响应头部Access-Control-Allow-Origin允许所有请求来源就可以了（所有服务器端处理都类似，对java不是很熟练，所以简单略过）\n@Controller@RequestMapping(&quot;/test&quot;)public class Test &#123;\t@ResponseBody\t@RequestMapping(value = &quot;/userInfo&quot;,method = RequestMethod.GET)\tpublic String getUserInfo(HttpServletResponse httpServletResponse)&#123;                httpServletResponse.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\t\tUser user = new User();\t\tuser.setId(1);\t\tuser.setName(&quot;java&quot;);\t\tuser.setPassword(&quot;123456&quot;);\t\tuser.setLoginDate(&quot;2018-08-14&quot;);\t\tSystem.out.println(JSON.toJSONString(user));\t\treturn JSON.toJSONString(user);\t&#125;&#125;\n\n结果：成功请求！\n比jsonp更强大的CORS方式解决跨域基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了。\n这里介绍的是java后端应该如何配置以解决问题\n第一步：1.非maven项目：获取依赖jar包下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下2.mavne项目：添加如下依赖到pom.xml中\n&lt;dependency&gt;  &lt;groupId&gt;com.thetransactioncompany&lt;/groupId&gt;  &lt;artifactId&gt;cors-filter&lt;/artifactId&gt;  &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;\n\n第二步:添加CORS配置到项目的Web.xml中(&#x2F;WEB-INF&#x2F;web.xml)\n&lt;!-- 跨域配置 --&gt;&lt;filter&gt;  &lt;!-- The CORS filter with parameters --&gt;  &lt;filter-name&gt;CORS&lt;/filter-name&gt;  &lt;filter-class&gt;com.thetransactioncompany.cors.CORSFilter&lt;/filter-class&gt;  &lt;!-- Note: All parameters are options, if omitted the CORS Filter will     fall back to the respective default values. --&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.allowGenericHttpRequests&lt;/param-name&gt;    &lt;param-value&gt;true&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.allowOrigin&lt;/param-name&gt;    &lt;param-value&gt;*&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.allowSubdomains&lt;/param-name&gt;    &lt;param-value&gt;false&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.supportedMethods&lt;/param-name&gt;    &lt;param-value&gt;GET, HEAD, POST,PUT,DELETE OPTIONS&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.supportedHeaders&lt;/param-name&gt;    &lt;param-value&gt;Accept, Origin, X-Requested-With, Content-Type, Last-Modified&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.exposedHeaders&lt;/param-name&gt;    &lt;!--这里可以添加一些自己的暴露Headers --&gt;    &lt;param-value&gt;X-Test-1, X-Test-2&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.supportsCredentials&lt;/param-name&gt;    &lt;param-value&gt;true&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;init-param&gt;    &lt;param-name&gt;cors.maxAge&lt;/param-name&gt;    &lt;param-value&gt;3600&lt;/param-value&gt;  &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;  &lt;!-- CORS Filter mapping --&gt;  &lt;filter-name&gt;CORS&lt;/filter-name&gt;  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;\n请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的)\n除了上述配置，我们无需添加其他任何代码就可以尽情的使用GET,POST,PUT,DELETE等等这个方法了，是不是比jsonp强大多了\n现在我们再来正常请求和处理请求试一下\n$.ajax(&#123;    type:&#x27;delete&#x27;,    url:requestApi + &quot;test/userInfo&quot;,    dataType:&#x27;json&#x27;,    success:function(data)&#123;        console.log(data);    &#125;,    error:function(err,textStatus)&#123;        console.log(&quot;err&quot;,err);    &#125;&#125;)\n\n@Controller@RequestMapping(&quot;/test&quot;)public class Test &#123;\t@ResponseBody\t@RequestMapping(value = &quot;/userInfo&quot;,method = RequestMethod.DELETE)\tpublic String getUserInfo(HttpServletRequest request,HttpServletResponse response)&#123;\t\tUser user = new User();\t\tuser.setId(1);\t\tuser.setName(&quot;java&quot;);\t\tuser.setPassword(&quot;123456&quot;);\t\tuser.setLoginDate(&quot;2018-08-14&quot;);\t\treturn JSONObject.toJSONString(user); \t&#125;&#125;\n\n请求结果：可以看到有OPTIONS请求了\n","categories":["Ajax"],"tags":["ajax","跨域"]},{"title":"JavaScript封装XMLHttpRequest请求","url":"/2018/08/16/JavaScript%E5%B0%81%E8%A3%85XMLHttpRequest%E8%AF%B7%E6%B1%82/","content":"\n\n什么是 XMLHttpRequest 对象XMLHttpRequest 对象用于在后台与服务器交换数据。XMLHttpRequest 对象是开发者的梦想，因为您能够：\n\n在不重新加载页面的情况下更新网页\n在页面已加载后从服务器请求数据\n在页面已加载后从服务器接收数据\n在后台向服务器发送数据\n\n所有现代的浏览器都支持 XMLHttpRequest 对象，XMLHttpRequest在 Ajax 编程中被大量使用。\n原生javascript（ES5）封装XMLHttpRequest对象1.创建ajax.js\nfunction Ajax()&#123;&#125;Ajax.prototype.ajax = function(obj)&#123;    //创建xmlhttprequest对象    var xhr;    try&#123;        xhr = new XMLHttpRequest();    &#125;catch(e)&#123;        xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);    &#125;    xhr.timeout = 5000;    xhr.ontimeout = function (event) &#123;        console.log(&quot;请求超时&quot;);    &#125;    xhr.responseType = obj.dataType;    xhr.open(obj.type,obj.url,obj.async||true);        if(obj.headers&amp;&amp;obj.headers[&quot;Content-Type&quot;])&#123;        xhr.setRequestHeader(&quot;Content-Type&quot;,obj.headers[&quot;Content-Type&quot;]);    &#125;else&#123;        xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);    &#125;    xhr.onreadystatechange = function() &#123;        //xhr.readyState 4:完成，XMLHttpRequest对象读取服务器响应结束        if(xhr.readyState == 4)&#123;             //xhr.status HTTP状态码 2XX表示有效响应 304意味着是从缓存读取            if(xhr.status &gt;= 200 &amp;&amp; (xhr.status &lt; 300 || xhr.status == 304))&#123;                  obj.success(xhr.response)            &#125;else&#123;                obj.error(xhr.status)            &#125;        &#125;    &#125;    if(obj.data)&#123;        var params = [];        for (const key in obj.data) &#123;            if (obj.data.hasOwnProperty(key)) &#123;                params.push(encodeURIComponent(key) + &quot;=&quot; + encodeURIComponent(obj.data[key]))                        &#125;        &#125;        var postData = params.join(&#x27;&amp;&#x27;);        xhr.send(postData);    &#125;else&#123;        xhr.send();    &#125;&#125;\n\n2.引用ajax.js\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;./ajax.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;  var $$ = new Ajax();  var requestApi = &quot;http://localhost:8080/springmvc_hibernate_maven/&quot;;  window.onload = function()&#123;    $$.ajax(&#123;        type:&#x27;get&#x27;,        url:requestApi + &quot;test/userInfo&quot;,        dataType:&#x27;json&#x27;,        success:function(data)&#123;            console.log(data,&quot;get&quot;);        &#125;,        error:function(err)&#123;            console.log(err);        &#125;    &#125;)    $$.ajax(&#123;        type:&#x27;post&#x27;,        url:requestApi + &quot;test/userInfo&quot;,        data:&#123;            name:&quot;xiongchao&quot;,            password:&#x27;xiongchao&#x27;,            status:1        &#125;,        dataType:&#x27;json&#x27;,        success:function(data)&#123;            console.log(data,&quot;post&quot;);        &#125;,        error:function(err)&#123;            console.log(err);        &#125;    &#125;)    $$.ajax(&#123;        type:&#x27;put&#x27;,        url:requestApi + &quot;test/userInfo/4/1&quot;,        dataType:&#x27;json&#x27;,        success:function(data)&#123;            console.log(data,&#x27;put&#x27;);        &#125;,        error:function(err)&#123;            console.log(err);        &#125;    &#125;)    $$.ajax(&#123;        type:&#x27;delete&#x27;,        url:requestApi + &quot;test/userInfo/4&quot;,        dataType:&#x27;json&#x27;,        success:function(data)&#123;            console.log(data,&#x27;delete&#x27;);        &#125;,        error:function(err)&#123;            console.log(err);        &#125;    &#125;)&#125;&lt;/script&gt;\n\n3.顺带看下后端写法（哈哈,虽然不需要前端开发人员操心）\n4.最后看下四种请求的结果\nES6 封装XMLHttpRequest对象同样ajax.js 文件\nconst ajax = function(obj)&#123;  return new Promise((resolve,reject)=&gt;&#123;      //创建xmlhttprequest对象      var xhr;      try&#123;          xhr = new XMLHttpRequest();      &#125;catch(e)&#123;          xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);      &#125;      xhr.timeout = 5000;      xhr.ontimeout = function (event) &#123;          console.log(&quot;请求超时&quot;);      &#125;      xhr.responseType = obj.dataType;      xhr.open(obj.type,obj.url,obj.async||true);            if(obj.headers&amp;&amp;obj.headers[&quot;Content-Type&quot;])&#123;          xhr.setRequestHeader(&quot;Content-Type&quot;,obj.headers[&quot;Content-Type&quot;]);      &#125;else&#123;          xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);      &#125;      xhr.onreadystatechange = function() &#123;          //xhr.readyState 4:完成，XMLHttpRequest对象读取服务器响应结束          if(xhr.readyState == 4)&#123;               //xhr.status HTTP状态码 2XX表示有效响应 304意味着是从缓存读取              if(xhr.status &gt;= 200 &amp;&amp; (xhr.status &lt; 300 || xhr.status == 304))&#123;                    resolve(xhr.response);              &#125;else&#123;                  reject(xhr.response);              &#125;          &#125;      &#125;      if(obj.data)&#123;          var params = [];          for (const key in obj.data) &#123;              if (obj.data.hasOwnProperty(key)) &#123;                  params.push(encodeURIComponent(key) + &quot;=&quot; + encodeURIComponent(obj.data[key]))                          &#125;          &#125;          var postData = params.join(&#x27;&amp;&#x27;);          xhr.send(postData);      &#125;else&#123;          xhr.send();      &#125;  &#125;)&#125;export default ajax;\n\n引用ajax.js\n&lt;script type=&quot;module&quot;&gt;  import ajax from &#x27;./ajax.js&#x27;  var requestApi = &quot;http://localhost:8080/springmvc_hibernate_maven/&quot;;  window.onload = function()&#123;      ajax(&#123;          type:&#x27;get&#x27;,          url:requestApi + &quot;test/userInfo&quot;,          dataType:&#x27;json&#x27;      &#125;).then((data)=&gt;&#123;          console.log(data,&quot;get&quot;);      &#125;).catch((err)=&gt;&#123;          console.log(err);      &#125;)      ajax(&#123;          type:&#x27;post&#x27;,          data:&#123;              name:&quot;xiongchao&quot;,              password:&#x27;xiongchao&#x27;,              status:1          &#125;,          url:requestApi + &quot;test/userInfo&quot;,          dataType:&#x27;json&#x27;      &#125;).then((data)=&gt;&#123;          console.log(data,&quot;post&quot;);      &#125;).catch((err)=&gt;&#123;          console.log(err);      &#125;)      ajax(&#123;          type:&#x27;put&#x27;,          url:requestApi + &quot;test/userInfo/4/1&quot;,          dataType:&#x27;json&#x27;      &#125;).then((data)=&gt;&#123;          console.log(data,&quot;put&quot;);      &#125;).catch((err)=&gt;&#123;          console.log(err);      &#125;)      ajax(&#123;          type:&#x27;delete&#x27;,          url:requestApi + &quot;test/userInfo/4&quot;,          dataType:&#x27;json&#x27;      &#125;).then((data)=&gt;&#123;          console.log(data,&quot;delete&quot;);      &#125;).catch((err)=&gt;&#123;          console.log(err);      &#125;)  &#125;&lt;/script&gt;\n","categories":["Ajax"],"tags":["ajax"]},{"title":"Jquery Dom元素Index()方法的使用","url":"/2017/06/10/Jquery-Dom%E5%85%83%E7%B4%A0Index-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"\n\n\n前言作为一个做后端java开发的被强行拉到前端组的菜鸟，前端知识略懂皮毛的我对于jquery很多常用方法都有误区，比如我现在要说的jquery DOM元素的index()方法。\njquery获取元素索引值index()方法使用误区由于对index()方法理解不是很深，所以在做项目时就遇到了有的页面获取的索引是正常的有的页面获取的索引总是大了2个，然后为了让最后的结果正常我就直接减2，并在后面注释”&#x2F;&#x2F;这里不知道为什么总是多了2，但其他页面又是正常的”，结果组长偶然一次机会看到了我这个注释就批评我说“哪有人这么写代码的”。唉，糗事就不多说了，以后写代码再也不敢这样了。\njquery获取元素索引值index()方法作用用法一：$(select).index();\n\n示例一：\n\n\n# html代码:&lt;div class=&quot;main&quot;&gt;  &lt;div class=&quot;box&quot;&gt;Milk&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;Tea&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;Coffee&lt;/div&gt; &lt;/div&gt;\n# js代码：$(&quot;.box&quot;).on(&quot;click&quot;,function()&#123;  $(this).index();//结果：如果点击的Milk则返回 0&#125;);\n\n\n\n这个示例看起来是获取的自己在与自己相同元素中的位置，那么看实例二\n\n\n示例二：\n\n\n# html代码:&lt;div class=&quot;main&quot;&gt;  &lt;p&gt;Soda&lt;/p&gt;  &lt;div class=&quot;box&quot;&gt;Milk&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;Tea&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;Coffee&lt;/div&gt; &lt;/div&gt; \n# js代码：$(&quot;.box&quot;).on(&quot;click&quot;,function()&#123;  $(this).index();//结果：如果点击的Milk则返回 1&#125;);\n从以上两个示例可以看出$(select).index()即使在没有参数的情况下也是相对用法，这个相对用法是相对其父元素中的位置，而不是获取自己在相同元素中的位置\n用法二：$(select1).index(select2);\n\n示例：\n\n\n# html代码:&lt;p class=&quot;box&quot;&gt;Tea&lt;/p&gt;&lt;div class=&quot;main&quot;&gt;  &lt;p&gt;Soda&lt;/p&gt;  &lt;div class=&quot;box&quot;&gt;Milk&lt;/div&gt;  &lt;div class=&quot;box&quot; id=&quot;box2&quot;&gt;Tea&lt;/div&gt;  &lt;div class=&quot;box&quot;&gt;Coffee&lt;/div&gt;&lt;/div&gt;\n# js代码:$(&quot;.box&quot;).index($(&quot;#box2&quot;));//结果: 2\n\n通过这个示例可以看出**$(select1).index(select2)的用法是选择器select2相对于选择器select1**的位置索引，跟同辈元素和其父辈元素都无关。\n总结虽然index()的用法比较简单，但是理解不深的话在项目中运用出了问题还是麻烦的，特别是对于我这个前端菜鸟出现果过这种尴尬的事情还是记录下来比较好，以免以后再跳进同一个坑。\n","categories":["javascript"],"tags":["jquery"]},{"title":"Markdown","url":"/2017/06/09/Markdown/","content":"\n\n我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：\n\n\n整理知识，学习笔记\n发布日记，杂文，所见所想\n撰写发布技术文稿（代码支持）\n撰写发布学术论文（LaTeX 公式支持）\n\n\n\n除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：\nWindows&#x2F;Mac&#x2F;Linux 全平台客户端\n请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的  新文稿 或者使用快捷键 Ctrl+Alt+N。\n\n\n什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以\n1. 制作一份待办事宜 Todo 列表\n 支持以 PDF 格式导出文稿\n 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n 新增 Todo 列表功能\n 修复 LaTex 公式渲染问题\n 新增 LaTex 公式编号功能\n\n2. 书写一个质能守恒公式[^LaTeX]$$E&#x3D;mc^2$$\n3. 高亮一段代码[^code]@requires_authorizationclass SomeClass:    passif __name__ == &#x27;__main__&#x27;:    # A comment    print &#x27;hello world&#x27;\n\n4. 高效绘制 流程图st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op\n\n5. 高效绘制 序列图Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!\n\n6. 高效绘制 甘特图title 项目开发流程section 项目确定    需求分析       :a1, 2016-06-22, 3d    可行性报告     :after a1, 5d    概念验证       : 5dsection 项目实施    概要设计      :2016-07-05  , 5d    详细设计      :2016-07-08, 10d    编码          :2016-07-15, 10d    测试          :2016-07-22, 5dsection 发布验收    发布: 2d    验收: 3d\n\n7. 绘制表格\n\n\n项目\n价格\n数量\n\n\n\n计算机\n$1600\n5\n\n\n手机\n$12\n12\n\n\n管线\n$1\n234\n\n\n8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。\n总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。\n\n什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑&#x2F;发布&#x2F;阅读 Markdown 的在线平台——您可以在任何地方，任何系统&#x2F;设备上管理这里的文字。\n1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！\n2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。\n\n3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！\n4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。\n5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。\n6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏：\n\n通过管理工具栏可以：\n 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通&#x2F;Vim&#x2F;Emacs 编辑模式\n7. 阅读工具栏\n通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。\n工具栏上的五个图标依次为：\n 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境\n8. 阅读模式在 阅读工具栏 点击  或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。\n9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档：\n标签： 未分类\n标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：\n\n10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击  (Ctrl+Alt+P) 发布这份文档给好友吧！\n\n再一次感谢您花费时间阅读这份欢迎稿，点击  (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！\n作者 @ghosert2016 年 07月 07日    \n[^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i&#x3D;1}^n a_i&#x3D;0$， 访问 MathJax 参考更多使用方法。\n[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。\n","categories":["Markdown"],"tags":["Markdown"]},{"title":"Qiniu-image-tool-实现图片一键上传七牛云","url":"/2018/07/02/Qiniu-image-tool-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%80%E9%94%AE%E4%B8%8A%E4%BC%A0%E4%B8%83%E7%89%9B%E4%BA%91/","content":"\n\n&ensp;&ensp;&ensp;&ensp;写博客当然少不了云储存了，那为什么推荐使用七牛云呢，当然是因为七牛云储存提供10G的免费空间,以及每月10G的流量，存放个人博客外链图片最好不过了，七牛云储存还有各种图形处理功能、缩略图、视频存放速度也给力。&ensp;&ensp;&ensp;&ensp;qiniu-image-tool是一个提升 markdown 贴图体验的实用小工具，支持windows 及 mac。其中 qiniu-image-tool-win 为windows版本，基于AutoHotkey和qshell实现，一键上传图片或截图至七牛云，获取图片的markdown引用至剪贴板，并自动粘贴到当前编辑器。\n用法\n复制本地图片、视频、js等文件至剪贴板（ctrl+c）or 使用喜欢的截图工具截图 or 直接复制网络图片.\n切换到编辑器，ctrl+alt+v便可以看到图片链接自动粘贴到当前编辑器的光标处（同时链接也会保存在粘贴板里）\n\n预览效果图：\n本地图片文件上传\n\n截图上传\n\n其它文件上传\n\n\n安装首先从 github 下载release版本（有两个版本：2.0 正式版和1.0 正式版，推荐使用2.0 正式版）并解压到任意目录\n目录结构应如下：\n其中dump-clipboard-png.ps1是保存截图的powershell脚本，qiniu-image-upload.ahk 即完成文件上传的AutoHotkey脚本。\n配置脚本打开settings.ini文件，右键选择编辑脚本使脚本在编辑器中打开，找到下面这段代码:\n\n修改这里的五个配置项的值，其中前四个配置项都与七牛账号相关：\nACCESS_KEY &amp; SECRET_KEY这是qshell操作个人账号的账号凭证，登陆七牛账号后在个人面板-&gt;密钥管理中查看，或者直接访问查看。\nBUCKET_NAME &amp; BUCKET_DOMAIN在对象存储-&gt;存储空间列表中选择或新建一个存储空间即bucket，点击该bucket在右边看到一个测试域名，该域名即bucketDomain是图片上传后的访问域名。这里要特别注意域名不要少了前面的 ***http头 *** 和最后的那个 斜杠。\n运行脚本配置完成以后以管理员身份运行qImage.exe，这时便可以使用ctrl+alt+v尝试上传图片了。\n调试如果以上操作完成后没有按照预期达到图片上传的效果，感兴趣的筒子可以先自己调试找一下原因，一般报错信息会打印在cmd命令行中，但是cmd窗口一闪而过可能看不清楚，这时候将可选参数DEBUG_MODE &#x3D; false 改为DEBUG_MODE &#x3D; true打开调试模式，再次尝试，这时候cmd窗口不会自动关闭，便可以看到具体的报错信息从而对症下药解决问题。\n","categories":["云储存"],"tags":["upload"]},{"title":"css常用奇淫技巧(不定期更新)","url":"/2018/08/30/css%E5%B8%B8%E7%94%A8%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7-%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0/","content":"\n一、常用技巧清除浮动\n添加新的元素 、应用 clear：both; \n父级定义 overflow: auto;\n父元素也设置浮动;\n使用br标签和其自身的html属性:《br clear&#x3D;”all”&#x2F;》 clear&#x3D;”all | left | right | none”;\n最高大上的方法，强烈推荐 parentDom:after{content: “ “;display: block;clear: both;}\n\n垂直居中&lt;div class=&quot;box box1&quot;&gt;  &lt;span&gt;垂直居中&lt;/span&gt;&lt;/div&gt;\n.box &#123;  width: 200px;  height: 200px;  background: red;&#125; \n\n方法1：table-cell.box1 &#123;  display: table-cell;  vertical-align: middle;  text-align: center;&#125;\n方法2：display:flex（部分低版本浏览器不兼容）.box2 &#123;  display: flex;  justify-content:center;  align-items:Center;&#125;\n\n方法3：绝对定位和负边距(已知元素高度).box3 &#123;position:relative;&#125;.box3 span &#123;    position: absolute;    width:100px;    height: 50px;    top:50%;    left:50%;    margin-left:-50px;    margin-top:-25px;    text-align: center;&#125;\n\n方法4：绝对定位和0(已知元素高度).box &#123;position:relative;&#125;.box4 span &#123;  width: 50%;   height: 50%;   background: #000;  overflow: auto;   margin: auto;   position: absolute;   top: 0; left: 0; bottom: 0; right: 0; &#125;\n\n方法5：display:flex和margin:auto.box5 &#123;    display: flex;    text-align: center;&#125;.box5 span &#123;margin: auto;&#125;\n\n文本超出部分隐藏单行文本超出部分隐藏#ellipsis &#123;  overflow: hidden;   /*超出的文本隐藏*/  text-overflow: ellipsis;    /*溢出用省略号显示*/  white-space: nowrap;    /*溢出不换行*/&#125;\n\n多行文本超出部分隐藏#ellipsis &#123;  overflow: hidden;   display: -webkit-box;   /*作为弹性伸缩盒子模型显示*/  -webkit-box-orient: vertical;   /*设置伸缩盒子的子元素排列方式--从上到下垂直排列*/  -webkit-line-clamp: 2;   /*显示的行*/&#125;\n\n二、形状技巧三角形#triangle1 &#123;  width: 0;  height: 0;  border-top: 50px solid red;  border-right: 50px solid orange;  border-bottom: 50px solid yellow;  border-left: 50px solid green;&#125;#triangle2 &#123;  width: 0;  height: 0;  border-top: 50px solid red;  border-right: 50px solid transparent;  border-bottom: 50px solid transparent;  border-left: 50px solid transparent;&#125;\n\n未读数量#superscript &#123;    width: 50px;    height: 50px;    background: red;    padding:0 20px;    border-radius: 20px;&#125;\n\n字体边框同色#app&#123;    width: 100px;    height: 100px;    color: red;    font-size: 30px;    /*方案一    CSS3 currentColor 表示当前的文字颜色*/    /* border: 10px solid currentColor; */        /*方案二    border 的默认值 (initial) 就是 currentColor*/    border: 10px solid;  &#125;\n\n放大镜#div5&#123;    width: 50px;    height: 50px;    border: 5px solid #000000;    border-radius: 50%;    position: relative;&#125;#div5::after&#123;    content: &#x27; &#x27;;    display: block;    width: 8px;    height: 60px;    border-radius: 5px;    background: #000000;    position: absolute;    right: -22px;        top: 38px;    transform: rotate(-45deg);&#125;\n\n","categories":["前端"],"tags":["CSS"]},{"title":"sessionStorage和localStorage解释及区别","url":"/2018/08/07/essionStorage%E5%92%8ClocalStorage%E8%A7%A3%E9%87%8A%E5%8F%8A%E5%8C%BA%E5%88%AB/","content":"\n\nHTML5的本地存储HTML5中与本地存储相关的两个重要内容：Web Storage与本地数据库。其中，Web Storage存储机制是对HTML4中cookie存储机制的一个改善。由于cookie存储机制有很多缺点，HTML5不再使用它，转而使用改良后的Web Storage存储机制。本地数据库是HTML5中新增的一个功能，使用它可以在客户端本地建立一个数据库，原本必须保存在服务器端数据库中的内容现在可以直接保存在客户端本地了，这大大减轻了服务器端的负担，同时也加快了访问数据的速度。\n本文主要来讲解Web Storage我们知道，在HTML4中可以使用cookie在客户端保存诸如用户名等简单的用户信息，但是，通过长期的使用，你会发现，用cookie存储永久数据存在以下几个问题：\n1.大小：cookie的大小被限制在4KB。\n2.带宽：cookie是随HTTP事务一起被发送的，因此会浪费一部分发送cookie时使用的带宽。\n3.复杂性：要正确的操纵cookie是很困难的。\n针对这些问题，在HTML5中，重新提供了一种在客户端本地保存数据的功能，它就是Web Storage。\n具体来说，Web Storage又分为两种：1.sessionStorage：将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据。\n2.localStorage：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。\n这两者的区别在于，sessionStorage为临时保存，而localStorage为永久保存。\n到目前为止，Firefox3.6以上、Chrome6以上、Safari 5以上、Pera10.50以上、IE8以上版本的浏览器支持sessionStorage与localStorage的使用。WebStorage的目的是克服由cookie所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。\nWebStorage两个主要目标：（1）提供一种在cookie之外存储会话数据的路径。（2）提供一种存储大量可以跨会话存在的数据的机制。\nHTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage（会话存储）。1、生命周期：localStorage:localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。　　sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。\n2、存储大小：localStorage和sessionStorage的存储数据大小一般都是：5MB\n3、存储位置：localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。\n4、存储内容类型：localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理\n5、获取方式：localStorage：window.localStorage;；sessionStorage：window.sessionStorage;\n6、应用场景：localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录；\nWebStorage的优点：（1）存储空间更大：cookie为4KB，而WebStorage是5MB；\n（2）节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样每次请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量；\n（3）对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便；\n（4）快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快；\n（5）安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题；\nWebStorage提供了一些方法，数据操作比cookie方便；\nsetItem（key, value） ——  保存数据，以键值对的方式储存信息。\n\ngetItem（key） ——  获取数据，将键值传入，即可获取到对应的value值。\n\nremoveItem（key） ——  删除单个数据，根据键值移除对应的信息。\n\nclear（） ——  删除所有的数据\n\nkey（index） —— 获取某个索引的key\n\n\ncookie 、sessionStorage与localStorage的区别特性cookiesessionStoragelocalStorage数据生命期生成时就会被指定一个maxAge值，这就是cookie的生存周期，在这个周期内cookie有效，默认关闭浏览器失效页面会话期间可用除非数据被清除，否则一直存在存放数据大小4K左右（因为每次http请求都会携带cookie）一般5M或更大详细看这(需科学上网)与服务器通信由对服务器的请求来传递，每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题数据不是由每个服务器请求传递的，而是只有在请求时使用数据，不参与和服务器的通信易用性cookie需要自己封装setCookie，getCookie可以用源生接口，也可再次封装来对Object和Array有更好的支持共同点都是保存在浏览器端，和服务器端的session机制不同（这里有一篇很好的介绍cookie和session的文章）\n\n示例：（1） 新建两个文件：\n&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;a href=&quot;./test.html&quot; target=&quot;_blank&quot;&gt;跳到test.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;    localStorage.setItem(&quot;xiongchao&quot;,123);    sessionStorage.setItem(&quot;xiongchao&quot;,456);&lt;/script&gt;\n\n（2） 部署服务（推荐使用nignx做反向代理,比tomcat简单粗暴，也可以不用这一步，只是为了模拟真实网站会话）\n（3） 打开index.html,并使用链接打开test.html\n两个页面的结果是一样的，这是一次会话，sessionStorage储存的内容被保存下来。\n（4） 单独打开test.html,会发现sessionStorage是空的。\n","categories":["javascript"],"tags":["sessionStorage","localStorage"]},{"title":"git常用命令","url":"/2018/07/08/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"\ngit的工作原理图解：\n将指定文件添加到暂存区(stage)\n\n将暂存区的所有内容提交到当前分支\n\n分支的创建与合并\n\n\ngit的使用步骤：基本使用git add . //如果有删除的文件则：git add -Agit commit -m&quot;first commit&quot;//这一步可能会进入一个奇怪的窗口，需执行 ESC :wqgit pull --rebase origin master//如果有冲突则解决冲突，然后执行第一步，最后执行以下命令git rebase --continuegit push origin master//push时有可能会提示没有change-id//复制提示中的&quot;gitdir=$(git rev-parse --git-dir); scp -p -P 29418 //xiongchao@192.168.1.192:hooks/commit-msg $&#123;gitdir&#125;/hooks/&quot;git commit -amend\n\n如果你正在完成某一个功能不能提交代码，然后又需要用到远程仓库中同事刚提交的代码，则只需要执行以下命令git stashgit pullgit stash pop //可能有冲突，改冲突，可直接运行项目\n\ncherry-pick用法（A分支的内容添加到B分支,此操作是在B分支上）git reflog//复制要cherry-pick的commit id（有说明的那一行）git cherry-pick commitidgit push origin master\n\ngit的常用命令解释：$ git status查看工作区状态；\n$ git add readme.txt将指定文件添加到暂存区(stage);反复多次使用，添加多个文件；\n$ git add .将所有文件添加到Git仓库暂存区；\n$ git commit -m “wrote a readme file”将暂存区的所有内容提交到当前分支；\n$ git checkout – readme.txt”把** readme.txt 文件在工作区的修改全部撤销，这里有两种情况：一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt**已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。\n$ rm test.txt”从版本库暂存区中删除该文件；\n$ git push origin master把当前分支master的内容推送到远程库；\n$ git pull –rebase origin master拉取远程库master分支的内容到本地仓库；\n$ git reset HEAD~将前版本回退到上一个版本；上上一个版本就是HEAD~~，上100个版本写成HEAD~100；\n$ git reset –hard 1094a将前版本回退到指定版本；\n$ git stash将你当前未提交（包括暂存的和非暂存的）到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的,需要说明一点，stash是本地的，不会通过git push命令上传到git server上；\n$ git stash pop将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下；\n$ git stash list查看现有stash；\n$ git stash drop移除stash；或者使用git stash clear命令，删除所有缓存的stash；\n$ git branch dev创建dev分支；\n$ git checkout dev切换到dev分支；\n$ git branch查看当前分支；\n$ git merge dev把dev分支的工作成果合并到master分支上；\n$ git branch -d dev删除dev分支；\n$ git clone将远程仓库克隆到本地；\n$ git log查看提交日志；\n$ git reflog记录你的每一次命令；\n","categories":["工具"],"tags":["git"]},{"title":"js Date对象的详细使用","url":"/2018/07/19/js%20Date%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/","content":"\n\n前言：&ensp;&ensp;&ensp;&ensp;最近发现Date对象在项目中真的是无处不在，几乎做过的所有项目中都有Date的各种用法，然而每次要使用的时候都是各种百度，自己既没有掌握Date的详细用法，也使得每次做项目都浪费很多时间，所以特此研究一下记录下来。\n一：Date()对象基本方法示例：//Date()：返回当日的日期和时间。var date = new Date();//Thu Jul 19 2018 10:46:06 GMT+0800// getDay()：从 Date 对象返回一周中的某一天 (0 ~ 6)。date.getDay();\t\t//4 今天是星期四// getFullYear()：从 Date 对象以四位数字返回年份。date.getFullYear();\t\t//2018// getMonth()：从 Date 对象返回月份 (0 ~ 11)。date.getMonth();\t\t//6// getDate()：从 Date 对象返回一个月中的某一天 (1 ~ 31)。date.getDate();\t\t//19// getHours()：返回 Date 对象的小时 (0 ~ 23)。date.getHours();\t\t//10// getMinutes()：返回 Date 对象的分钟 (0 ~ 59)。date.getMinutes();\t\t//53// getSeconds()：返回 Date 对象的秒数 (0 ~ 59)。date.getSeconds();\t\t//5// getMilliseconds()：返回 Date 对象的毫秒(0 ~ 999)。date.getMilliseconds();\t\t//522// getTime()：返回 1970 年 1 月 1 日至今的毫秒数。date.getTime();\t\t//1531968785522// setFullYear()：设置 Date 对象中的年份（四位数字）。date.setFullYear(1995); //1531968785522// setMonth()：设置 Date 对象中月份 (0 ~ 11)。date.setMonth(8); //Wed Sep 19 2018 11:51:48 GMT+0800 (中国标准时间)// setDate()：设置 Date 对象中月的某一天 (1 ~ 31)。date.setDate(25); //Wed Jul 25 2018 11:52:15 GMT+0800 (中国标准时间)// setTime()：以毫秒设置 Date 对象。date.setTime(77771564221); console.log(date) //Mon Jun 19 1972 11:12:44 GMT+0800 (中国标准时间)// toTimeString()：把 Date 对象的时间部分转换为字符串。console.log(date.toTimeString()); =&gt; 11:58:45 GMT+0800 (中国标准时间)// toDateString()：把 Date 对象的日期部分转换为字符串。console.log(date.toDateString()); =&gt; Thu Jul 19 2018\n\n\n二：Date()对象组合高级用法：//将毫秒转换为yyyy-MM-dd HH:mm:ss日期格式function dateFormat(seconds) &#123;    let date = new Date(seconds),        year = date.getFullYear(),        month = date.getMonth() + 1,        day = date.getDate(),        hour = date.getHours(),        min = date.getMinutes(),        s = date.getSeconds();    return `$&#123;year&#125;-$&#123;formatNum(month)&#125;-$&#123;formatNum(day)&#125; $&#123;formatNum(hour)&#125;:$&#123;formatNum(min)&#125;:$&#123;formatNum(s)&#125;`;&#125;//转换为yyyy-MM-dd日期格式function dateFormatShort(date) &#123;    let year = date.getFullYear(),    month = date.getMonth() + 1,    day = date.getDate();    return `$&#123;year&#125;-$&#123;formatNum(month)&#125;-$&#123;formatNum(day)&#125;`;&#125;//将yyyy-MM-dd HH:mm:ss转化为毫秒数function formatMilliseconds(str)&#123;    // str = &#x27;2018-7-19 15:14:30&#x27;;    str = str.replace(/-/g,&#x27;/&#x27;);//由于部分浏览器以及一些低版本浏览器不兼容new Date(yyyy-MM-dd HH:mm:ss)    let date = new Date(str);    return date.getTime();&#125;//获取两个时间的秒数差function SecondsDiff(startDate,endDate)&#123;    startDate = &quot;2018-7-18 10:56:23&quot;,endDate = &quot;2018-7-19 12:00:00&quot;;    let startTime = formatMilliseconds(startDate),//获得毫秒数        endTime = formatMilliseconds(endDate),        milliseconds = endTime - startTime;//毫秒数之差    return parseInt(milliseconds/1000);&#125;//根据剩余秒数获取剩余HH:mm:ss（应用在活动倒计时或物品过期还有多久&#x27;dd天HH小时&#x27;）function secondsFormat(seconds)&#123;    seconds = SecondsDiff();    let day = Math.floor(seconds / 3600 / 24),        hour = Math.floor((seconds % 86400) / 3600),        min = Math.floor((seconds % 86400 % 3600) / 60 ),        second = Math.floor(seconds % 86400 % 3600 % 60);        hour += day * 24;    return `$&#123;formatNum(hour)&#125;:$&#123;formatNum(min)&#125;:$&#123;formatNum(second)&#125;`;//为什么只计算天数,因为一般活动只在相邻几天&#125;    //获得某月的天数　　 function getMonthDays(year, month) &#123;    let nowDate = new Date(year,month,0),        days = nowDate.getDate();    return days;&#125;//补0操作function formatNum(e) &#123;    return e &gt;= 10 ? e : `0$&#123;e&#125;`;&#125;\t\n\n\n三：对当前时间的判定：//判断时间是否是今天function isToday(str)&#123;    str = new Date(str.replace(/-/g,&quot;/&quot;));    if (str.toDateString() === new Date().toDateString()) &#123;//今天        return true;    &#125; else if (new Date(str) &gt; new Date())&#123;        return false;    &#125;&#125;/*** 判断某个时间是前天、昨天、今天、明天、后天* @now:当前服务器时间*/function daysText(str,now)&#123;    let date = str.substring(0,str.indexOf(&quot;-&quot;)+6);    now = new Date(now.replace(/-/g,&#x27;/&#x27;));    now = new Date(now.getFullYear(), now.getMonth(), now.getDate());    str = new Date(str.replace(/-/g,&#x27;/&#x27;));    str = new Date(str.getFullYear(), str.getMonth(), str.getDate());    let diff = (str - now) / 1000 / 60 / 60 / 24;    if (diff &lt; -1) &#123;        return &quot;前天&quot;;    &#125; else if (diff &lt; -0) &#123;        return &quot;昨天&quot;    &#125; else if (diff == 0) &#123;        return &quot;今天&quot;;    &#125; else if (diff &lt; 2) &#123;        return &quot;明日&quot;;    &#125; else if (diff &lt; 3) &#123;        return &quot;后天&quot;;    &#125; else &#123;        return date;    &#125;&#125;//判断是否超过48小时function overTime(seconds) &#123;    let diffSeconds = Math.floor((new Date().getTime() - seconds)/1000),        days = Math.floor(diffSeconds / 86400),        hour = Math.floor(diffSeconds % 86400 / 3600),        min = Math.floor((diffSeconds % 86400 % 3600) / 60 )        second = Math.floor(diffSeconds % 86400 % 3600 % 60);    if(days&gt;2)&#123;//超过两天超时        return 0;    &#125;else if(days==2)&#123; //刚好两天判断时分秒        if(hour==0)&#123;             if(min==0)&#123;                if(second==0)&#123;                    return 1;                &#125;else&#123; //有多余秒数，超时                    return 0;                &#125;            &#125;else&#123; //有多余分钟，超时                return 0;            &#125;        &#125;else&#123; //还有多余小时，超时            return 0;        &#125;    &#125;else &#123; //小于两天则没有超时        return 1;    &#125;&#125;/** * 判断某个时间相对于现在过了多久 * seconds:毫秒数 */function pastTimes(seconds)&#123;    //得到时间    let dateTime;    //传入时间    let starDate = new Date(seconds),        starYear = starDate.getFullYear(), //年        starMonth = starDate.getMonth() + 1, //月        starDay = starDate.getDate(),     //日        starHour = starDate.getHours(),   //时        starMin = starDate.getMinutes(),  //分        starSen = starDate.getSeconds(); //秒    //当前时间    let nowDate = new Date(),        nowYear = nowDate.getFullYear(), //年        nowMonth = nowDate.getMonth() + 1, //月        nowDay = nowDate.getDate(),     //日        nowHour = nowDate.getHours(),   //时        nowMin = nowDate.getMinutes(),  //分        nowSen = nowDate.getSeconds();  //秒    //判断是否在同一年    if (starYear == nowYear) &#123;        //判断是否是同一个月        if (starMonth == nowMonth) &#123;             //判断在今天昨天或者前天            let diffDay = nowDay - starDay;            if (diffDay == 0) &#123;//今天                //判断小时数                let diffHours = nowHour - starHour;                let diffMinutes = nowMin - starMin;                if (diffHours == 0) &#123;                    if (diffMinutes &gt;= 0 &amp;&amp; diffMinutes &lt; 2) &#123;                        dateTime = &quot;刚刚&quot;;                    &#125; else if (diffMinutes &gt;= 2) &#123;                        dateTime = diffMinutes + &quot;分钟前&quot;;                    &#125;                &#125;else if (diffHours == 1) &#123;                    if (diffMinutes &lt; 0) &#123;                        let minute = (60 - starMin) + (nowMin - 0);                        dateTime = minute + &quot;分钟前&quot;;                    &#125; else if (diffMinutes &gt; 0) &#123;                        dateTime = &quot;1个小时前&quot;;                    &#125;                &#125;else if (diffHours == 2) &#123;                     if (diffMinutes &lt; 0) &#123;                        dateTime = &quot;1个小时前&quot;;                    &#125; else if (diffMinutes &gt; 0) &#123;                        dateTime = &quot;2个小时前&quot;;                    &#125;                &#125;else&#123;                    dateTime = formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);                &#125;            &#125;else if(diffDay == 1) &#123;//昨天                dateTime = &#x27;昨天&#x27; + formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);            &#125;else if (diffDay == 2) &#123;//前天                dateTime = &#x27;前天&#x27; + formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);            &#125;else&#123;                dateTime = formatNum(starMonth) + &#x27;-&#x27; + formatNum(starDay) + &#x27; &#x27; + formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);            &#125;        &#125;else&#123;            //不在同一个月且在同一年的不显示年份            dateTime = formatNum(starMonth) + &#x27;-&#x27; + formatNum(starDay) + &#x27; &#x27; + formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);        &#125;    &#125;else&#123;        //不在同一年的显示年月日时分        dateTime = starYear + &#x27;-&#x27; + formatNum(starMonth) + &#x27;-&#x27; + formatNum(starDay) + &#x27; &#x27; + formatNum(starHour) + &#x27;:&#x27; + formatNum(starMin);    &#125;    return dateTime    &#125;","categories":["javascript"],"tags":["js","date"]},{"title":"js 将对象数组中具有相同值的对象取出组成新的数组","url":"/2018/07/26/js-%E5%B0%86%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E5%80%BC%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%96%E5%87%BA%E7%BB%84%E6%88%90%E6%96%B0%E7%9A%84%E6%95%B0%E7%BB%84/","content":"\n\n实现方法：let arr = [  &#123;    &quot;id&quot;: 577,    &quot;name&quot;: &quot;艾杜纱 毛孔洁净洗面奶&quot;,    &quot;skuName&quot;: &quot;125mL&quot;,    &quot;image&quot;: &quot;commodityImage/haZW5gLF.jpg&quot;,    &quot;price&quot;: 122.32,    &quot;store&quot;: 327,    &quot;status&quot;: 1,    &quot;brandId&quot;: 18,    &quot;categoryId&quot;: 32  &#125;, &#123;    &quot;id&quot;: 536,    &quot;name&quot;: &quot;心机彩妆 星魅霓光唇膏&quot;,    &quot;skuName&quot;: &quot;BE300&quot;,    &quot;image&quot;: &quot;commodityImage/ibg54OOx.jpg&quot;,    &quot;price&quot;: 273.65,    &quot;store&quot;: 50,    &quot;status&quot;: 1,    &quot;brandId&quot;: 17,    &quot;categoryId&quot;: 33  &#125;, &#123;    &quot;id&quot;: 546,    &quot;name&quot;: &quot;心机彩妆 炫眉膏&quot;,    &quot;skuName&quot;: &quot;77&quot;,    &quot;image&quot;: &quot;commodityImage/356LBmxe.jpg&quot;,    &quot;price&quot;: 160.68,    &quot;store&quot;: 20,    &quot;status&quot;: 1,    &quot;brandId&quot;: 17,    &quot;categoryId&quot;: 20  &#125;]console.log(arr,&#x27;原始数组&#x27;);console.log(sortArr(arr, &#x27;brandId&#x27;),&#x27;转化后的数组&#x27;);/*** arr 要转化的数组* key 根据某一键转化*/function sortArr(arr, key) &#123;  let newArr = [],      tempArr = [],      temp;  // 按照特定的参数将数组排序，将具有相同值的排在一起  arr = arr.sort(function(a, b) &#123;      let s = a[key],          t = b[key];      return s &lt; t ? -1 : 1;  &#125;);  console.log(arr,&quot;排序之后的数组&quot;);  if ( arr.length )&#123;      temp = arr[0][key];  &#125;  // 将相同类别的对象添加到统一个数组  for (let i in arr) &#123;      if ( arr[i][key] === temp )&#123;          tempArr.push( arr[i] );      &#125; else &#123;          temp = arr[i][key];          newArr.push(tempArr);          tempArr = [arr[i]];      &#125;  &#125;  // 将最后的内容推出新数组  newArr.push(tempArr);  return newArr;&#125;\n结果：\n","categories":["javascript"],"tags":["js","Array"]},{"title":"js经典排序算法","url":"/2018/07/27/js%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/","content":"\n\n1.冒泡排序（Bubble Sort）冒泡排序动图演示：\n定义： 比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个 数据交换。对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。N=N-1，如果N不为0就重复前面二步，否则排序完成。\nfunction bubbleSort(arr)&#123;    var len = arr.length;    for(var i = 0;i &lt; len;i++)&#123;        for(var j = 0;j &lt; len - 1 - i;j++)&#123;            if(arr[j]&gt;arr[j+1])&#123;                var temp = arr[j];                arr[j+1] = arr[j];                arr[j] = temp;            &#125;        &#125;    &#125;&#125;\n2.选择排序（Selection Sort）选择排序动图演示：\n/*** 比如在一个长度为N的无序数组中，在第一趟遍历N个数据，找出其中最小的数值与* 第一个元素交换，第二趟遍历剩下的N-1个数据，找出其中最小的数值与第二个元* 素交换……第N-1趟遍历剩下的2个数据，找出其中最小的数值与第N-1个元素交换，* 至此选择排序完成。*/function selectSort(arr)&#123;    var min,temp;    for(var i=0;i&lt;arr.length-1;i++)&#123;        min=i;        for(var j=i+1;j&lt;arr.length;j++)&#123;            if(arr[j]&lt;arr[min])&#123;                min = j;            &#125;        &#125;        temp=arr[i];        arr[i]=arr[min];        arr[min]=temp;    &#125;    return arr;&#125;\n\n3.插入排序（Insertion Sort）插入排序动图演示：\n从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。\nfunction insertionSort(arr) &#123;    var len = arr.length;    var preIndex, current;    for (var i = 1; i &lt; len; i++) &#123;        preIndex = i - 1;        current = arr[i];        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;            arr[preIndex+1] = arr[preIndex];            preIndex--;        &#125;        arr[preIndex+1] = current;    &#125;    return arr;&#125;\n\n4.快速排序（Quick Sort）快速排序动图演示：\n先从数列中取出一个数作为基准数。分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。再对左右区间重复第二步，直到各区间只有一个数。\n\nfunction quickSort(arr)&#123;    if(arr.length&lt;2)&#123;        return arr    &#125;    var left=[],right=[],mid=arr.splice(Math.floor(arr.length/2),1);    for(var i=0;i&lt;arr.length;i++)&#123;            if(arr[i]&lt;mid)&#123;                left.push(arr[i]);            &#125;else &#123;                right.push(arr[i])            &#125;    &#125;    return bubbleSort(left).concat(mid,bubbleSort(right))  &#125;","categories":["算法"],"tags":["Array","sort"]},{"title":"js跳出循环总结","url":"/2018/07/31/js%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF%E6%80%BB%E7%BB%93/","content":"\n\n一.跳出一层循环var arr = [&quot;a&quot;, &quot;b&quot;,&#x27;c&#x27;,&#x27;d&#x27;];\n结束for循环for(var i=0;i&lt;arr.length;i++)&#123;  if(i==2)&#123;      break;  &#125;  console.log(arr[i],i);&#125;console.log(&#x27;循环外&#x27;);\n注意：return 虽说可以结束循环，但是循环体后面的内容也无法执行了\n结束forEach循环try &#123;    arr.forEach((o,i) =&gt; &#123;        if(i==2)&#123;            throw new Error(&quot;EndIterative&quot;);        &#125;        console.log(o,i);    &#125;);&#125; catch (e) &#123;    if(e.message!=&#x27;EndIterative&#x27;)&#123;        throw e;    &#125;&#125;console.log(&#x27;循环体外&#x27;);\n\n注意：return 只能结束本次循环，并不能终止整个循环\n结束for…in循环for (var i in arr) &#123;    if(i==2)&#123;        break;    &#125;    console.log(arr[i],i);&#125;console.log(&#x27;循环体外&#x27;);\n注意：return 虽说可以结束循环，但是循环体后面的内容也无法执行了\n结果：\n二.跳出多层循环var arr = [[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;],[&quot;小红&quot;, &quot;小明&quot;, &quot;小亮&quot;]];\n正常多层for循环for (var i = 0; i &lt; arr.length; i++) &#123;    for (var j = 0; j &lt; arr[i].length; j++) &#123;        console.log(arr[i][j], &#x27;内层&#x27;);    &#125;    console.log(arr[i], &quot;外层&quot;);&#125;console.log(&quot;循环体外&quot;);\n#####结果：\n使用breakfor (var i = 0; i &lt; arr.length; i++) &#123;    for (var j = 0; j &lt; arr[i].length; j++) &#123;      if(j==i)&#123;          break;      &#125;      console.log(arr[i][j], &#x27;内层&#x27;);    &#125;    console.log(arr[i], &quot;外层&quot;);&#125;\n结果： 只跳出了一层循环\n\n我们可以使用以下方法跳出多层for循环var flag = false;for (var i = 0; i &lt; arr.length; i++) &#123;    for (var j = 0; j &lt; arr[i].length; j++) &#123;      if(j==1)&#123;          flag = true;          break;      &#125;      console.log(arr[i][j], &#x27;内层&#x27;);    &#125;    if(flag)&#123;        break;    &#125;    console.log(arr[i], &quot;外层&quot;);&#125;\n结果： 只执行了一次j&#x3D;0就结束了循环\n使用returnfor (var i = 0; i &lt; arr.length; i++) &#123;    for (var j = 0; j &lt; arr[i].length; j++) &#123;      if(j==1)&#123;          return;      &#125;      console.log(arr[i][j], &#x27;内层&#x27;);    &#125;    console.log(arr[i], &quot;外层&quot;);&#125;console.log(&#x27;我在循环体外&#x27;);\n结果： 虽然跳出了多层循环，但是循环体后面的内容都没有被执行\n\n跳出多层forEach循环try &#123;    arr.forEach((newArr,i) =&gt; &#123;        newArr.forEach((o,j)=&gt;&#123;            if(j==1)&#123;                throw new Error(&quot;EndIterative&quot;);            &#125;            console.log(o,&#x27;内层&#x27;)        &#125;);        console.log(newArr,&#x27;外层&#x27;);    &#125;);&#125; catch (e) &#123;    if(e.message!=&quot;EndIterative&quot;)&#123;        throw e;    &#125;&#125;console.log(&#x27;循环体外&#x27;);\n结果： 正确跳出了多层循环\n最后总结：\nbreak只能在for、for…in循环中使用不能再forEach里面使用，并且break只能跳出单层循环；\nreturn 虽然可以终止循环，但是也终止了return之后的所有语句，特别注意：return 不能终止forEach循环，只能结束当前循环。\n\n","categories":["javascript"],"tags":["Array","循环"]},{"title":"css3伪类选择器nth-child和nth-of-type的区别","url":"/2017/06/10/ss3%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8nth-child%E5%92%8Cnth-of-type%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"\n\n\n\n使用误区之前在做项目时一直是:nth-child和:nth-of-type混着用，第一个不行就用第二个，当时就觉得能实现效果就行，后来这样的情况遇到多了，每次用的时候就感觉效果是试出来的，特别浪费时间，现在就来研究一下这两个用法的区别。\n1.用法效果相同的情况示例一：# HTML代码&lt;div class=&quot;main&quot;&gt;  &lt;p&gt;one&lt;/p&gt;  &lt;p&gt;two&lt;/p&gt;  &lt;p&gt;three&lt;/p&gt;&lt;/div&gt;\n\n要实现的效果：将two变红\n\n\nnth-child()的方式:\n\n\n# CSSp:nth-child(2)&#123;color:red;&#125;\n\n\n\nnth-of-type()的方式:\n\n\n# CSSp:nth-of-type(2)&#123;color:red;&#125;\n\n效果：\n在同辈元素都相同的情况下两个用法效果一样\n2.用法相同效果不同的情况示例二：# HTML代码&lt;div class=&quot;main&quot;&gt;  &lt;p&gt;one&lt;/p&gt;  &lt;div&gt;div&lt;/div&gt;  &lt;p&gt;two&lt;/p&gt;  &lt;p&gt;three&lt;/p&gt;&lt;/div&gt;\n要实现的效果：同样将two变红\n\n\n先看nth-of-type()的方式:\n\n\n# CSSp:nth-of-type(2)&#123;color:red;&#125;\n效果：\n\n\n再来看nth-child()的方式:\n\n\n# CSSp:nth-child(2)&#123;color:red;&#125;\n效果：\n3.用法不同效果相同的情况示例三：# HTML代码&lt;div class=&quot;main&quot;&gt;  &lt;p&gt;one&lt;/p&gt;  &lt;div&gt;div&lt;/div&gt;  &lt;p&gt;two&lt;/p&gt;  &lt;p&gt;three&lt;/p&gt;&lt;/div&gt;\n要实现的效果：同样将two变红\n\n\n先看nth-of-type()的方式:\n\n\n# CSSp:nth-of-type(2)&#123;color:red;&#125;\n\n\n\n再来看nth-child()的方式:\n\n\n# CSSp:nth-child(3)&#123;color:red;&#125;\n\n效果：\n用法总结从以上三个示例可以看出：\n\n1.在所有子元素都相同的情况下，两种用法效果相同；\n2.在子元素不同的情况下，:nth-of-type选择的是相同（同种元素）元素中的第几个，而:nth-child选择的其父辈元素下面的第几个子元素；\n\n","categories":["javascript"],"tags":["css","伪类选择器"]},{"title":"使用gulp插件快速开发项目","url":"/2017/07/16/%E4%BD%BF%E7%94%A8gulp%E6%8F%92%E4%BB%B6%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE/","content":"\n\n\n简介：&ensp;&ensp;&ensp;&ensp;gulp有着丰富的插件库，她能自动化地完成javascript、coffee、sass、less、html、image、css 等文件的的测试、检查、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤，能快速提高我们项目的开发效率。\n1.gulpfile.js基本配置示例：&ensp;&ensp;&ensp;&ensp;通过此配置示例可以让我们快速编写js,css代码并打包压缩文件，减少文件资源大小。\n//导入工具包 require(&#x27;node_modules里对应模块&#x27;)var gulp = require(&#x27;gulp&#x27;); //本地安装gulp所用到的地方var sass = require(&#x27;gulp-sass&#x27;);//将scss文件编译成浏览器可识别的cssvar minifycss = require(&#x27;gulp-minify-css&#x27;);//压缩css文件，减小文件大小，并给引用url添加版本号避免缓存var cleancss = require(&#x27;gulp-clean-css&#x27;);//压缩css文件，减小文件大小，并给引用url添加版本号避免缓存var livereload = require(&#x27;gulp-livereload&#x27;);//监听文件发生变化时，浏览器自动刷新页面var babel = require(&#x27;gulp-babel&#x27;);//将ES6编译成ES5var uglify = require(&#x27;gulp-uglify&#x27;);//压缩jsvar autoprefixer = require(&#x27;gulp-autoprefixer&#x27;);//根据设置浏览器版本自动处理浏览器前缀//定义一个sass任务（自定义任务名称）gulp.task(&#x27;sass&#x27;, function () &#123;    gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件        .pipe(sass()) //该任务调用的模块        .pipe(cleancss(&#123;            advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]            compatibility: &#x27;ie7&#x27;,//保留ie7及以下兼容写法 类型：String 默认：&#x27;&#x27;or&#x27;*&#x27; [启用兼容模式； &#x27;ie7&#x27;：IE7兼容模式，&#x27;ie8&#x27;：IE8兼容模式，&#x27;*&#x27;：IE9+兼容模式]            keepBreaks: true,//类型：Boolean 默认：false [是否保留换行]            keepSpecialComments: &#x27;*&#x27;            //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀        &#125;))        .pipe(autoprefixer(&#123;            browsers: [&#x27;last 2 versions&#x27;, &#x27;Android &gt;= 4.0&#x27;],            cascade: true, //是否美化属性值 默认：true             remove:true //是否去掉不必要的前缀 默认：true         &#125;))        .pipe(gulp.dest(&#x27;./css&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）        .pipe(livereload());//监听文件发生变化时，浏览器自动刷新页面&#125;);//定义一个babel任务（自定义任务名称）编译jsgulp.task(&#x27;babel&#x27;, function () &#123;    gulp.src(&#x27;./src/**/*.js&#x27;) //该任务针对的文件        .pipe(babel(&#123;            presets: [&#x27;es2015&#x27;]        &#125;)) //该任务调用的模块        .pipe(livereload())//监听文件发生变化时，浏览器自动刷新页面        .pipe(uglify(&#123; //压缩js            // mangle: false,//类型：Boolean 默认：true 是否修改变量名            // compress: true//类型：Boolean 默认：true 是否完全压缩        &#125;))        .pipe(gulp.dest(&#x27;./js&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);gulp.task(&#x27;auto&#x27;, function () &#123;    gulp.watch(&#x27;./sass/**/*.scss&#x27;, [&#x27;sass&#x27;]);    gulp.watch(&#x27;./src/**/*.js&#x27;, [&#x27;babel&#x27;]);    // livereload.listen();&#125;); gulp.task(&#x27;default&#x27;,[&#x27;sass&#x27;,&#x27;auto&#x27;,&#x27;babel&#x27;]); //定义默认任务// 通配符路径匹配示例：// “src/a.js”：指定具体文件；// “*”：匹配所有文件    例：src/*.js(包含src下的所有js文件)；// “**”：匹配0个或多个子文件夹    例：src/**/*.js(包含src的0个或多个子文件夹下的js文件)；// “&#123;&#125;”：匹配多个属性    例：src/&#123;a,b&#125;.js(包含a.js和b.js文件)  src/*.&#123;jpg,png,gif&#125;(src下的所有jpg/png/gif文件)；// “!”：排除文件    例：!src/a.js(不包含src下的a.js文件)；//gulp.task(name[, deps], fn) 定义任务  name：任务名称 deps：依赖任务名称 fn：回调函数//gulp.src(globs[, options]) 执行任务处理的文件  globs：处理的文件路径(字符串或者字符串数组) //gulp.dest(path[, options]) 处理完后文件生成路径\n\n配置文件详解：执行一个任务分三步走：1.导入工具包 require(‘node_modules里对应模块’)  \nvar gulp = require(&#x27;gulp&#x27;); //本地安装gulp所用到的地方\n\n2.定义一个任务（自定义任务名称）  \ngulp.task(&#x27;test&#x27;, function () &#123;  gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件      .pipe(test())      .pipe(gulp.dest(&#x27;./css&#x27;)) //将会在css文件夹下生成.css文件（复制文件目录及文件）&#125;)\n3.执行任务：cmd命令提示符 \ngulp test\n如果只是简单的配置了上面部分，每当我们修改了代码都需要重新执行命令gulp test,而且如果有多个任务就要执行多个命令，为了避免这么繁琐的操作可以加上如下配置：gulp.task(&#x27;auto&#x27;, function () &#123;    gulp.watch(&#x27;./src/**/*.js&#x27;, [&#x27;test&#x27;]);&#125;);gulp.task(&#x27;default&#x27;,[&#x27;auto&#x27;,&#x27;test&#x27;]); //定义默认任务\n这样我们只需要输入一次命令gulp,就可以监听到每次代码的修改，自动帮我们编译，减少了很多繁琐的操作。\n2.使用gulp编译css1.gulp-sass的使用：1.简介：SASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。2.本地安转：npm install gulp-less –save-dev3.配置gulpfile.js1.配置：\n//导入sass工具包var sass = require(&#x27;gulp-sass&#x27;);//定义一个sass任务（自定义任务名称）gulp.task(&#x27;sass&#x27;, function () &#123;    gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件        .pipe(sass(&#123;        outputStyle: &#x27;compact&#x27;  //代码风格      // nested：嵌套缩进的css代码，它是默认值。      // expanded：没有缩进的、扩展的css代码。      // compact：简洁格式的css代码。      // compressed：压缩后的css代码。        &#125;)) //该任务调用的模块        .pipe(gulp.dest(&#x27;./css&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);\n\n2.sass使用示例：\n$blue : #1875e7;　.class &#123;    font-size: 12px;&#125;.main&#123;    color:$blue;    @if 1 + 1 == 2 &#123;         border: 1px solid red;    &#125;@if 5 &lt; 3 &#123;         border: 2px dotted blue;     &#125;    .parent&#123;        margin-left:10px + 20px;        &amp;:hover&#123;            cursor: pointer;            @extend .class;        &#125;    &#125;&#125;\n\n4.执行任务：命令提示符：gulp sass\n5.编译结果：\n2.gulp-minify-css的使用：1.插件介绍：压缩css文件，减小文件大小，并给引用url添加版本号避免缓存2.本地安转：npm install gulp-minify-css –save-dev。3.配置gulpfile.js1.配置\nvar minifycss = require(&#x27;gulp-minify-css&#x27;);//定义一个sass任务（自定义任务名称）gulp.task(&#x27;sass&#x27;, function () &#123;    gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件        .pipe(sass(&#123;            outputStyle: &#x27;compact&#x27;  //代码风格        // nested：嵌套缩进的css代码，它是默认值。        // expanded：没有缩进的、扩展的css代码。        // compact：简洁格式的css代码。        // compressed：压缩后的css代码。        &#125;)) //该任务调用的模块        .pipe(minifycss(&#123;            advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]            compatibility: &#x27;ie7&#x27;,//保留ie7及以下兼容写法 类型：String 默认：&#x27;&#x27;or&#x27;*&#x27; [启用兼容模式； &#x27;ie7&#x27;：IE7兼容模式，&#x27;ie8&#x27;：IE8兼容模式，&#x27;*&#x27;：IE9+兼容模式]            keepBreaks: true,//类型：Boolean 默认：false [是否保留换行]            keepSpecialComments: &#x27;*&#x27;            //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀        &#125;))        .pipe(gulp.dest(&#x27;./css&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);\n2.使用示例：\n4.执行任务：命令提示符：gulp sass\n5.编译结果：编译之后的css文件被压缩了\n3.gulp-autoprefixer：1.插件介绍：根据设置浏览器版本自动处理浏览器前缀2.本地安转：npm install gulp-autoprefixer –save-dev。3.配置gulpfile.js1.配置\nvar autoprefixer = require(&#x27;gulp-autoprefixer&#x27;);//定义一个sass任务（自定义任务名称）gulp.task(&#x27;sass&#x27;, function () &#123;    gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件        .pipe(sass(&#123;            outputStyle: &#x27;compact&#x27;  //代码风格        // nested：嵌套缩进的css代码，它是默认值。        // expanded：没有缩进的、扩展的css代码。        // compact：简洁格式的css代码。        // compressed：压缩后的css代码。        &#125;)) //该任务调用的模块        .pipe(autoprefixer(&#123;            browsers: [&#x27;last 2 versions&#x27;, &#x27;Android &gt;= 4.0&#x27;],            cascade: true, //是否美化属性值 默认：true             remove:true //是否去掉不必要的前缀 默认：true         &#125;))        .pipe(gulp.dest(&#x27;./css&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);\n2.使用示例：\n4.执行任务：命令提示符：gulp sass\n5.编译结果：浏览器中的编译结果：\n3.使用gulp编译js1.gulp-babel的使用：1.介绍：gulp-babel是可以将ES6编译成大多数浏览器可识别的ES5规范2.本地安转：1.npm install gulp-babel –save-dev2.npm install babel-preset-es2015 –save-dev\n3.配置gulpfile.js1.配置：\n//导入babel工具包var less = require(&#x27;gulp-babel&#x27;);//定义一个babel任务（自定义任务名称）//定义一个babel任务（自定义任务名称）编译jsgulp.task(&#x27;babel&#x27;, function () &#123;    gulp.src(&#x27;./src/**/*.js&#x27;) //该任务针对的文件        .pipe(babel(&#123;            presets: [&#x27;es2015&#x27;]        &#125;)) //该任务调用的模块        .pipe(gulp.dest(&#x27;./js&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);\n\n2.ES6使用示例：\n\n4.执行任务：命令提示符：gulp babel\n5.编译结果：\n2.gulp-uglify的使用：1.介绍：压缩js代码2.本地安转： npm install gulp-uglify –save-dev3.配置gulpfile.js1.配置：\n//导入uglify工具包var uglify = require(&#x27;gulp-uglify&#x27;);//定义一个babel任务（自定义任务名称）编译jsgulp.task(&#x27;babel&#x27;, function () &#123;    gulp.src(&#x27;./src/**/*.js&#x27;) //该任务针对的文件        .pipe(babel(&#123;            presets: [&#x27;es2015&#x27;]        &#125;)) //该任务调用的模块        .pipe(uglify(&#123; //压缩js         // mangle: false,//类型：Boolean 默认：true 是否修改变量名         // compress: true//类型：Boolean 默认：true 是否完全压缩        &#125;))        .pipe(gulp.dest(&#x27;./js&#x27;)) //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;);\n\n2.ES6使用示例：\n\n4.执行任务：命令提示符：gulp babel\n5.编译结果：\ngulp插件库还有其他很多优秀的插件，可以根据自己的需要引入。此dome在我的github上，可以下载自行查看https://github.com/xiongcao/project-gule\n","categories":["工具"],"tags":["gulp"]},{"title":"使用gulp自动化构建前端项目","url":"/2017/07/09/%E4%BD%BF%E7%94%A8gulp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/","content":"\n\n\ngulp简介：&ensp;&ensp;&ensp;&ensp;gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成，从而大大提高我们的工作效率。\n&ensp;&ensp;&ensp;&ensp;gulp是基于Nodejs的自动任务运行器,她能自动化地完成javascript、coffee、sass、less、html、image、css 等文件的的测试、检查、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。\n环境搭建：1.安装nodeJS1.gulp是基于nodejs，所以需要安装nodejs。2.自己去node官网下载nodejs安装。\n2.npm工具说明：npm（node package manager）nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）；\n使用npm安装插件：npm install &lt;name&gt; [-g] [–save-dev]；1.name: node插件名称。例：npm install gulp-sass –save-dev；\n2.-g: 全局安装,可以通过命令行在任何地方调用它。如果不写-g则使非全局安装，将安装在定位目录的node_modules文件夹下，通过require()调用；  \n3.–save: 将保存配置信息至package.json（package.json是nodejs项目配置文件）；\n4.-dev: 保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点；\n3.安装gulp1.npm install gulp -g；\n4.新建package.json文件1.说明：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件；\n2.通过命令行新建：npm init， 创建过程中会提示让输入各种信息，可以一直回车忽略它。\n5.新建gulpfile.js文件1.说明：gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件2.新建gulpfile.js文件示例  \n//导入工具包 require(&#x27;node_modules里对应模块&#x27;)var gulp = require(&#x27;gulp&#x27;); //本地安装gulp所用到的地方var sass = require(&#x27;gulp-sass&#x27;);var minifycss = require(&#x27;gulp-minify-css&#x27;);//压缩css插件var cleancss = require(&#x27;gulp-clean-css&#x27;);//压缩css插件 //定义一个sass任务（自定义任务名称）gulp.task(&#x27;sass&#x27;, function () &#123;    gulp.src(&#x27;./sass/**/*.scss&#x27;) //该任务针对的文件        .pipe(sass()) //该任务调用的模块        .pipe(cleancss(&#123;            advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]            compatibility: &#x27;ie7&#x27;,//保留ie7及以下兼容写法 类型：String 默认：&#x27;&#x27;or&#x27;*&#x27; [启用兼容模式； &#x27;ie7&#x27;：IE7兼容模式，&#x27;ie8&#x27;：IE8兼容模式，&#x27;*&#x27;：IE9+兼容模式]            keepBreaks: true,//类型：Boolean 默认：false [是否保留换行]            keepSpecialComments: &#x27;*&#x27;            //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀        &#125;))        .pipe(gulp.dest(&#x27;./css&#x27;)); //将会在css文件夹下生成index.css（复制文件目录及文件）&#125;); gulp.task(&#x27;default&#x27;,[&#x27;sass&#x27;]); //定义默认任务 //gulp.task(name[, deps], fn) 定义任务  name：任务名称 deps：依赖任务名称 fn：回调函数//gulp.src(globs[, options]) 执行任务处理的文件  globs：处理的文件路径(字符串或者字符串数组) //gulp.dest(path[, options]) 处理完后文件生成路径\n\n6.运行gulp1.gulp [name]:  gulpfile.js里面定义的模块的名称 例如:gulp sass。2.gulp default: 如果定义了默认任务gulp.task(‘default’,[‘sass’])可直接执行gulp命令。\n&ensp;&ensp;&ensp;&ensp;到此为止使用gulp自动化构建前端项目的环境已经配置完成了，接下来就是我们自己去安装相应的插件来完善项目了。","categories":["工具"],"tags":["gulp"]}]